[
    {
        "url": "https://github.com/rd4com/mojo-learning/blob/main/LICENSE",
        "content": "MIT License\n\nCopyright (c) 2023 rd4com\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n"
    },
    {
        "url": "https://github.com/rd4com/mojo-learning/blob/main/tutorials/README.md",
        "content": "\n\n# 📖 Learning mojo language\n###  ⚠️  not affiliated with Modular or Mojo\n\n&nbsp; \n\n### [🔍 Why](/why.md) \n### [🔦 Introduction](/introduction.md)\n### [🫵 corrections and contributions](/contribute.md)\n\n\n&nbsp; \n# [🔁 Python land and mojo land, PythonObject](python-world-mojo-world.md) \nnote: need revision for better accessibility\n\n# [🛣️ 🚌 multi-core (parallelize) with simd](multi-core-parallelize-with-simd%20.md) \nsimd and parallelize.\n\n# [🪄 calling mojo functions from python ](calling-mojo-functions-in-python.md)\nusing pointers an ctype\n\n# [🐍 using python in mojo: a to z](using-python-in-mojo.md)\nfirst steps and dancing\n\n# [🧬 Parameters, Alias, Struct parameter deduction, more](parameters-alias-struct-parameter-deduction.md)\nParameterize! (compile time meta-programming) \n\n# [🔥 With blocks: with my_struct(1) as v ](with-blocks-for-struct-parametric-minimal-raise.md)\nwith blocks from struct (parametric/minimal/raise)\n\n# [🏃 (SPEED) Parametric struct through CPU registers](parametric-struct-trough-cpu-registers.md)\nthe @register_passable decorator\n\n# [🏞️ getattr: dynamic and static struct members](getattr-dynamic-and-static-struct-members.md)\n\nthe_instance.method_not_defined() handled\n\n# [🤹 making lists of structs with magic operators](lists-of-structs-magic-operators-pre-lifetimes.md)\nunsafe references abilities until lifetimes\n\n# 🫙 [struct as a namespace (@staticmethod)](struct-as-namespace.md)\nexample: wrap python functions\n\n# [🏳️ make test builds using a custom flag](make-test-builds-using-a-custom-flag.md)\nmojo build program.mojo -D...\n\n# [🕯️ reader.read\\[Int32,\"swap\"\\](3) in 45 lines](reader-in-few-lines-with-endian-ness.md)\nv0.4.0: powerfull magic \n\n# [🔮 Autotune: optimization made easy](autotune-optimize-by-search-and-benchmark.md)\nEasy to use\n\n# [🔥 making compile time functions](compile-time-functions.md)\nPointer[Int] of squared numbers\n\n# [🧹 ASAP: will call ```__del__``` when last used](memory-asap-and-destructor-behaviours.md)\nwhen do del get called on instance\n\n# [🏗️ moveinit 💿💿 copyinit 🐿️ takeinit](moveinit-copyinit-takeinit.md)\nimplement in struct: copy of instance, move, taking move\n\n# 🤙 [callbacks trough parameters](callbacks-trough-parameters.md)\ntoy markdown generator as an example\n\n# [🌊 256Hz: simd cosine and plot it](vectorise-simd-cosine.md)\none cycle by vectorizing simd instructions, plot with python\n\n# [🦜 env, argv and param_env (for alias)](env-argv-param_env-for-parameters.md)\narguments: command-line, env, alias\n\n# [⌨️ introduction to types](introduction-to-types.md)\nsyntax and concepts: not complicated\n\n# [Try & Except: ✋->⚠️->⛑️->🩹->👍 ](try-and-except-errors-handling.md)\nraise custom errors and recover (with example)\n\n# [📫 find out changes and improvements when there is a new update](what-have-change-when-there-is-a-new-update.md)\nchangelogs for new comers\n\n\n"
    },
    {
        "url": "https://github.com/rd4com/mojo-learning/blob/main/tutorials/autotune-optimize-by-search-and-benchmark.md",
        "content": "# 🔮 Autotune: optimization made easy\n> with 0.4.0\n#### ⚠️ untested code, there might be bugs\n\n### how it determine the optimal choice\nBy passing an evaluator function.\n\nThat function will determine if a choice is better or not.\n\nIt is needed because someone might want to optimise for ram usage instead of speed for example, or for another array size.\n\nIn that example, we are optimizing for speed, and will measure it using ```now()``` from time package.\n\n```python\nfrom autotune import autotune, search\n\n#let's grab it to demonstate the autotune\nfrom algorithm import vectorize\n\n#to determine the maximum value of an integer\nfrom math.limit import max_finite\n\n#to perform benchmarks (mojo also does provide a benchmark function if needed)\nfrom time import now\n\n#the signature of the function to optimize\n#(the_function_implementation)\nalias how_function_look_like = fn()->Int\n\n#use another type by making one modification here\nalias type_to_use = DType.int8\nalias simd_width_of_type = simdwidthof[type_to_use]()\n\n#optimize for 256 elements\nalias total_elements = 2**8\n\n#marked with adaptive\n@adaptive\nfn the_function_implementation()->Int:\n    \n    # use autotune: all potential values of width to test\n    alias width_to_use = autotune(1, 2, 4, 8, 16, 32, 64 , 128)\n    \n    #allocate total_elements of type_to_use\n    var elements = DTypePointer[type_to_use].alloc(total_elements)\n\n    @parameter\n    fn vectorization[group_size:Int](base_index:Int):\n        var numbers = elements.simd_load[group_size](base_index)\n        #simd squaring of group_size elements * group_size elements\n        numbers = numbers * numbers\n        elements.simd_store[group_size](base_index,numbers)\n    \n    #note the usage of width_to_use\n    #autotune help to determine the optimal value of it\n    vectorize[width_to_use,vectorization](total_elements)\n    \n    #deallocate\n    elements.free()\n\n    #just for printing later\n    return width_to_use\n\n#the function that gonna help determine what is the optimal choice\nfn the_performance_evaluator(funcs: Pointer[how_function_look_like], total_candidates: Int) -> Int:\n\n    #set the best performance(time spent) to the highest value\n    var best_performance:Int = max_finite[DType.int64]().__int__()\n    var best_candidate = 0\n    \n    print(\"start searching for best candidate\")\n    \n    #loop over all candidate functions\n    for candidate_number in range(total_candidates):\n        #get the candidate function\n        let candidate_function = funcs.load(candidate_number)\n        var width_used = 0\n        \n        let start = now()\n        \n        #run the function 100000 times\n        for i in range(100000):\n            width_used = candidate_function()\n        \n        let time_it_took = now()-start\n\n        #if it is better, store the index of the candidate\n        if time_it_took<best_performance:\n            #here check if the width is not too big\n            #because we check for unusable values too in autotune() above\n            #the reason is to be able to test different types\n            if width_used <= simd_width_of_type:\n                best_candidate = candidate_number\n                best_performance = time_it_took\n        \n        #this is the width_to_use used in that benchmark:\n        print(\"\\t width used:\",width_used)\n        #how much time to run 100000 times the function\n        print(\"\\t\\t benchmark: \",time_it_took)\n    \n    print(\"search is done\")\n    #return the index of the optimal candidate function\n    return best_candidate\n\nfn main():\n\n    #will store the optimal function based on the benchmark\n    alias most_performant_implementation: how_function_look_like\n\n    #run the performance evaluator to determine most_performant_implementation\n    search[\n        how_function_look_like,\n        VariadicList(the_function_implementation.__adaptive_set),\n        the_performance_evaluator -> most_performant_implementation\n    ]()\n\n    print(\"\")\n    print(\"let's use the optimal function:\")\n    \n    # call the best implementation\n    let width_used = most_performant_implementation()\n    \n    print(\"\\tbest implementation simdwidth is\",width_used)\n    \n    #what is the actual maximal width of that type\n    print(\"\")\n    print(\"max simdwidth of type_to_use is\",simd_width_of_type)\n```\n## output:\n```\nstart searching for best candidate\n         width used: 1\n                 benchmark:  12326435\n         width used: 2\n                 benchmark:  15592902\n         width used: 4\n                 benchmark:  6721930\n         width used: 8\n                 benchmark:  3742553\n         width used: 16\n                 benchmark:  3113805\n         width used: 32\n                 benchmark:  2480954\n         width used: 64\n                 benchmark:  2342148\n         width used: 128\n                 benchmark:  2249421\nsearch is done\n\nlet's use the optimal function:\n        best implementation simdwidth is 32\n\nmax simdwidth of type_to_use is 32\n```\n##### *this page is a community effort and may contains errors. please contribute any corrections if needed.*\nFor better examples, the official mojo website is the place to go:\n- see how [Matmul](https://docs.modular.com/mojo/notebooks/Matmul.html) determine the perfect tile size."
    },
    {
        "url": "https://github.com/rd4com/mojo-learning/blob/main/tutorials/callbacks-trough-parameters.md",
        "content": "# 🤙 callbacks trough parameters\n```python\n@value\nstruct markdown:\n    var content: String\n\n    fn __init__(inout self):\n        self.content = \"\"\n\n    def render_page[f: def()->object](self,file=\"none\"):\n        self.content = \"\"\n        f()\n\n    fn __ior__(inout self,t:String):\n        self.content+=t\n\nvar md = markdown()\n\ndef readme():\n    md |= '''\n    # hello mojo\n    this is markdown\n    ```python\n    fn main():\n        print(\"ok\")\n    ```\n    '''\n    footer()\n\ndef footer():\n    md |= '''\n    > Page generated\n    '''\n\ndef main():\n    md = markdown()\n    md.render_page[readme](file=\"README.md\")\n    print(md.content)\n```\n\noutput:\n\n\n# hello mojo\nthis is markdown\n```python\nfn main():\n    print(\"ok\")\n```\n\n> Page generated\n\n"
    },
    {
        "url": "https://github.com/rd4com/mojo-learning/blob/main/tutorials/calling-mojo-functions-in-python.md",
        "content": "# 🔥🐍 calling mojo functions from python\n> with 0.4.0\n\n> ⚠️ not ready for use as it is, not tested and have unfreed pointers\n\n\n\n\n\nBuilding a wrapper with all thoses features:\n- [VariadicList](https://docs.modular.com/mojo/stdlib/utils/list.html#variadiclist) for the arguments types\n- [@noncapturing](https://docs.modular.com/mojo/changelog.html#week-of-2023-04-10) to keep the global scope clean\n- [import_module](https://docs.modular.com/mojo/stdlib/python/python.html#import_module)\n- [PythonObject.\\_\\_getattr\\_\\_()](https://docs.modular.com/mojo/stdlib/python/object.html#getattr__)\n- [Parametrized function](https://docs.modular.com/mojo/programming-manual.html#defining-parameterized-types-and-functions)\n- struct parameter deduction\n\n\nThe function is passed to python using a pointer, as an integer.\n\n*note: it is memory unsafe, not a feature*\n\n#### main.mojo\n```python\nfrom python import Python\n\nfn get_wrapper[fsig:AnyType](ret_type:StringLiteral,f:fsig,*args_types:StringLiteral) raises -> PythonObject:\n    let ctypes = Python.import_module(\"ctypes\")\n    let tmp_ = Pointer[fsig].alloc(1)\n    tmp_.store(0,f)\n    let tmp = (ctypes.CFUNCTYPE(ctypes.c_void_p)).from_address(tmp_.__as_index())\n\n    let py_obj_argtypes = PythonObject([])\n\n    for i in range(args_types.__len__()):\n        py_obj_argtypes.append(ctypes.__getattr__(args_types[i]))\n    tmp.argtypes = py_obj_argtypes\n    tmp.restype = ctypes.__getattr__(ret_type)\n    #note: tmp_ is never freed\n    return tmp\n\ndef main():\n\n    Python.add_to_path(\"./\")\n    let py_mymodule = Python.import_module(\"python_custom_package\")\n\n    @noncapturing\n    fn mojo_print(p:Int)->Int:\n        print(p)\n        return p+1\n    \n    w = get_wrapper(\"c_int\",mojo_print,\"c_int\")\n    \n    py_mymodule.call_mojo_print(w)\n\n\n    @noncapturing\n    fn m_sum(arg:Pointer[Float64],size:Int)->Float64:\n        var total:Float64 = 0.0\n        for i in range(size):\n            total+=arg.load(i)\n        return total\n    \n    w2 = get_wrapper(\"c_double\",m_sum,\"c_void_p\",\"c_int\")\n    py_mymodule.call_sum(w2)\n```\n\n#### python_custom_package.py\n```python\nimport numpy as np\n\ndef call_mojo_print(mojo_print):\n    res = mojo_print(123)\n    for i in range(10):\n        res = mojo_print(res)\n\n\ndef call_sum(sum):\n    elements = 100\n    array = np.random.random(elements)\n    \n    res = sum(array.ctypes.data,elements)\n    _ = array\n    \n    print(res)\n\n    #notes:\n    #print(array.dtype)   #float64\n    #print(array.strides) #8\n```\n\n\n\n#### Overview:\n- Create a pointer to the mojo function\n- Create a PythonObject with ctype imported_module\n- load the address as a CFUNCTYPE\n- assign the return type and argument types from variadic list\n- Pass the PythonObject into python land\n- Call the PythonObject from there\n- Pointer is left not freed, *need to be freed*\n\n"
    },
    {
        "url": "https://github.com/rd4com/mojo-learning/blob/main/tutorials/compile-time-functions.md",
        "content": "# 🪄 making compile time functions: same as the runtime ones\n> with v0.4.0\n\nExecute a function at comptime\n```python\n#can be used both during comptime and runtime\nfn squared(n:Int)->Pointer[Int]:\n    let tmp = Pointer[Int].alloc(n)\n    for i in range(n):\n        tmp.store(i,i*i)\n    return tmp\n\ndef main():\n\n    #alias: during comptime\n    alias n_numbers = 5\n    alias precaculated = squared(n_numbers)\n\n    for i in range(n_numbers):\n        print(precaculated.load(i))\n    \n    precaculated.free()\n```\n\n#### what is the code doing\nReturns a pointer with pre-calculated values during compilation and using it at runtime.\n#### how to call squared() during runtime\nBy not using alias.\n```python\n# using var instead of alias\nvar precaculated = squared(n_numbers)\n```\n"
    },
    {
        "url": "https://github.com/rd4com/mojo-learning/blob/main/tutorials/env-argv-param_env-for-parameters.md",
        "content": "# 🦜 env, argv and param_env (for alias)\n> with v0.5.0\n## Overview\n```env```: defined in the os ENV\n\n```argv```: get command-line arguments\n\n```param_env```: for alias, available at compile time\n\n## param_env\nThey are retreived when mojo build the program.\n\nSo they can be used to do compile-time logic.\n\n```mojo build -D build_message=\"now faster with simd!\" -D simd_width=8 app.mojo```\n```python\nfrom sys.param_env import is_defined,env_get_int,env_get_string\n\nfn get_width() -> Int:\n    @parameter\n    if is_defined[\"simd_width\"]():\n        @parameter\n        if env_get_int[\"simd_width\"]() > simdwidthof[DType.uint8]():\n            # simd_width too big, default to max\n            return simdwidthof[DType.uint8]()\n        else:\n            return env_get_int[\"simd_width\"]()\n    else:\n        return 1\n\nalias simd_width:Int = get_width()\n\n#shorter way for default value:\nalias build_message:StringLiteral = env_get_string[\"build_message\",\"none\"]()\n\nfn main():\n    @parameter\n    if build_message != \"none\":\n        print(\"build message:\",build_message)\n\n    var v = SIMD[DType.uint8,simd_width]()\n    print(v)\n```\nStart the program:\n\n```./app```\n\nOutput:\n\n    build message: now faster with simd!\n    [0, 0, 0, 0, 0, 0, 0, 0]\n## env\nIt is not \"only a mojo thing\", it is widely used by operating systems and apps.\n\n##### Example:\n```python\nfrom os import getenv\n\nfn main():\n    var k = getenv(name= \"ENV_VARIABLE_NAME\", default= \"none\")\n    if k == \"none\":\n        print(\"it is default value\")\n        return\n```\n\n\n## args\n> ⚠️ the example do not include error checking, so don't use it as it is\n\nBuild the app: ```mojo build app.mojo```\n\n    ./app \"The number is\" 3\n    ./app \"The number is\" 4\nThey are retrieved each time we run the program.\n\n```python\nfrom sys import argv\n\nfn main() raises:\n    var arguments = argv()\n    let size = len(arguments)\n\n    var message = arguments[1]\n    #convert to an integer\n    var the_number:Int = atol(arguments[2])\n\n    print(message,the_number)\n```\n"
    },
    {
        "url": "https://github.com/rd4com/mojo-learning/blob/main/tutorials/getattr-dynamic-and-static-struct-members.md",
        "content": "\n\n# 🏞️ getattr: dynamic and static struct members\n\n\n> with v0.5.0\n\n```__getattr__()``` is a feature that makes it possible to design flexible and versatile structs in mojo (like other features too). \n\n\n\nIt feels like merging the static and the dynamic world.\n\n\n\n\nTheses features are just there when needed, no obligation to use them all the time!\n\nHere is an example, note that ```try:``` and ```except:``` blocks are available in mojo and python!\n\n### my_package.py\n```python\ndef method_from_package():\n    return \"Called on package\"\n\ndef package_double_the_value(arg):\n    return arg*2\n\npackage_value = 123\n```\n\n### The struct (in a .mojo or .🔥 file)\n\nLet implement one that can refer to both static and dynamic struct members.\n\nThat way, we can do both \"mojo things\" and \"python things\" in a seamless manner.\n\n\n```python\nfrom python import Python\n\n@value\nstruct PackageHelper:\n\n    var my_package: PythonObject\n    var struct_value: Int\n    \n    def __init__(inout self):\n        Python.add_to_path(\".\")\n        self.my_package = Python.import_module(\"my_package\")\n        \n        self.struct_value = 456\n\n    def method_from_struct(self) -> String:\n        return \"called on struct\"\n\n    def __getattr__(inout self,name:StringLiteral) ->PythonObject:\n        return self.my_package.__getattr__(name) \n```\nThe ```__getattr__()``` implementation is quite small, but is powerfull:\n\nIf a struct do not define a requested attribute, it will call that function and pass the name of it.\n\nIn this implementation, if the attribute is not in the struct, get it from the PythonObject.\n\nThat way, it is possible to do ```the_struct_ìnstance.anything``` in a dynamic manner.\n\nConsider this example for more clarity:\n  - ```struct_instance.method_defined_in_the_struct()```\n    - It works as usual.\n  - ```struct_instance.method_not_defined_in_the_struct()```\n    - Let the```__getattr__(self, the_name)``` handle that!\n\n### The main function\n*(To place just below the mojo struct)*\n```python\ndef main():\n    #create an instance\n    w = PackageHelper()\n    \n    #that attribute is defined in the struct\n    print(w.method_from_struct())\n\n    #that attribute comes from the PythonObject\n    print(w.method_from_package())\n\n    #that attribute is defined in the struct\n    print(w.struct_value)\n\n    #that attribute is defined in the PythonObject\n    print(w.package_value)\n\n    temp_value = PythonObject(1.0)\n    print(w.package_double_the_value(temp_value))\n    temp_value = 1.5\n    print(w.package_double_the_value(temp_value))\n``` \n\n### Notes\n- inside ```def()``` function, ```let``` and ```var``` are optional.\n- struct can store PythonObject type instances.\n- implicit type\n  - temp_value = PythonObject(1.0)\n    - temp_value is of PythonObject type\n  - temp_value = 1.5\n    - instanciated by PythonObject again\n\n\n```try:``` and ```except:``` blocks can be placed in both ```def()``` and ```fn()``` functions\n\n```__getattr__()``` and ```__setattr()__``` were introduced in [Changelog: Week of 2023-04-03](https://docs.modular.com/mojo/changelog.html#week-of-2023-04-03)\n"
    },
    {
        "url": "https://github.com/rd4com/mojo-learning/blob/main/tutorials/introduction-to-types.md",
        "content": "# ⌨️ introduction to types\n> with v0.5.0\n## Declaration of variables\n```let```: immutable, constant, cannot be changed\n\n```var```: variable, can re-assign it another value\n## Types\ndefined after the semi column```:```\n```python\ndef main():\n    let x:Int = 1\n    var y:Int = 1\n    y = 2\n```\n##### common types:\n- Int\n- Float\n- String\n- Bool\n\n##### important:\n- once defined, the type of the variable cannot be changed for another one\n## functions\n##### passing an argument\n```python\ndef PrintNumber(Number:Int):\n    print(Number)\n```\n```python\ndef main():\n    let TheNumber:Int = 1\n    PrintNumber(TheNumber)\n```\n##### returning a value\nthe return type is written after the arrow ```->```\n```python\ndef add(a,b):\n    return a+b\n\ndef add(a:Int ,b: Int)->Int:\n    return a+b\n\ndef add(a:Float64 ,b: Float64)->Float64:\n    return a+b\n```\n##### default arguments value and named arguments\n```python\ndef greet(name:String=\"learner\" ,message: String = \"Hello \"):\n    print(message+name)\n```\n```python\ndef main():\n    greet() #Hello learner\n    greet(name=\"\") #Hello\n    greet(message=\"Greetings \") #Greetings learner\n```\n##### modify an argument from within a function\nadd ```inout``` before the argument name\n\n```python\ndef increase(inout Number: Int):\n    Number+=1\n```\n```python\ndef main():\n    var TheNumber:Int = 0\n    increase(TheNumber)\n    print(TheNumber) # 1\n```\n\n## Structures\nThe ```@value``` for a short example, it simply adds a few methods for us.\n\nThey can also be added manually as needed.\n```python\n@value\nstruct Computer:\n    var cores: Int\n    var is_running: Bool\n    var ram_size: Int\n\n    fn __init__(inout self,cores:Int = 4,state:Bool = False):\n        self.cores = cores\n        self.is_running = state\n        self.ram_size = 1024\n\n    fn start(inout self):\n        self.is_running = True\n        print(\"ram size:\", self.ram_size)\n\ndef ImproveComputer(inout existing:Computer, improved: Computer):\n    existing.cores = improved.cores\n    existing.ram_size = improved.ram_size\n\ndef main():\n    var MyComputer = Computer()\n\n    var NextComputer = Computer(cores=8)\n    NextComputer.ram_size *= 4\n\n    ImproveComputer(MyComputer,NextComputer)\n    \n    MyComputer.start() #ram size: 4096\n```"
    },
    {
        "url": "https://github.com/rd4com/mojo-learning/blob/main/tutorials/lists-of-structs-magic-operators-pre-lifetimes.md",
        "content": "# 🤹 making lists of structs with magic operators (pre-lifetimes)\n\n\n> with v0.5\n\n*note: ⚠️ there could be bugs in the code or errors, please [contribute corrections](/contribute.md)*\n\n\n\n\n&nbsp;\n\n\n\n\n\nIn mojo for now, there is something called *magic operators* .\n\nTheses are used for unsafe references until the day we gonna use lifetimes.\n\n\nThere are a lot of conversation on the github repo of mojo about the lifetimes, proposals and a refinement process.\n\nMore about it can be read on the website of mojo aswell.\n\n\n\n\n&nbsp;\n\n#### [Roadmap: ownership and lifetimes](https://docs.modular.com/mojo/roadmap.html#ownership-and-lifetimes) for more on lifetimes\n\n#### [Documentation: Pointer](https://docs.modular.com/mojo/stdlib/memory/unsafe.html#pointer) the tutorial uses pointers\n\n&nbsp;\n\n\n### ```__get_lvalue_as_address()``` \n  - see [Roadmap: shap edges](https://docs.modular.com/mojo/roadmap.html#sharp-edges)\n  \n  -  returns the address of a instance\n  - ```\n    var x = 1\n    var pointer = __get_lvalue_as_address(x)\n    __get_address_as_lvalue(pointer)=2\n    var with_copyinit = __get_address_as_lvalue(pointer)\n    _ = x #extend lifetime\n    ```\n\n\n### ```__get_address_as_lvalue()```\n  - documentation in [Roadmap: shap edges](https://docs.modular.com/mojo/roadmap.html#sharp-edges)\n  - ```__get_address_as_lvalue(address) = other_instance ``` \n    - will call ``` __del__()``` on existing value at the address (cannot contains nothing)\n  - get an copy instance trough ```__copyinit__```:\n    - ```var x = __get_address_as_lvalue(address)```\n\n\n\n### ```__get_address_as_owned_value()``` \n  - introduced in [Week of 2023-04-17](https://docs.modular.com/mojo/changelog.html#week-of-2023-04-17)\n  -  return the \"original\" instance as owned\n  -  ```__del()__``` will be called on the \"original\" instance when last used\n  -  require extra attention for proper use! (unsafe)\n\n\n### ```__get_address_as_uninit_lvalue()``` \n  - introduced in [Week of 2023-04-17](https://docs.modular.com/mojo/changelog.html#week-of-2023-04-17)\n  -  act like a placement new\n  -  ```__get_address_as_uninit_lvalue(address) = instance```\n     -  address should be allocated\n     -  address should not already contain a value\n     -  will **not** call ``` __del__()``` on value at the address \n     \n\n&nbsp;\n#### Example: list of struct\n> ⚠️ this code have not been tested, require more work\n```python\n@value\nstruct a_struct:\n    var x:Int\n    var y:Int\n\nstruct storage:\n    var data: Pointer[a_struct]\n\n    fn __init__(inout self,capacity:Int):\n        self.data = self.data.alloc(capacity)\n\n    fn __moveinit__(inout self,owned other:Self):\n        #see tutorial on moveinit\n        #__del__() will not be called on \"other\"\n        #with takeinit, __del__() is called on it\n        self.data=other.data\n    \n    fn store(inout self, i:Int,value:a_struct):\n        #placement new on the offset\n        #will not call __del()__ if something was there\n        __get_address_as_uninit_lvalue(self.data.offset(i).address) = value\n    \n    fn get(inout self, i:Int)->a_struct:\n        #returns a __copyinit__() instance, not the original\n        return __get_address_as_lvalue(self.data.offset(i).address)\n    \n    fn replace(inout self, i:Int,value:a_struct):\n        #will call __del__() on the previous value\n        __get_address_as_lvalue(self.data.offset(i).address) = value\n        \n    fn __del__(owned self):\n        # not implemented in the example: placement delete on elements\n        # please contribute solutions, working on it\n        # see __get_address_as_owned_value()\n        # just free() is not enough to have no bugs.\n        self.data.free()\n\ndef main():\n    var collection = storage(capacity=2)\n    \n    for i in range(10):\n        collection.store(0,a_struct(0,1))\n        collection.store(1,a_struct(2,3))\n\n    for i in range(2):\n        let res = collection.get(i)\n        print(res.x,res.y)\n        \n    collection.replace(0,a_struct(1,1))\n\n    for i in range(2):\n        let res = collection.get(i)\n        print(res.x,res.y)\n    \n```\nLifetimes can be manually extended if needed:\n```\nvar x = 1\n#unsafe reference code\n_ = x #extended lifetime\n```\nsee the [ASAP](https://docs.modular.com/mojo/programming-manual.html#behavior-of-destructors). (call del on last use of the instance)\n\n> one revision on Nov 6 2023\n\n[contribute corrections](/contribute.md)"
    },
    {
        "url": "https://github.com/rd4com/mojo-learning/blob/main/tutorials/make-test-builds-using-a-custom-flag.md",
        "content": "# 🏳️ make test builds using a custom flag\nIn mojo, it is possible to do it trough programming!\n\nFor serious testing, the assert functions provided mojo standard library should be used instead.\n\n*Note: testing is very important, and that code have not been tested. not ready for use*\n\n```python\nfrom sys.param_env import is_defined\n\nalias testing = is_defined[\"testing\"]()\n\n#let's do colors for fun!\n@always_inline\nfn expect[message:StringLiteral ](cond:Bool):\n\n    if cond: \n        #print in green\n        print_no_newline(chr(27))\n        print_no_newline(\"[42m\")\n    else: \n        #print in red\n        print_no_newline(chr(27))\n        print_no_newline(\"[41m\")\n\n    print_no_newline(message)\n    \n    #reset to default colors\n    print_no_newline(chr(27))\n    print(\"[0m\")\n\nfn main():\n    @parameter\n    if testing:\n        print(\"this is a test build, don't use in production\")\n\n    @parameter\n    if testing:\n        expect[\"math check\"](3==(1+2))\n        #should print \"math check in green\"\n```\n### pass testing \"flag\":\n```mojo build myfile.mojo -D testing```\n\n```-D customised=1234``` is also possible, \nsee [param_env](https://docs.modular.com/mojo/stdlib/sys/param_env.html)\n\n\n\n\n\n"
    },
    {
        "url": "https://github.com/rd4com/mojo-learning/blob/main/tutorials/memory-asap-and-destructor-behaviours.md",
        "content": "# 🧹 ASAP: will call ```__del__``` when last used\n> with v0.4.0\n\n##### *this page is a community effort and may contains errors. please contribute any corrections if needed.*\n\nIt's wonderfull because mojo free memory as soon as possible.\n\nLifetimes is on the roadmap: [Ownership and Lifetimes](https://docs.modular.com/mojo/roadmap.html#ownership-and-lifetimes).\n\nsource: [Behavior of destructors](https://docs.modular.com/mojo/programming-manual.html#behavior-of-destructors) \n\n\n### using that struct as an example:\n```python\n@value\nstruct ValuePointer:\n    \n    var pointer: Pointer[Int]\n\n    #instantiate\n    def __init__(inout self):\n        #allocate memory\n        self.pointer = Pointer[Int].alloc(1)\n        #store 123\n        self.pointer.store(0,123)\n\n    #delete\n    def __del__(owned self):\n        #free memory\n        self.pointer.free()\n```\n### the challenge:\n```python\ndef main():\n\n    var original = ValuePointer()\n\n    #original is deleted here after last use/access:\n    var copy_of_pointer = original.pointer\n\n    #copy now point to freed memory\n    print(copy_of_pointer.load(0))\n```\n1. original will get deleted after it's last use, the pointer inside will be freed by\nour ```__del__``` function.\n2. copy_of_pointer now point to freed memory and unknown data is printed \n\n\n### the solution:\n```python\ndef main():\n\n    var original = ValuePointer()\n\n    var copy_of_pointer = original.pointer\n\n    print(copy_of_pointer.load(0))\n\n    #original is deleted here after last use/access:\n    _ = original\n```\n\nby assigning original to ```_``` , it's last use will be there.\n\ncopy_of_pointer no will longer point to freed memory.\n\n123 got printed.\n\n"
    },
    {
        "url": "https://github.com/rd4com/mojo-learning/blob/main/tutorials/moveinit-copyinit-takeinit.md",
        "content": "# 🏗️ moveinit 💿💿 copyinit 🐿️ takeinit\n> using v0.4.0\n\nLet's have a look at theses features trough an example,\n\nthey looks like this :\n\n  - ```fn __copyinit__(inout self, borrowed original: Self)```\n    -  original is borrowed and cannot be modified\n    -  original live separately and can get deleted later in the program\n    -  it provides a way to create a copy of an instance\n  - ```fn __moveinit__(inout self, owned original: Self)```\n    -  original is owned, ```__del__``` will never be called on it\n    -  original can't be used in the program anymore \n    -  **^ transfer suffix** is used to call moveinit\n    -  usefull for making sure an instance don't have copies thus is unique\n  - ```fn __takeinit__(inout self, inout original: Self)```\n    - original can be modified\n    - ```__del()__``` will get called on original on last use \n    - usefull to affect a conditional in ```__del__()```\n      - example: don't free pointer if self.dontfree == true\n\n### The illustration:\n```python\nstruct my_type:\n    var id:Int\n    \n    fn __init__(inout self,id:Int):\n        self.id=id\n        print(\"init \"+String(self.id))\n\n    fn __moveinit__(inout self, owned existing: Self):\n        self.id = existing.id\n        print(\"moveinit \"+ String(self.id))\n        \n    fn __copyinit__(inout self, existing: Self):\n        self.id = existing.id+1\n        print('copyinit '+String(+self.id))\n    \n    fn __del__(owned self):\n        print(\"del \"+String(+self.id))\n\nfn separator():\n    print(\"-------------\")\n\nfn main():\n    var original = my_type(id=0)    #init 0\n    \n    separator()\n\n    var copy = original             #copyinit 1\n    \n    separator()\n    \n    var still_original = original^  #moveinit 0\n\n    #cannot use original anymore, because moved\n    #var other = original\n    #would produce an error\n\n```\n\n### Complete output:\n    init 0\n    -------------\n    copyinit 1\n    del 1\n    -------------\n    moveinit 0\n    del 0\n\n*Note: del 0 comes from still_original and not original*\n\n&nbsp;\n\n### ```var original = my_type(id=0)```\nAn instance of my_type is created,\n\nit calls ```fn __init__(inout self,id:Int)```\n\n    init 0\n### ```var copy = original```\nIt will call ```fn __copyinit__(inout self, existing: Self)```\n\nWe get a copy of it:\n\n    copyinit 1\n    del 1\nThe copy get deleted when it is last used in the code.\n\nWe dont use it so it later so it gets deleted here.\n\n### ```var still_original = original^```\n\n\nthe **^ transfer suffix** will call ```__moveinit__(inout self, owned existing: Self)```\n\nwe moved original to still_original and took original as ```owned```:\n- ```__del__()``` have never been called on original\n- del 0 is showed only once\n- it is showed whend still_original gets deleted\n\n&nbsp;\n\n## why moveinit is important and usefull\nWe can make sure that an instance have no copies in the program,\n\nwhen we to pass it to a function, the function could return it:\n```python\nfn from_owned(owned source:my_type)->my_type:\n    #do things\n    return source\n```\n\nOr could assign it to an inout argument:\n```python\nfn move_to(owned source:my_type,inout to: my_type):\n    to = source^ #re transfer it\n    #var tmp = source would produce an error\n    #source can't be used anymore here\n```\n\nIt could also be store inside another struct type passed as inout.\n```python\nfn change_owner(owned some_item:item_type,inout new_owner: owner_type):\n    new_owner.owned_item = some_item^\n```\n\n&nbsp;\n\n### Owned argument does get deleted if not used:\n```python\nfn from_owned(owned arg:my_type):\n    print(\"not used\")\n```\n```in that case, we don't re-transfer arg, so arg will be deleted.```\n\n```__del__()``` is called at the moment of the last use of the instance.\n\n&nbsp;\n\n # 🐿️ takeinit\n```python\nfn __takeinit__(inout self, inout original: Self)\n```\n  - original can be modified\n  - ```__del()__``` will get called on original on last use \n  - usefull to affect a conditional in ```__del__()```\n    - example: don't free pointer if self.dontfree == true\n\n### Example\n ```python\nstruct my_type[T:AnyType]:\n    var ptr:Pointer[T]\n    var freed_allowed:Bool\n    \n    fn __init__(inout self,value:T):\n        self.ptr=self.ptr.alloc(1)\n        self.ptr.store(0,value)\n        self.freed_allowed=True\n        print(\"init\")\n\n\n    fn __takeinit__(inout self, inout existing: Self):\n        self.ptr = existing.ptr\n        self.freed_allowed=existing.freed_allowed\n        existing.freed_allowed = False\n        print(\"takeinit\")\n\n    fn __del__(owned self):\n        if self.freed_allowed == True:\n            print(\"del with free\")\n            self.ptr.free()\n        else:\n            print(\"del without free\")\n        \n\nfn main():\n    var original = my_type[Int](1)\n\n    var x = original\n    #delete original at last use, here:\n    _=original^ \n\n    print(\"freed allowed: \",x.freed_allowed)\n    #x gets deleted here at its last use\n```\n### Complete output:\n    init\n    takeinit\n    del without free\n    del with free\n    freed allowed:  True\n*note: when original gets deleted, it print accordingly: del without free*\n\n&nbsp;\n\nIt is interesting because ```__del()__``` is called on original.\n\nWith ```__moveinit()__``` it is not called on the original.\n\nWith ```__copyinit()__``` original can't be modified because it is borrowed.\n\nBut with ```__takeinit()__```,original can be modified:\n  - ```existing.freed_allowed = False```\n\n\n&nbsp;\n\n> Need further work and help for \\_\\_takeinit\\_\\_(), the page will get updated"
    },
    {
        "url": "https://github.com/rd4com/mojo-learning/blob/main/tutorials/multi-core-parallelize-with-simd .md",
        "content": "\n# 🛣️ 🚌 multi-core (parallelize) with simd\n### 🪮 parallel without simd\n\n```python\nfrom algorithm import parallelize\nfn main():\n\n    @parameter\n    fn compute_number(x:Int): \n        print(x*x)\n        \n    var stop_at = 16\n    var cores = 4\n    \n    #start at 0, end at stop_at (non inclusive)\n    parallelize[compute_number](stop_at,cores)\n```\n\n\n# 🚍 simd\nTo use an analogy, thanks to @PriNova for the inspiration,\n\nsimd can be thought of as autobuses filled with numbers,\n\nwith only one instruction, we can calculate the entire autobus. (in the same amount of time it would have taken to calculate a single number in a non-simd way)\n\nhow much numbers can fit in one autobus depend on the type. (can fit more small types)\n\n```python\nimport math\nfn main():\n    var numbers = SIMD[DType.uint8,8]()\n    \n    # simd instructions:\n\n    # a. fill them whith numbers from 0 to 7\n    numbers = math.iota[DType.uint8,8](0)\n    \n    # b. x*x for each numbers\n    numbers*=numbers\n\n    print(numbers)\n    \n    #[0, 1, 4, 9, 16, 25, 36, 49]\n```\n\n# 🚍 🚍 🛣️ simd in parallel \n\nit is like 4 autobus advancing on 4 seperate highway lanes toward a destination. \n\nthey reach destination more or less at the same time and in the same amount of time it would have taken with only one autobus in a single highway lane. (single core, non multi-core)\n\n\n```python\nfrom algorithm import parallelize\nfrom memory.unsafe import DTypePointer\nfrom sys.info import simdwidthof\nimport math\n\nfn main():\n\n    # how much highway lanes\n    var computer_cores = 4\n\n    alias element_type = DType.int32\n\n    #how much numbers in the autobus:\n    alias group_size = simdwidthof[element_type]()\n    \n    #how much autobus needs to travel:\n    alias groups = 16\n\n    #initialized array of numbers with random values\n    var array = DTypePointer[element_type]().alloc(groups*group_size)\n    \n    @parameter\n    fn compute_number(x:Int):\n        # one autobus:\n        var numbers: SIMD[element_type,group_size]\n        \n        # 3 simd instructions:\n        numbers = math.iota[element_type,group_size](x*group_size)\n        numbers *= numbers\n        array.simd_store[group_size](x*group_size,numbers)\n\n\n    # open the highway\n    parallelize[compute_number](groups,computer_cores)\n    \n    #   parallelize will call compute_number with argument\n    #       x= 0,1,2...groups (non-inclusive)\n\n    for i in range(groups*group_size):\n        var result = array.load(i)\n        print(\"Index:\" , i, \" = \",result)\n\n    array.free()\n```\n\n### [math.iota](https://docs.modular.com/mojo/stdlib/math/math.html#iota) fills an array with incrementing numbers.\n\n### DTypePointer: *simd_store*\nWith an array of 256 elements:\n\nset the first 8 elements:\n- ```array.simd_store[DType.float32,8](0,simd_array_of_8_values)```\n\nset the second 8 elements:\n- ```array.simd_store[DType.float32,8](8,simd_array_of_8_values)```\n\nset the third 8 elements:\n- ```array.simd_store[DType.float32,8](16,simd_array_of_8_values)```\n\n> note: the offset argument is a **multiple of 8** when storing by groups of 8.\n"
    },
    {
        "url": "https://github.com/rd4com/mojo-learning/blob/main/tutorials/numpy-simd.md",
        "content": "\n# simd cosine with np.linspace\nThe simd part need revision,\nit is not good practice. update soon!\n```python\nfrom python import Python\nfrom python import PythonObject\nfrom math import math\n\nstruct np_loader:\n    #Python.import_module(\"numpy\") returns a PythonObject\n    var lib:PythonObject\n    var loaded: Bool\n    fn __init__(inout self):\n        try:        #let see if an error is produced\n            self.lib = Python.import_module(\"numpy\")\n            self.loaded = True\n        except e:   #if there was an error,don't crash, do this\n            self.loaded = False\n    #np[\"linspace\"], \"linspace\" is the key, a StringLiteral\n    fn __getitem__(inout self, key:StringLiteral)raises->PythonObject:\n        #get the attribute \"linspace\" from the python object, and return it\n        return self.lib.__getattr__(key)\n\nfn main() raises:\n    #get numpy from python\n    var np = np_loader()\n    #make sure there was no errors                                    \n    if np.loaded:\n        #get the linspace function from python and call it\n        var python_result = np[\"linspace\"](0, 255,256)          \n        #prepare a simd array of 256 elements\n        var simd_mojo_array = SIMD[DType.float64,256]()         \n\n        # python returns PythonObject therefore they sometimes require\n        # conversion to mojo types in order to use some functions                                                   \n        var pi = np[\"pi\"].to_float64()                          \n\n        #convert array size to mojo int\n        var size:Int=python_result.size.to_float64().to_int()\n        #mojo provide range just like python, that one is a mojo one\n        for x in range(size):\n            #from python float object to mojo float\n            simd_mojo_array[x]=python_result[x].to_float64()    \n\n        #perform the simd cos operation \n        simd_mojo_array = math.cos(simd_mojo_array*(pi*2.0/256.0))\n\n        print(simd_mojo_array)\n```"
    },
    {
        "url": "https://github.com/rd4com/mojo-learning/blob/main/tutorials/parameters-alias-struct-parameter-deduction.md",
        "content": "# 🧬 Parameters, Alias, Struct parameter deduction, more\n\n> with v0.5.0\n\n⚠️ Some examples are \"minimal and simple\", no safe checks are done.\n\nIt is to better illustrate concepts and not clutter the mind, make sure follow good practices and safe coding in your implementations.\n\nLet's learn how to parametrize!\n\n\n\n\n# Start of the tutorial\n> Parameters are compile-time values.\n\nThat example also covers \"Struct parameters deduction\". \n\nIt is very usefull, try to practice playing with it in order to remember and understand it.\n\nNotice how the deduction \"works its way\" up the struct and fill the blanks.\n\nIt feels like the arguments types defines the parameters of the struct, and not the other way around.\n\nIncreased productivity, less screen space used, less repetitive coding:\n\n```python\n@value\nstruct Point3D[XT:AnyType,YT:AnyType,ZT:AnyType]:\n    var x:XT\n    var y:YT\n    var z:ZT\n\n    fn __init__(inout self, x:XT ,y:YT,z:ZT):\n        self.x = x\n        self.y = y\n        self.z = z\n\n# 4️⃣. use parameters of an argument inside the function signature:\nfn to_list_literal(arg:Point3D)-> ListLiteral[arg.XT,arg.YT,arg.ZT]:\n    return ListLiteral(arg.x,arg.y,arg.z)\n\nfn main():\n\n    #1️⃣ Explicit struct parameters:\n    var my_point_d = Point3D[Int64,Int64,Int64](1,2,3)\n    var my_point_e = Point3D[Int64,Float64,Int64](1,2.5,3)\n    \n    #2️⃣ Struct parameters deduction \n        #XT, YT, ZT deduced from argument passed:\n\n    var my_point_a = Point3D(1, 2, 3)         #Int64, Int64, Int64\n\n    var my_point_b = Point3D(1.0, 2.0, 3.0)   #Float64, Float64, Float64\n    \n    var my_point_c = Point3D(1, 2.5, 3)       #Int64, Float64, Int64\n\n    #3️⃣ Re-use the parameters of an instance of Point3D\n    var some:my_point_c.YT = 1.0 #my_point_c.YT is a type (Float64)\n\n    print(to_list_literal(my_point_a)) # [1, 2, 3]\n    print(to_list_literal(my_point_c)) # [1, 2.5, 3]\n```\n#### see [Changelog: v0.5.0-2023-11-2](https://docs.modular.com/mojo/changelog.html#v0.5.0-2023-11-2)\n- Function argument input parameters can now be referenced within the signature of the function\n- Mojo now supports struct parameter deduction\n---\n\n### Automatic parameterization of functions\nsee [Documentation](https://docs.modular.com/mojo/programming-manual.html?q=parameter#automatic-parameterization-of-functions)\n\nOur ```take_dynamic_vector()``` don't take parameters for arg, but DynamicVector is parametric.\n\nThe long form version could look like this:\n```python\nfn take_dynamic_vector[T:AnyType](arg:DynamicVector[T]) -> T:\n```\n\nMojo will create theses for us in order to be more productive.\n\nIt is important to be aware of it in order to understand the language.\n\n```python\nfn take_dynamic_vector(arg:DynamicVector) -> arg.type:\n    let tmp: arg.type = arg[0] #first element of vector\n    return tmp\n\nfn main(): \n    var tmp_a = DynamicVector[Int64]()\n    var tmp_b = DynamicVector[Float64]()\n    var tmp_c = DynamicVector[Bool]()\n\n    tmp_a.push_back(1)\n    tmp_b.push_back(1.5)\n    tmp_c.push_back(True)\n\n    let a:Int64 = take_dynamic_vector(tmp_a)\n    let b = take_dynamic_vector(tmp_b)\n\n    print(a,b)\n\n    #parameters are known at compile time\n    #type is a parameter of DynamicVector\n\n    let d:tmp_c.type = False #tmp_c.type == Bool\n    let e = take_dynamic_vector(tmp_c)\n    print(d==e)\n    \n```\n---\n### \"Pulling\" parameters when needed:\nNote that we refer to the parameter of arg, inside the function signature itself.\n```python\nfn simd_to_dtype_pointer(arg:SIMD)->DTypePointer[arg.type]:\n    var tmp = DTypePointer[arg.type].alloc(arg.size)\n    # just to demonstrate unroll, \n    # simd_store is probably way faster:\n    @unroll\n    for i in range(arg.size):\n        tmp.store(i,arg[i])\n    return tmp\n\nfn simd_to_static_tuple(arg:SIMD)->StaticTuple[arg.size,SIMD[arg.type,1]]:\n    var tmp = StaticTuple[arg.size,SIMD[arg.type,1]]()\n    \n    #Can be unrolled, because arg.size is known at compile time.\n    #Parameters of simd: SIMD[TYPE,SIZE]\n    \n    @unroll\n    for i in range(arg.size):\n        tmp[i]=arg[i]\n    return tmp\n```\nsee [Changelog: july-2023](https://docs.modular.com/mojo/changelog.html#july-2023) for more on ```@unroll```\n\nCompiler time constant value (alias or parameters for example) is required to unroll a loop.\n\n---\n### Capture dynamic value in function and pass it as a parameter\nIt is unsafe for now (v0.5), until model the lifetime of captured value by reference.\n\nsee [Documentation: parameter decorator](https://docs.modular.com/mojo/programming-manual.html#parameter-decorator)\n\nHere is an introduction in order to get familiar with it:\n```python\nfn take_parameter[f: fn() capturing -> Int]():\n    let val = f()\n    print(val)\n\nfn main():\n\n    #will be captured as a reference\n    var val = 0\n    \n    @parameter\n    fn closure()->Int:\n        return val #captured here\n    \n    for i in range(5):\n        val = i\n        take_parameter[closure]()\n\n    _ = val #extend lifetime manually\n    #if not extended, would be cleaned at last use.\n```\n---\n### Compile time if statement\nIt is an if statement that runs at compile time.\n\nThe benefit is that only the live branch is included into the final program.\n\nsee [Documentation: parameter if](https://docs.modular.com/mojo/programming-manual.html#parameterization-compile-time-metaprogramming)\n\n\n\n```python\nalias use_simd:Bool = SIMD[DType.uint8].size > 1\n\nfn main():\n    @parameter\n    if use_simd == True:\n        print(\"This build uses simd\")\n    else:\n        print(\"This build do not uses simd\")\n```\nA traditional if statement that run at runtime is executed each time.\n\nThat one is executed only one time during the compilation.\n\nWhat is inside the block of the if statement is included in the program if condition is met.\n\nIt introduce a form of conditional compilation.\n\nNote that any \"compile-time ready\" function can be used in the if statement.\n\n---\n### alias\nFor compile time constants, \n\nthey can be passed as parameters because they are compile-time known.\n\n```python\nfn main():\n    alias size = 4\n    alias DT = DType.uint8\n    var value = SIMD[DT,size](0)\n    print(value.size==size)\n\n    #create an alias to the print_no_newline function\n    alias say = print_no_newline\n\n    say(\"hello world\")\n```\nThey can also be used \"like define in C\"\n```python\nalias TYPE_OF_INT = Int64\n\nfn get_vector()->DynamicVector[TYPE_OF_INT]:\n    return DynamicVector[TYPE_OF_INT]()\n\nfn my_add(a:TYPE_OF_INT,b:TYPE_OF_INT)->TYPE_OF_INT:\n    return a+b\n```\nBecause an alias is \"compile-time\", it can store the result of a compile time computation:\n```python\nfn squared(a:Int) -> Int:\n    return a*a\n\nfn main():\n    alias pre_calculated_during_compilation = squared(3)\n    var calculated_during_runtime = squared(3)\n    print(pre_calculated_during_compilation) #9\n\n    alias squared_again_during_compilation = squared(pre_calculated_during_compilation)\n    print(squared_again_during_compilation) #81\n```\nAt compile time, it is possible to allocate heap memory and materialize it for runtime use.\n\nSee [Changelog: august-2023](https://docs.modular.com/mojo/changelog.html#august-2023)\n\n```python\nfn get_squared[stop_at:Int=10]() -> DynamicVector[Int]:\n    var tmp = DynamicVector[Int]()\n    for i in range(stop_at):\n        tmp.push_back(i*i)\n    return tmp\n\nfn main():\n    alias the_compile_time_vector = get_vector[stop_at=100]()\n    var materialized_for_runtime_use = the_compile_time_vector\n```\n\n\n---\n#### Parameter default value and keyword\nParameters can have default values and be refered by keyword.\n\nThe ones that have default values need to be defined after the ones that don't (order).\n- ```example[no_default:Int, got_default:Int=1]```\n\n\n```python\nfn get_vector[VT:AnyType = Int64]()->DynamicVector[VT]:\n    return DynamicVector[VT]()\n\nfn main():\n    var vec = get_vector()\n    vec.push_back(1)\n\n    var vec2 = get_vector[VT=Int32]()\n    vec2.push_back(1)\n```\n---\n    \n\n### Overloading: same name, different types.\nOverloading can be done on parameters and functions/methods.\n```python\nfn take_arg[arg:Float64]():\n    print(\"float64\", arg)\n\nfn take_arg[arg:Int64]():\n    print(\"Int64\", arg)\n\nfn main():\n    alias a:Float64 = 1.0\n    alias b:Int64 = 1\n    take_arg[a]()\n    take_arg[b]()\n```\n\nSee:\n- [Documentation: overloading on parameters](https://docs.modular.com/mojo/programming-manual.html#overloading-on-parameters)\n\n- [Documentation: overloading methods and functions](https://docs.modular.com/mojo/programming-manual.html#overloaded-functions-and-methods)\n\n\n---\n&nbsp;\n\n\nThis is a work in progress and will get improved and expanded,\n\n\n[Corrections and contribution](/contribute.md)!\n\n\n"
    },
    {
        "url": "https://github.com/rd4com/mojo-learning/blob/main/tutorials/parametric-struct-trough-cpu-registers.md",
        "content": "# 🏃 (SPEED) Parametric struct through CPU registers.\n\n> with v0.5.0\n\nSome types are store in the ram. each time we access the ram it takes time.\n\nThe reason for accessing the ram is to retrieve a value, or change it, even makes a copy of it (example: pointers).\n\nRam is slow compared to cpu registers.  (just like storage hard-drive is slower than ram).\n\nThe speed to access a CPU register vs RAM is significantly higher,\n\nlet's make a struct that is passed trough cpu-register for  higher speed!\n\nAn example of such type is an Integer, but mojo pave the way for designing way more sophisticated types!\n\n\n\nLet's implement a naive parametric Tuple type that can be passed trough registers.\n\nNote: mojo comes with builtin register passables Tuple types already.\n\n# Naive tuple passed trough registers\n\n\n\n```python\n@register_passable(\"trivial\")\nstruct naive_register_tuple[T_FIRST:AnyType,T_SECOND:AnyType]:\n    var first:T_FIRST\n    var second:T_SECOND\n    \n    #need to return Self type, wich is naive_register_tuple\n    fn __init__(arg_one:T_FIRST,arg_two:T_SECOND) -> Self:\n\n        var tmp = Self{\n            first:arg_one,\n            second:arg_two\n        }\n        return tmp\n    \n    fn mutate_first(inout self,val:T_FIRST):\n        self.first = val\n    \n    fn mutate_second(inout self,val:T_SECOND):\n        self.second = val\n\n    \n\nfn main():\n\n    #explicitely specify the types:\n    var tmp = naive_register_tuple[Bool,Bool](True,True)\n    \n    #with struct parameter deduction:\n    var val = naive_register_tuple(True,1)\n    \n    #mutate first value:\n    val.mutate_first(False)\n    \n    #get the type from the parameters:\n    var my_vec = DynamicVector[val.T_FIRST]()\n    my_vec.push_back(val.first)\n    \n    #get a copy:\n    var val2 = val\n\n    #get fields individually\n    let val_first = val2.first\n    let val_second:val2.T_SECOND = val2.second\n\n    #move the value to another variable\n    let new_val = val^\n    print(new_val.first)\n\n    #Create a DynamicVector for it:\n    var v = DynamicVector[naive_register_tuple[Int,Bool]]()\n    v.push_back(naive_register_tuple[Int,Bool](1,True))\n    v.push_back(naive_register_tuple(2,False))\n```\n\nMany methods could be implemented on top of a register_passable struct.\n\nThis is great for meta-programming and productive/creative implementations.\n\nExamples:\n- ```__getitem__``` to create a ```value[index]``` type of access\n- ```__add__``` to perform ```new_value = value_a+value_b```\n- many more\n\n### register_passable\n\n> Thoses values will be passed trough CPU registers\n\nThe ```__init__()``` function looks different than usual, it returns ```Self```.\n\nusually, self is passed as inout: ```__init__(inout self)```\n\nregister_passable is slightly different in that aspect.\n\n\n### trivial\nIt means that we can get a copy of a value and that we can move it.\n\nThere is no need to implement thoses methods. (```copyinit```, ```moveinit```, ```takeinit```, ```del```)\n\nThink about it, theses are just \"sequences of bytes\" that can be copied as they are from one register to another.\n\nA way to think about thoses is in term of \"bags of bits\" (see mojo documentation).\n\n\n\n> Note: that decorator is subject to reconsiderations\n\nsee [Documentation: trivial types](https://docs.modular.com/mojo/programming-manual.html#trivial-types)\n\n# A new tool in the 🧰 !\nOne clear benefit is the speed.\n\nAlso, in ```Version <= 0.5```, the register_passable types can be used with types such as DynamicVector.\n\n(version is ```0.5``` when this tutorial was written)\n\nAnother significant benefit is that it creates the opportunity to design/implement new/different types.\n\nTheses will becomes more popular as mojo evolve and people start to create hardware specific types.\n\n\nIt also **reconcile performance and user-friendlyness** in a significant manner .\n\n\n\n\n\n---\n\n&nbsp;\n\n\nSee [Contributions](/contribute.md) for ideas, drafts, tutorials, corrections.\n\n\n"
    },
    {
        "url": "https://github.com/rd4com/mojo-learning/blob/main/tutorials/python-world-mojo-world.md",
        "content": "# 🔁 Python land and mojo land, PythonObject\n\n[PythonObject](https://docs.modular.com/mojo/stdlib/python/object.html) is a mojo type that can store python objects of any python class (int, list,ndarray..)\n- can \"travel\" trough **mojo functions**, as a PythonObject, but can also be passed to **python functions**, as a PythonObject.\n- can go back and forth between thoses two worlds.\n- is understood both by python and mojo\n\n### mojo->python\n```python\nvar the_number:Int = 1\nvar the_py_object = PythonObject(the_number)\n```\nthe_number is a mojo [Int](https://docs.modular.com/mojo/stdlib/builtin/int.html), it is automatically converted to Python object by the method ```__init__(inout self: Self, integer: Int)``` of PythonObject.\n### python->mojo\n```python\nthe_number = the_py_object.__index__()\n```\n```__index__()``` is a method of [PythonObject](https://docs.modular.com/mojo/stdlib/python/object.html)\n\n```to_float64()``` is another one.\n\n### calling python functions\n```python\nvar the_python_list = PythonObject([])\n```\nThe PythonObject is initialized from an empty mojo [ListLiteral](    https://docs.modular.com/mojo/stdlib/builtin/builtin_list.html) by ```__init__[*Ts: AnyType](inout self: Self, value: ListLiteral[Ts])```\n\nthe_python_list is now a PythonObject of class list.\n\n```python\nthe_python_list.append(123)\n```\n**append is not a method of PythonObject**\n\n- append is a python method of the list class.\n- the_python_list is a PythonObject of the list class\n- append is in python land and mojo can find it inside the python object and call it!\n\n### the ability to import and use any created python file or \"pip\" package:\n```python\nfrom python import Python\nvar my_python_file = Python.import_module(\"my_python_file_name\") #no .py needed\nmy_python_file.my_function([1,2,3]) #mojo will find my_function\n```\n[import_module](https://docs.modular.com/mojo/stdlib/python/python.html#import_module) return a PythonObject\n# Example with many comments:\n```python\nfrom python import Python\nfrom python import PythonObject\n\nfn plot_from_mojo(values: PythonObject) raises:\n    #require matplotlib package to be installed\n    let plt = Python.import_module(\"matplotlib.pyplot\")     \n    plt.plot(values) #theses values comes from numpy\n                     #that python object class is ndarray: \n                     #print(values.__class__.__name__)\n    plt.show()\n\nfn numpy_array_from_mojo() raises -> PythonObject:\n    let np = Python.import_module(\"numpy\")      #np is a PythonObject  \n                                                #let np:PythonObject...\n                                                #import_module returns a PythonObject\n    var x = PythonObject([]) #x: PythonObject, class: list \n                             #initialized from an empty list literal https://docs.modular.com/mojo/stdlib/builtin/builtin_list.html\n                             #note that [] is a mojo type! (ListLiteral)\n    \n    var range_size:Int = 256     #Mojo Int!         https://docs.modular.com/mojo/stdlib/builtin/int.html\n    #mojo have ranges too, that one is a mojo one   https://docs.modular.com/mojo/stdlib/builtin/range.html\n    for i in range(range_size):  #i is a mojo Int \n        #append is a python function, mojo find it inside the PythonObject\n        x.append(i) #i get converted to a python object trough the __init__ function of PythonObject\n\n    return np.cos(np.array(x)*np.pi*2.0/256.0)\n    #np.cos return a python object of class ndarray\n\n\ndef main():     \n    #numpy_array_from_mojo is a mojo function that return a PythonObject.       \n    var results = numpy_array_from_mojo() \n    #plot_from_mojo is a mojo function that takes a PythonObject.      \n    plot_from_mojo(results) \n\n```\n"
    },
    {
        "url": "https://github.com/rd4com/mojo-learning/blob/main/tutorials/reader-in-few-lines-with-endian-ness.md",
        "content": "# 🕯️ [reader.read\\[Int32,\"swap\"\\](3) in 45 lines]() \n> with mojo v0.4.0 \n\nTheses mojo features are used:\n- [alias](https://docs.modular.com/mojo/programming-manual.html#alias-named-parameter-expressions)\n- [bitcasted](https://docs.modular.com/mojo/stdlib/memory/unsafe.html#bitcast) pointer to generic T\n- [generic struct](https://docs.modular.com/mojo/programming-manual.html#defining-parameterized-types-and-functions) ([T] is a parameter)\n- [@parameter if](https://docs.modular.com/mojo/programming-manual.html#powerful-compile-time-programming)\n- [parameter with a default value](https://docs.modular.com/mojo/programming-manual.html#using-default-parameter-values)\n- [extend lifetime](https://docs.modular.com/mojo/programming-manual.html#field-lifetimes-of-owned-arguments-in-__moveinit__-and-__del__) with _ = pointer\n- [Raising errors: dynamic messages](https://docs.modular.com/mojo/changelog.html#v0.4.0-2023-10-05)\n- [sizeof\\[T\\]()](https://docs.modular.com/mojo/stdlib/sys/info.html#sizeof) \n- [raising errors](https://docs.modular.com/mojo/stdlib/builtin/error.html)\n\nIt is nice to see how they work together.\n\n*note: how productive and user friendly 🔥 is* \n> ⚠️ the code has not been tested, not ready for use\n\n```python\ndef main():\n    var reader = file_reader(\"data_from_ruby\")\n    \n    #return a Pointer to four Uint32\n    let LE_ui32 = reader.read[UInt32](4)\n\n    for i in range(4):\n        print(LE_ui32.load(i))\n\n    #two Float32, converted from another endian-ness\n    \n    let BE_f32 = reader.read[Float32,\"swap\"](2)\n    \n    print(BE_f32.load(0))\n    print(BE_f32.load(1))\n    \n    #free the pointers\n    LE_ui32.free()\n    BE_f32.free()\n\n    #move the reader cursor back four bytes\n    reader.offset -=4\n\n    #Float32 (not pointer), converted from another endian-ness\n    print(reader.read_one[Float32,\"swap\"]())\n```\n\n\n\n```python\nfrom sys.info import sizeof\n\nstruct file_reader:\n    var data:DTypePointer[DType.uint8]\n    var size: Int\n    var offset:Int\n\n    fn __init__(inout self,filename:String) raises:\n        #open the file\n        var handler = open(filename,\"r\")\n\n        #pointer with no allocation done:\n        self.data = DTypePointer[DType.uint8]()\n        self.size = 0\n        self.offset = 0\n        \n        #read the file into tmp\n        let tmp = handler.read()\n        self.size = tmp._buffer.size\n        self.data = self.data.alloc(self.size)\n        \n        #interpret the bytes as uint8 when .load(index)\n        let tmp_ptr = tmp._as_ptr().bitcast[DType.uint8]()\n        \n        #copy the content of tmp into self.data\n        for i in range(self.size):\n            self.data.store(i,tmp_ptr.load(i))\n        \n        _=tmp #extending the lifetime to more than tmp_ptr\n        #if dont do, tmp will be freed when last used\n        #and tmp_ptr will point to freed memory\n        \n        #close the file\n        handler.close()\n    \n    fn read_one[T:AnyType,endian:StringLiteral= \"not_swap\"](inout self) raises->T:\n        let tmp = self.read[T,endian](1)\n        let tmp2:T = tmp.load(0)\n        tmp.free()\n        return tmp2\n    \n    #\"be\" is default if no value is passed\n    fn read[T:AnyType,endian:StringLiteral= \"not_swap\"](inout self,e: Int = 1) raises->Pointer[T]:\n        \n        #size of T in bytes multiplied by elements\n        let fsize = e*sizeof[T]()\n        \n        if (self.offset+fsize)>self.size:\n            raise Error(\"file is not that big\")\n        \n        let tmp = Pointer[UInt8]().alloc(fsize)\n        \n        for i in range(fsize):\n            tmp.store(i,self.data.load(i+self.offset))\n        \n        self.offset+=fsize\n        \n        #swapping the bytes if specified:\n        @parameter\n        #\"not_swap\" is the default parameter value!\n        if endian == \"swap\":\n            alias sizeoft=sizeof[T]()\n\n            let tmp_for_swap = Pointer[UInt8]().alloc(sizeoft)\n            \n            for i in range(0,fsize,sizeoft):\n                for i2 in range(0,sizeoft):\n                    tmp_for_swap.store(i2,tmp.load(i+i2))\n                for i2 in range(0,sizeoft):\n                    tmp.store(i+i2,tmp_for_swap.load(sizeoft-1-i2))\n            \n            tmp_for_swap.free()\n        #Pointer[UInt8] to Pointer[T]\n        #does not modify the data, just provide \"a viewer\"\n        return tmp.bitcast[T]()\n\n    #when instance of file_reader is deleted\n    fn __del__(owned self):\n        #free memory\n        self.data.free()\n```\n```ruby\n# ruby code to generate data\nFile.write(\"name.extension\",[1,2,3,4,1.1,2.5].pack(\"l<4g2\"))\n```"
    },
    {
        "url": "https://github.com/rd4com/mojo-learning/blob/main/tutorials/struct-as-namespace.md",
        "content": "\n# 🫙 struct as a namespace (@staticmethod)\n\n\nUsing python functions from mojo with a wrapper:\n\n```python   \nfn main():\n    print(strings.contains(\"hello world\",\"hello\"))\n    print(strings.endswith(\"hello world\",\"world\"))\n    print(strings.count(\"hello world\",\"l\"))\n    print(strings.find(\"hello world\",\"l\"))\n    print(strings.replace(\"hello world world\",\"world\",\"planet\"))\n```\n\n>  *the global scope is clean, not cluttered*\n\nA function marked by the decorator ```@staticmethod``` is called on the struct.\n\n> *the struct act as a namespace !*\n\nNo need to instantiate an object.\n\n\n\n```python\nstruct strings:\n    \n    @staticmethod   #without try: except\n    def center(a:String,b:Int) -> String:\n        return PythonObject(a).center(PythonObject(b)).to_string()\n    \n    @staticmethod\n    fn replace(a:String,b:String,c:String)->String:\n        try:\n            return PythonObject(a).replace(PythonObject(b),PythonObject(c)).to_string()\n        except e:\n            print(e)\n            return \"\"\n\n    @staticmethod\n    fn contains(a:String,b:String)->Bool:\n        try:\n            if PythonObject(a).find(PythonObject(b)) == -1:\n                return False\n            else:\n                return True\n        except e:\n            print(e)\n            return False\n    \n    @staticmethod\n    fn endswith(a:String,b:String)->Bool:\n        try:\n            return PythonObject(a).endswith(PythonObject(b)).__bool__()\n        except e:\n            print(e)\n            return False\n    \n    @staticmethod\n    fn count(a:String,b:String)->Int:\n        try:\n            return PythonObject(a).count(PythonObject(b)).to_float64().__int__()\n        except e:\n            print(e)\n            return -1\n    \n    @staticmethod\n    fn find(a:String,b:String)->Int:\n        try:\n            return PythonObject(a).find(PythonObject(b)).to_float64().__int__()\n        except e:\n            print(e)\n            return -1\n```\n\n```try: except:``` could be left unused, but it is a good habit for later!\n\n# 🗃️ organised\n\n- packages\n- modules\n- struct\n  - @staticmethod\n"
    },
    {
        "url": "https://github.com/rd4com/mojo-learning/blob/main/tutorials/try-and-except-errors-handling.md",
        "content": "# [Try & Except: ✋->⚠️->⛑️->🩹->👍 ]()\n> with v0.4.0\n\nThere are explainations further down the page,\n\nThis example accompany thoses:\n\n```python\nfrom random import random_float64,seed\nalias flip_a_coin = random_float64\nalias tail = 0.5\n\ndef say_three():\n    raise Error(\"⚠️ no time to say three\")\n\nfn count_to_5() raises:\n    print(\"count_to_5: one\")\n    print(\"count_to_5: two\")\n    try:\n        say_three()\n    except e:\n        print(\"\\t count_to_5: error\",e)\n        \n        if flip_a_coin()>tail:\n            raise Error(\"⚠️ we stopped at three\")\n        else:\n            print(\"count_to_5: three ⛑️\")\n    \n    print(\"count_to_5: four\")\n    print(\"count_to_5: five\")\n\n\nfn main() raises:\n    seed()\n    \n    try:\n        count_to_5()\n    except e:\n        print(\"error inside main(): \",e)\n        #main: errror e\n        if e.__repr__() == \"⚠️ we stopped at three\":\n            print(\"main: three ⛑️\")\n            print(\"main: four ⛑️\")\n            print(\"main: five ⛑️\")\n\n    print(\"✅ main function: all good\")\n```\nIn order to illustrate Except and Try, \n\nThe code will randomely produce one of those two scenarios:\n#### Fix the error from count_to_5:\n\n    count_to_5: one\n    count_to_5: two\n            count_to_5: error ⚠️ no time to say three\n    count_to_5: three ⛑️\n    count_to_5: four\n    count_to_5: five\n    ✅ main function: all good\n\n#### Fix the error from main:\n\n    count_to_5: one\n    count_to_5: two\n            count_to_5: error ⚠️ no time to say three\n    error inside main():  ⚠️ we stopped at three\n    main: three ⛑️\n    main: four ⛑️\n    main: five ⛑️\n    ✅ main function: all good\n\n# More\n\n#### Raising\n- ```def()``` functions can call raising functions and can raise by default\n-  ```fn() raises``` is necessary in order to raise\n- ```fn()``` cannot call functions that might raise, for example: a def function that raises by default\n\n#### Try:\nInside the try block, we can call functions that could raise and error. It is also possible to Raise an error.\n\nIf and error is thrown, the execution continue at the beginning of the Except: block just below\n\n#### Except e:\nHere it is possible to inspect the error e, based on that, we can fix it.\n\nIf fixed, the the execution continue on the first line after the except block.\n\nIf it is not possible to fix it, it is possible to Raise an error: either the same or another.\n\nThe error will be transfered to the next Except: block. (see example)\n"
    },
    {
        "url": "https://github.com/rd4com/mojo-learning/blob/main/tutorials/using-python-in-mojo.md",
        "content": "# 🐍 using python in mojo: a to z\n\n> with v0.4.0\n\n👷 under active development, see [contributions](/contribute.md)\n### Import python in mojo\n```python\nfrom python import Python\n```\n### create mutable variable res\n```python\ndef main():\n    var res:PythonObject \n```\n### list comprehension\n```python\n    res = Python.evaluate(\"[x*x for x in range(1,4)]\")\n\n    for i in res: # i is a PythonObject\n        let element:Float64 = i.to_float64()\n        print(element) #1.0 4.0 9.0\n```\n### call methods\n```python\n    res = \" and \" #res is a PythonObject \n\n    #call join method\n    res = res.join([\"mojo\",\"python\"])\n\n    print(res) #print: mojo and python\n```\n### list\n```python\n    res =[]\n    res.append(Float64(1))\n    res.append(\"hello world\")\n    res.append(True)\n    res.pop()\n    res.append(False)\n    print(res) #[1.0, 'hello world', False]\n```\n### tuples\n```python\n    res = (True,0)\n    print(res[0])\n    print(res[1])\n```\n### get and call python functions\n```python\n    res = Python.evaluate(\"bin\")\n    print(res(15)) #0b1111\n```\n### types\n```python\n    res = 1.0\n    print(res.__class__.__name__) #float\n```\n\n### instance\n```python\n    res = True\n    let is_instance = Python.evaluate(\"isinstance\")\n    let float_type = Python.evaluate(\"bool\")\n    print(is_instance(res,float_type))\n```\n\n### convert to mojo types\n```python\n    res = \"hello world\"\n    let res_b:String = res.upper().to_string()\n    print(res_b) #HELLO WORLD\n\n    res = 1.0\n    let res_c:Float64 = res.to_float64()\n\n    res = 123\n    let res_d:Int = res.__index__()\n\n    res = True\n    let res_e:Bool = res.__bool__()\n\n```\n\n# with pip modules\n### numpy linspace\n```python\n    res = Python.import_module(\"numpy\").linspace(0, 1.0, 5)\n    print(res) #[0.   0.25 0.5  0.75 1.  ]\n```\n### matplotlib plotting\n```python\n    res = Python.import_module(\"matplotlib.pyplot\")\n    res.plot([1.1,2.2,4.4])\n    res.show()\n```\n# importing a custom python file\n#### main.mojo:\n```python\nfrom python import Python\n\ndef main():\n    #path to the file (current directory)\n    Python.add_to_path(\"./\")\n\n    #name of the file without .py\n    let my_module = Python.import_module(\"python_file\")\n\n    my_module.my_func(2, 3)\n```\n#### python_file.py:\n```python\ndef my_func(a,b):\n    print(a+b)\n```\n\n\n"
    },
    {
        "url": "https://github.com/rd4com/mojo-learning/blob/main/tutorials/vectorise-simd-cosine.md",
        "content": "```python\nimport math\nfrom sys.info import simdwidthof\nfrom algorithm import vectorize\nfrom python import Python\n\nfn main():\n\n    alias size = 256\n    alias value_type = DType.float64\n    \n    #allocate array of size elements of type value_type\n    var array = DTypePointer[value_type]().alloc(size)\n    \n    @parameter\n    fn cosine[group_size:Int](X: Int):\n        #create a simd array of size group_size. values: X->(X+group_size-1)\n        var tmp = math.iota[value_type, group_size](X)\n        tmp = tmp * 3.14 * 2 / 256.0\n        tmp = math.cos[value_type,group_size](tmp)\n        array.simd_store[group_size](X,tmp)\n    \n    #how much values at a time\n    alias by_group_of = simdwidthof[value_type]() \n    vectorize[by_group_of,cosine](size)\n    \n    for i in range(size):\n        print(array.load(i))\n    \n    try:\n        var plt = Python.import_module(\"matplotlib.pyplot\")\n        var python_y_array = PythonObject([])\n        for i in range(size):\n            python_y_array.append(array.load(i))\n        var python_x_array = Python.evaluate(\"[x for x in range(256)]\")\n        plt.plot(python_x_array,python_y_array)\n        plt.show()\n    except:\n        print(\"no plot\")\n    \n    #release memory\n    array.free()\n```"
    },
    {
        "url": "https://github.com/rd4com/mojo-learning/blob/main/tutorials/what-have-change-when-there-is-a-new-update.md",
        "content": "# 📫 find out changes and improvements when there is a new update\n\nWhen there is a new update, a new changelog is available.\n\nThe changelogs are availables for us [here](https://docs.modular.com/mojo/changelog.html)\n\n## What is a changelog\nIt is an entry that describe the changes made, new features and bug fixed of an update.\n\n## How are they usefull\n\nProvides a clear listing of new features that are now availables.\n\nThey also helps to maintain existing code by adapting to changes.\n\n## Practical example\n\nLets understand how usefull it is by partially analysing a real changelog.\n\n### [v0.5.0 (2023-11-2)](https://docs.modular.com/mojo/changelog.html#v0.5.0-2023-11-2)\nFrom a glance, we can see that SIMD got a new function:\n-  ```join()``` : allows concatenating two SIMD values\n\nMore features:\n-  Tensor has new ```fromfile()``` and ```tofile()``` methods to save and load as bytes from a file.\n-  Mojo now supports compile-time keyword parameters\n   -  ```fn foo[a: Int, b: Int = 42]()```\n-  Keyword parameters are also supported in structs\n- The parameters for InlinedFixedVector have been switched. \n  - It now looks more like SIMD, let's make changes to existing codes to reflect the improvement, another benetits of changelogs.\n-  The [benchmark](https://docs.modular.com/mojo/stdlib/benchmark/benchmark.html) module has been simplified and improved \n- ...more exciting features\n\nA section is dedicated to list features that have been removed if any.\n\n### ✅ Fixed section\nThat sections show all the bug reports made on the [github repository of mojo](https://github.com/modularml/mojo/issues) that have been fixed in that update.\n\nUsers can also create new bug reports if needed on that link.\n\nThe repository is also a place to create a feature request.\n\n\n---\n\n> People also usually discuss the changes on the [Discord channel](https://www.discord.gg/modular)\n\n> There are also live Q/A, demonstrations and blog posts by mojo/modular team\n\n"
    },
    {
        "url": "https://github.com/rd4com/mojo-learning/blob/main/tutorials/with-blocks-for-struct-parametric-minimal-raise.md",
        "content": "\n\n# 🔥 With blocks: with my_struct(1) as v (parametric/minimal/raise)\n\n\n> with v0.5.0\n\nThe with blocks are similar to the ones in python in many aspects.\n\nIn mojo, it is possible to parametrize the struct.\n\nThis is just one distinction, there are probably more and more to come!\n\n\n\n### A. Minimal example\nThat example cover a new supported feature introduced in [Changelog: 2023-10-05](https://docs.modular.com/mojo/changelog.html#v0.4.0-2023-10-05)\n\n- support an ```__enter__``` method without implementing support for an ```__exit__``` method\n```python\n@value\nstruct my_struct[T:AnyType]:\n    var value: T\n    \n    fn __init(inout self,arg:T):\n        self.value = arg\n    \n    fn __enter__(owned self) -> T:\n        return self.value\n        #__del__() called on self here\n\nfn main():\n\n    #struct parameter deduction:\n    with my_struct(1.5) as value:\n        print(value)\n\n    #explicitely specify type:\n    with my_struct[Bool](True) as value:\n        print(value)\n```\n\nNote the absence of an ```__exit__()``` method in that  example. \n\nself is \"consumed\" in the ```__enter__(owned self)->T```\n\n```__del()__``` is called on self after the last use of it.\n\n\n see [Mojo documentation:ASAP](https://docs.modular.com/mojo/programming-manual.html#behavior-of-destructors) for more on why it is called after it's last use.\n\nThere is also a small tutorial on ASAP inside this repository.\n\n&nbsp;\n\n### B. Error handling and Exit\nThat example cover some features introduced in\n[Changelog: week-of-2023-04-24](https://docs.modular.com/mojo/changelog.html#week-of-2023-04-24).\n\n##### enter the with block, and provide value of type T\n```fn __enter__(self) -> T:```\n\n##### exit the with block without error\n```fn __exit__(self):```\n\n##### error got raised inside the with block:\n```fn __exit__(self, err: Error) -> Bool:```\n\n\n```python\n@value\nstruct my_struct[T:AnyType]:\n    var value: T\n    \n    fn __init(inout self,arg:T):\n        self.value = arg\n    \n    #Return a value to be used by the with block\n    fn __enter__(self) -> T:\n        return self.value\n    \n    fn __exit__(self):\n        print(\"🏖️ exit with success\")\n\n    #For error handling\n    fn __exit__(self, err: Error) -> Bool:\n        print(\"❌ Error 'received' by __exit__ : \",err)\n\n        if err._message() == \"Error in with block\":\n            #Let's consider it handled by returning True.\n            print(\"✅ Handled in exit\")\n            return True\n            \n        #If return False, it means the error was not handled here\n        #the error will be re-propagated/re-thrown \n        return False\n\nfn main() raises:\n    \n    try:\n        with my_struct(1.5) as value:\n            print(value)\n            #raise Error(\"Error in with block\") \n            raise Error(\"Another error\") \n    \n    except err:\n        #The error got re-thrown here\n        print(\"❌ Error 'received' by main : \",err)\n\n        #Lets consider it handled.\n        print(\"✅ Handled in main\")\n\n        #Program will continue, below in the main function\n\n    print(\"Main: all good\")\n```\n\nDepending on wich error is thrown (see the commented one),\n\nthe program produce one of theses two outputs:\n#### A:\n```\n1.5\n❌ Error 'received' by __exit__ :  Error in with block\n✅ Handled in exit\nMain: all good\n```\n#### B:\n```\n1.5\n❌ Error 'received' by __exit__ :  Another error\n❌ Error 'received' by main :  Another error\n✅ Handled in main\nMain: all good\n```\n"
    }
]