[
  {
    "title": "Modular Docs - vector",
    "url": "https://docs.modular.com/mojo/stdlib/utils/vector.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nindex\nlist\nstatic_tuple\nvector\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nInlinedFixedVector\n__init__\n__copyinit__\n__getitem__\n__setitem__\ndeepcopy\nappend\n__len__\nclear\n__iter__\nUnsafeFixedVector\nDynamicVector\nCollectionElement\nvector\n\nModule\n\nDefines several vector-like classes.\n\nYou can import these APIs from the utils package. For example:\n\nfrom utils.vector import InlinedFixedVector\nInlinedFixedVector\n\nA dynamically-allocated vector with small-vector optimization and a fixed maximum capacity.\n\nThe InlinedFixedVector does not resize or implement bounds checks. It is initialized with both a small-vector size (specified at compile time) and a maximum capacity (specified at runtime).\n\nThe first size elements are stored in the statically-allocated small vector storage. Any remaining elements are stored in dynamically-allocated storage.\n\nWhen it is deallocated, it frees its memory.\n\nTODO: It should call its element destructors once we have traits.\n\nThis data structure is useful for applications where the number of required elements is not known at compile time, but once known at runtime, is guaranteed to be equal to or less than a certain capacity.\n\nParameters:\n\n​type (AnyRegType): The type of the elements.\n​size (Int): The statically-known small-vector size.\n\nAliases:\n\n​static_size = _69x23_size\n​static_data_type = StaticTuple[size, *\"type\"]\n\nFields:\n\n​static_data (StaticTuple[size, *\"type\"]): The underlying static storage, used for small vectors.\n​dynamic_data (Pointer[*\"type\", 0]): The underlying dynamic storage, used to grow large vectors.\n​current_size (Int): The number of elements in the vector.\n​capacity (Int): The maximum number of elements that can fit in the vector.\n\nFunctions:\n\n__init__\n\n__init__(inout self: Self, capacity: Int)\n\nConstructs InlinedFixedVector with the given capacity.\n\nThe dynamically allocated portion is capacity - size.\n\nArgs:\n\n​capacity (Int): The requested maximum capacity of the vector.\n__copyinit__\n\n__copyinit__(inout self: Self, existing: Self)\n\nCreates a shallow copy (doesn’t copy the underlying elements).\n\nArgs:\n\n​existing (Self): The InlinedFixedVector to copy.\n__getitem__\n\n__getitem__(self: Self, i: Int) -> *\"type\"\n\nGets a vector element at the given index.\n\nArgs:\n\n​i (Int): The index of the element.\n\nReturns:\n\nThe element at the given index.\n\n__setitem__\n\n__setitem__(inout self: Self, i: Int, *value: \"type\")\n\nSets a vector element at the given index.\n\nArgs:\n\n​i (Int): The index of the element.\n​value (*\"type\"): The value to assign.\ndeepcopy\n\ndeepcopy(self: Self) -> Self\n\nCreates a deep copy of this vector.\n\nReturns:\n\nThe created copy of this vector.\n\nappend\n\nappend(inout self: Self, *value: \"type\")\n\nAppends a value to this vector.\n\nArgs:\n\n​value (*\"type\"): The value to append.\n__len__\n\n__len__(self: Self) -> Int\n\nGets the number of elements in the vector.\n\nReturns:\n\nThe number of elements in the vector.\n\nclear\n\nclear(inout self: Self)\n\nClears the elements in the vector.\n\n__iter__\n\n__iter__(inout self: Self) -> _VecIter[*\"type\", InlinedFixedVector[*\"type\", size], _deref_iter_impl[*\"type\", size]]\n\nIterate over the vector.\n\nReturns:\n\nAn iterator to the start of the vector.\n\nImplemented Traits:\n\n​Destructable\n​Sized\nUnsafeFixedVector\n\nThe UnsafeFixedVector type is a dynamically-allocated vector that does not resize or implement bounds checks.\n\nIt is initialized with a dynamic (not known at compile time) number of slots, and when it is deallocated, it frees its memory.\n\nTODO: It should call its element destructors once we have traits.\n\nThis data structure is useful for applications where the number of required elements is not known at compile time, but once known at runtime, is guaranteed to be equal to or less than a certain capacity.\n\nParameters:\n\n​type (AnyRegType): The type of the elements.\n\nFields:\n\n​data (Pointer[*\"type\", 0]): The underlying storage for the vector.\n​size (Int): The number of elements in the vector.\n​capacity (Int): The amount of elements that can fit in the vector.\n\nFunctions:\n\n__init__\n\n__init__(inout self: Self, capacity: Int)\n\nConstructs UnsafeFixedVector with the given capacity.\n\nArgs:\n\n​capacity (Int): The requested capacity of the vector.\n__copyinit__\n\n__copyinit__(inout self: Self, existing: Self)\n\nCreates a shallow copy (it doesn’t copy the data).\n\nArgs:\n\n​existing (Self): The UnsafeFixedVector to copy.\n__getitem__\n\n__getitem__(self: Self, i: Int) -> *\"type\"\n\nGets a vector element at the given index.\n\nArgs:\n\n​i (Int): The index of the element.\n\nReturns:\n\nThe element at the given index.\n\n__setitem__\n\n__setitem__(self: Self, i: Int, *value: \"type\")\n\nSets a vector element at the given index.\n\nArgs:\n\n​i (Int): The index of the element.\n​value (*\"type\"): The value to assign.\n__len__\n\n__len__(self: Self) -> Int\n\nGets the number of elements in the vector.\n\nReturns:\n\nThe number of elements in the vector.\n\nappend\n\nappend(inout self: Self, *value: \"type\")\n\nAppends a value to this vector.\n\nArgs:\n\n​value (*\"type\"): The value to append.\nclear\n\nclear(inout self: Self)\n\nClears the elements in the vector.\n\nImplemented Traits:\n\n​Destructable\n​Sized\nDynamicVector\n\nThe DynamicVector type is a dynamically-allocated vector.\n\nIt supports pushing and popping from the back resizing the underlying storage as needed. When it is deallocated, it frees its memory.\n\nFIXME: Rename this to DynamicVector.\n\nParameters:\n\n​T (CollectionElement): The type of the elements.\n\nFields:\n\n​data (AnyPointer[T]): The underlying storage for the vector.\n​size (Int): The number of elements in the vector.\n​capacity (Int): The amount of elements that can fit in the vector without resizing it.\n\nFunctions:\n\n__init__\n\n__init__(inout self: Self)\n\nConstructs an empty vector.\n\n__init__(inout self: Self, capacity: Int)\n\nConstructs a vector with the given capacity.\n\nArgs:\n\n​capacity (Int): The requested capacity of the vector.\n__copyinit__\n\n__copyinit__(inout self: Self, existing: Self)\n\nCreates a deepcopy of the given vector.\n\nArgs:\n\n​existing (Self): The vector to copy.\n__moveinit__\n\n__moveinit__(inout self: Self, owned existing: Self)\n\nMove data of an existing vector into a new one.\n\nArgs:\n\n​existing (Self): The existing vector.\n__del__\n\n__del__(owned self: Self)\n\nDestroy all elements in the vector and free its memory.\n\n__getitem__\n\n__getitem__(self: Self, i: Int) -> T\n\nGets a copy of the vector element at the given index.\n\nFIXME(lifetimes): This should return a reference, not a copy!\n\nArgs:\n\n​i (Int): The index of the element.\n\nReturns:\n\nA copy of the element at the given index.\n\n__setitem__\n\n__setitem__(inout self: Self, i: Int, owned value: T)\n\nSets a vector element at the given index.\n\nArgs:\n\n​i (Int): The index of the element.\n​value (T): The value to assign.\n__len__\n\n__len__(self: Self) -> Int\n\nGets the number of elements in the vector.\n\nReturns:\n\nThe number of elements in the vector.\n\nappend\n\nappend(inout self: Self, owned value: T)\n\nAppends a value to this vector.\n\nArgs:\n\n​value (T): The value to append.\npush_back\n\npush_back(inout self: Self, owned value: T)\n\nAppends a value to this vector.\n\nArgs:\n\n​value (T): The value to append.\npop_back\n\npop_back(inout self: Self) -> T\n\nPops a value from the back of this vector.\n\nReturns:\n\nThe popped value.\n\nreserve\n\nreserve(inout self: Self, new_capacity: Int)\n\nReserves the requested capacity.\n\nIf the current capacity is greater or equal, this is a no-op. Otherwise, the storage is reallocated and the date is moved.\n\nArgs:\n\n​new_capacity (Int): The new capacity.\nresize\n\nresize(inout self: Self, new_size: Int, value: T)\n\nResizes the vector to the given new size.\n\nIf the new size is smaller than the current one, elements at the end are discarded. If the new size is larger than the current one, the vector is appended with new values elements up to the requested size.\n\nArgs:\n\n​new_size (Int): The new size.\n​value (T): The value to use to populate new elements.\nclear\n\nclear(inout self: Self)\n\nClears the elements in the vector.\n\nsteal_data\n\nsteal_data(inout self: Self) -> AnyPointer[T]\n\nTake ownership of the underlying pointer from the vector.\n\nReturns:\n\nThe underlying data.\n\nImplemented Traits:\n\n​Destructable\n​Sized\nCollectionElement\n\nA collection element is a value type that can be moved, copied, and default-constructed in a collection.\n\nFunctions:\n\n__copyinit__\n\n__copyinit__(inout self: T, existing: T, /)\n\nCreate a new instance of the value by copying an existing one.\n\nArgs:\n\n​existing (T): The value to copy.\n__moveinit__\n\n__moveinit__(inout self: T, owned existing: T, /)\n\nCreate a new instance of the value by moving the value of another.\n\nArgs:\n\n​existing (T): The value to move.\n__del__\n\n__del__(owned self: T, /)\n\nDestroy the contained value.\n\nThe destructor receives an owned value and is expected to perform any actions needed to end the lifetime of the object. In the simplest case, this is nothing, and the language treats the object as being dead at the end of this function.\n\nImplemented Traits:\n\n​Copyable\n​Destructable\n​Movable\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - static_tuple",
    "url": "https://docs.modular.com/mojo/stdlib/utils/static_tuple.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nindex\nlist\nstatic_tuple\nvector\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nStaticTuple\n__init__\n__getitem__\n__setitem__\n__len__\nstatic_tuple\n\nModule\n\nImplements StaticTuple, a statically-sized uniform container.\n\nYou can import these APIs from the utils package. For example:\n\nfrom utils.static_tuple import StaticTuple\nStaticTuple\n\nA statically sized tuple type which contains elements of homogeneous types.\n\nParameters:\n\n​size (Int): The size of the tuple.\n​_element_type (AnyRegType): The type of the elements in the tuple.\n\nAliases:\n\n​element_type = _95x31__element_type\n​type = array<#lit.struct.extract<:!kgen.declref<@\"$builtin\"::@\"$int\"::@Int, !lit.metatype<@\"$builtin\"::@\"$int\"::@Int>> size, \"value\">, _element_type>\n\nFields:\n\n​array (array<#lit.struct.extract<:!kgen.declref<@\"$builtin\"::@\"$int\"::@Int, !lit.metatype<@\"$builtin\"::@\"$int\"::@Int>> size, \"value\">, _element_type>): The underlying storage for the static tuple.\n\nFunctions:\n\n__init__\n\n__init__() -> Self\n\nConstructs an empty (undefined) tuple.\n\nReturns:\n\nThe tuple.\n\n__init__(*elems: _element_type) -> Self\n\nConstructs a static tuple given a set of arguments.\n\nArgs:\n\n​elems (*_element_type): The element types.\n\nReturns:\n\nThe tuple.\n\n__init__(values: VariadicList[_element_type]) -> Self\n\nCreates a tuple constant using the specified values.\n\nArgs:\n\n​values (VariadicList[_element_type]): The list of values.\n\nReturns:\n\nA tuple with the values filled in.\n\n__getitem__\n\n__getitem__[index: Int](self: Self) -> _element_type\n\nReturns the value of the tuple at the given index.\n\nParameters:\n\n​index (Int): The index into the tuple.\n\nReturns:\n\nThe value at the specified position.\n\n__getitem__(self: Self, index: Int) -> _element_type\n\nReturns the value of the tuple at the given dynamic index.\n\nArgs:\n\n​index (Int): The index into the tuple.\n\nReturns:\n\nThe value at the specified position.\n\n__setitem__\n\n__setitem__[index: Int](inout self: Self, val: _element_type)\n\nStores a single value into the tuple at the specified index.\n\nParameters:\n\n​index (Int): The index into the tuple.\n\nArgs:\n\n​val (_element_type): The value to store.\n\n__setitem__(inout self: Self, index: Int, val: _element_type)\n\nStores a single value into the tuple at the specified dynamic index.\n\nArgs:\n\n​index (Int): The index into the tuple.\n​val (_element_type): The value to store.\n__len__\n\n__len__(self: Self) -> Int\n\nReturns the length of the array. This is a known constant value.\n\nReturns:\n\nThe size of the list.\n\nImplemented Traits:\n\n​Destructable\n​Sized\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - list",
    "url": "https://docs.modular.com/mojo/stdlib/utils/list.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nindex\nlist\nstatic_tuple\nvector\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nDim\n__init__\n__bool__\n__eq__\n__ne__\n__mul__\nhas_value\nis_dynamic\nget\nis_multiple\n__int__\nDimList\nlist\n\nModule\n\nProvides utilities for working with static and variadic lists.\n\nYou can import these APIs from the utils package. For example:\n\nfrom utils.list import Dim\nDim\n\nA static or dynamic dimension modeled with an optional integer.\n\nThis class is meant to represent an optional static dimension. When a value is present, the dimension has that static value. When a value is not present, the dimension is dynamic.\n\nFields:\n\n​value (Optional[Int]): An optional value for the dimension.\n\nFunctions:\n\n__init__\n\n__init__(value: Int) -> Self\n\nCreates a statically-known dimension.\n\nArgs:\n\n​value (Int): The static dimension value.\n\nReturns:\n\nA dimension with a static value.\n\n__init__(value: index) -> Self\n\nCreates a statically-known dimension.\n\nArgs:\n\n​value (index): The static dimension value.\n\nReturns:\n\nA dimension with a static value.\n\n__init__() -> Self\n\nCreates a dynamic dimension.\n\nReturns:\n\nA dimension value with no static value.\n\n__bool__\n\n__bool__(self: Self) -> Bool\n\nReturns True if the dimension has a static value.\n\nReturns:\n\nWhether the dimension has a static value.\n\n__eq__\n\n__eq__(self: Self, rhs: Self) -> Bool\n\nCompares two dimensions for equality.\n\nArgs:\n\n​rhs (Self): The other dimension.\n\nReturns:\n\nTrue if the dimensions are the same.\n\n__ne__\n\n__ne__(self: Self, rhs: Self) -> Bool\n\nCompare two dimensions for inequality.\n\nArgs:\n\n​rhs (Self): The dimension to compare.\n\nReturns:\n\nTrue if they are not equal.\n\n__mul__\n\n__mul__(self: Self, rhs: Self) -> Self\n\nMultiplies two dimensions.\n\nIf either are unknown, the result is unknown as well.\n\nArgs:\n\n​rhs (Self): The other dimension.\n\nReturns:\n\nThe product of the two dimensions.\n\nhas_value\n\nhas_value(self: Self) -> Bool\n\nReturns True if the dimension has a static value.\n\nReturns:\n\nWhether the dimension has a static value.\n\nis_dynamic\n\nis_dynamic(self: Self) -> Bool\n\nReturns True if the dimension has a dynamic value.\n\nReturns:\n\nWhether the dimension is dynamic.\n\nget\n\nget(self: Self) -> Int\n\nGets the static dimension value.\n\nReturns:\n\nThe static dimension value.\n\nis_multiple\n\nis_multiple[alignment: Int](self: Self) -> Bool\n\nChecks if the dimension is aligned.\n\nParameters:\n\n​alignment (Int): The alignment requirement.\n\nReturns:\n\nWhether the dimension is aligned.\n\n__int__\n\n__int__(self: Self) -> Int\n\nImplemented Traits:\n\n​Destructable\n​Intable\nDimList\n\nThis type represents a list of dimensions. Each dimension may have a static value or not have a value, which represents a dynamic dimension.\n\nFields:\n\n​value (VariadicList[Dim]): The underlying storage for the list of dimensions.\n\nFunctions:\n\n__init__\n\n__init__(values: VariadicList[Dim]) -> Self\n\nCreates a dimension list from the given list of values.\n\nArgs:\n\n​values (VariadicList[Dim]): The initial dim values list.\n\nReturns:\n\nA dimension list.\n\n__init__(*values: Dim) -> Self\n\nCreates a dimension list from the given Dim values.\n\nArgs:\n\n​values (*Dim): The initial dim values.\n\nReturns:\n\nA dimension list.\n\n__len__\n\n__len__(self: Self) -> Int\n\nGets the size of the DimList.\n\nReturns:\n\nThe number of elements in the DimList.\n\nat\n\nat[i: Int](self: Self) -> Dim\n\nGets the dimension at a specified index.\n\nParameters:\n\n​i (Int): The dimension index.\n\nReturns:\n\nThe dimension at the specified index.\n\nproduct\n\nproduct[length: Int](self: Self) -> Dim\n\nComputes the product of all the dimensions in the list.\n\nIf any are dynamic, the result is a dynamic dimension value.\n\nParameters:\n\n​length (Int): The number of elements in the list.\n\nReturns:\n\nThe product of all the dimensions.\n\nproduct_range\n\nproduct_range[start: Int, end: Int](self: Self) -> Dim\n\nComputes the product of a range of the dimensions in the list.\n\nIf any in the range are dynamic, the result is a dynamic dimension value.\n\nParameters:\n\n​start (Int): The starting index.\n​end (Int): The end index.\n\nReturns:\n\nThe product of all the dimensions.\n\ncontains\n\ncontains[length: Int](self: Self, value: Dim) -> Bool\n\nDetermines whether the dimension list contains a specified dimension value.\n\nParameters:\n\n​length (Int): The number of elements in the list.\n\nArgs:\n\n​value (Dim): The value to find.\n\nReturns:\n\nTrue if the list contains a dimension of the specified value.\n\nall_known\n\nall_known[length: Int](self: Self) -> Bool\n\nDetermines whether all dimensions are statically known.\n\nParameters:\n\n​length (Int): The number of elements in the list.\n\nReturns:\n\nTrue if all dimensions have a static value.\n\ncreate_unknown\n\nstatic create_unknown[length: Int]() -> Self\n\nCreates a dimension list of all dynamic dimension values.\n\nParameters:\n\n​length (Int): The number of elements in the list.\n\nReturns:\n\nA list of all dynamic dimension values.\n\nImplemented Traits:\n\n​Destructable\n​Sized\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - index",
    "url": "https://docs.modular.com/mojo/stdlib/utils/index_.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nindex\nlist\nstatic_tuple\nvector\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nStaticIntTuple\n__init__\n__getitem__\n__setitem__\n__lt__\n__le__\n__eq__\n__ne__\n__gt__\n__ge__\n__add__\n__sub__\n__mul__\n__floordiv__\n__str__\n__len__\nas_tuple\nflattened_length\nremu\nIndex\nproduct\nindex\n\nModule\n\nImplements StaticIntTuple which is commonly used to represent N-D indices.\n\nYou can import these APIs from the utils package. For example:\n\nfrom utils.index import StaticIntTuple\n\nAliases:\n\n​mlir_bool = scalar<bool>\nStaticIntTuple\n\nA base struct that implements size agnostic index functions.\n\nParameters:\n\n​size (Int): The size of the tuple.\n\nFields:\n\n​data (StaticTuple[size, Int]): The underlying storage of the tuple value.\n\nFunctions:\n\n__init__\n\n__init__() -> Self\n\nConstructs a static int tuple of the given size.\n\nReturns:\n\nThe constructed tuple.\n\n__init__(value: index) -> Self\n\nConstructs a sized 1 static int tuple of given the element value.\n\nArgs:\n\n​value (index): The initial value.\n\nReturns:\n\nThe constructed tuple.\n\n__init__(*elems: Int) -> Self\n\nConstructs a static int tuple given a set of arguments.\n\nArgs:\n\n​elems (*Int): The elements to construct the tuple.\n\nReturns:\n\nThe constructed tuple.\n\n__init__(elem: Int) -> Self\n\nConstructs a static int tuple given a set of arguments.\n\nArgs:\n\n​elem (Int): The elem to splat into the tuple.\n\nReturns:\n\nThe constructed tuple.\n\n__init__(values: VariadicList[Int]) -> Self\n\nCreates a tuple constant using the specified values.\n\nArgs:\n\n​values (VariadicList[Int]): The list of values.\n\nReturns:\n\nA tuple with the values filled in.\n\n__init__(values: DimList) -> Self\n\nCreates a tuple constant using the specified values.\n\nArgs:\n\n​values (DimList): The list of values.\n\nReturns:\n\nA tuple with the values filled in.\n\n__getitem__\n\n__getitem__(self: Self, index: Int) -> Int\n\nGets an element from the tuple by index.\n\nArgs:\n\n​index (Int): The element index.\n\nReturns:\n\nThe tuple element value.\n\n__setitem__\n\n__setitem__[index: Int](inout self: Self, val: Int)\n\nSets an element in the tuple at the given static index.\n\nParameters:\n\n​index (Int): The element index.\n\nArgs:\n\n​val (Int): The value to store.\n\n__setitem__(inout self: Self, index: Int, val: Int)\n\nSets an element in the tuple at the given index.\n\nArgs:\n\n​index (Int): The element index.\n​val (Int): The value to store.\n__lt__\n\n__lt__(self: Self, rhs: Self) -> Bool\n\nCompares this tuple to another tuple using LT comparison.\n\nA tuple is less-than another tuple if all corresponding elements of lhs is less than rhs.\n\nNote: This is not a lexical comparison.\n\nArgs:\n\n​rhs (Self): Right hand side tuple.\n\nReturns:\n\nThe comparison result.\n\n__le__\n\n__le__(self: Self, rhs: Self) -> Bool\n\nCompares this tuple to another tuple using LE comparison.\n\nA tuple is less-or-equal than another tuple if all corresponding elements of lhs is less-or-equal than rhs.\n\nNote: This is not a lexical comparison.\n\nArgs:\n\n​rhs (Self): Right hand side tuple.\n\nReturns:\n\nThe comparison result.\n\n__eq__\n\n__eq__(self: Self, rhs: Self) -> Bool\n\nCompares this tuple to another tuple for equality.\n\nThe tuples are equal if all corresponding elements are equal.\n\nArgs:\n\n​rhs (Self): The other tuple.\n\nReturns:\n\nThe comparison result.\n\n__ne__\n\n__ne__(self: Self, rhs: Self) -> Bool\n\nCompares this tuple to another tuple for non-equality.\n\nThe tuples are non-equal if at least one element of LHS isn’t equal to the corresponding element from RHS.\n\nArgs:\n\n​rhs (Self): The other tuple.\n\nReturns:\n\nThe comparison result.\n\n__gt__\n\n__gt__(self: Self, rhs: Self) -> Bool\n\nCompares this tuple to another tuple using GT comparison.\n\nA tuple is greater-than than another tuple if all corresponding elements of lhs is greater-than than rhs.\n\nNote: This is not a lexical comparison.\n\nArgs:\n\n​rhs (Self): Right hand side tuple.\n\nReturns:\n\nThe comparison result.\n\n__ge__\n\n__ge__(self: Self, rhs: Self) -> Bool\n\nCompares this tuple to another tuple using GE comparison.\n\nA tuple is greater-or-equal than another tuple if all corresponding elements of lhs is greater-or-equal than rhs.\n\nNote: This is not a lexical comparison.\n\nArgs:\n\n​rhs (Self): Right hand side tuple.\n\nReturns:\n\nThe comparison result.\n\n__add__\n\n__add__(self: Self, rhs: Self) -> Self\n\nPerforms element-wise integer add.\n\nArgs:\n\n​rhs (Self): Right hand side operand.\n\nReturns:\n\nThe resulting index tuple.\n\n__sub__\n\n__sub__(self: Self, rhs: Self) -> Self\n\nPerforms element-wise integer subtract.\n\nArgs:\n\n​rhs (Self): Right hand side operand.\n\nReturns:\n\nThe resulting index tuple.\n\n__mul__\n\n__mul__(self: Self, rhs: Self) -> Self\n\nPerforms element-wise integer multiply.\n\nArgs:\n\n​rhs (Self): Right hand side operand.\n\nReturns:\n\nThe resulting index tuple.\n\n__floordiv__\n\n__floordiv__(self: Self, rhs: Self) -> Self\n\nPerforms element-wise integer floor division.\n\nArgs:\n\n​rhs (Self): Right hand side operand.\n\nReturns:\n\nThe resulting index tuple.\n\n__str__\n\n__str__(self: Self) -> String\n\nGet the tuple as a string.\n\nReturns:\n\nA string representation.\n\n__len__\n\n__len__(self: Self) -> Int\n\nReturns the size of the tuple.\n\nReturns:\n\nThe tuple size.\n\nas_tuple\n\nas_tuple(self: Self) -> StaticTuple[size, Int]\n\nConverts this StaticIntTuple to StaticTuple.\n\nReturns:\n\nThe corresponding StaticTuple object.\n\nflattened_length\n\nflattened_length(self: Self) -> Int\n\nReturns the flattened length of the tuple.\n\nReturns:\n\nThe flattened length of the tuple.\n\nremu\n\nremu(self: Self, rhs: Self) -> Self\n\nPerforms element-wise integer unsigned modulo.\n\nArgs:\n\n​rhs (Self): Right hand side operand.\n\nReturns:\n\nThe resulting index tuple.\n\nImplemented Traits:\n\n​Destructable\n​Sized\n​Stringable\nIndex\n\nIndex[T0: Intable](x: T0) -> StaticIntTuple[1]\n\nConstructs a 1-D Index from the given value.\n\nParameters:\n\n​T0 (Intable): The type of the 1st argument.\n\nArgs:\n\n​x (T0): The initial value.\n\nReturns:\n\nThe constructed StaticIntTuple.\n\nIndex[T0: Intable, T1: Intable](x: T0, y: T1) -> StaticIntTuple[2]\n\nConstructs a 2-D Index from the given values.\n\nParameters:\n\n​T0 (Intable): The type of the 1st argument.\n​T1 (Intable): The type of the 2nd argument.\n\nArgs:\n\n​x (T0): The 1st initial value.\n​y (T1): The 2nd initial value.\n\nReturns:\n\nThe constructed StaticIntTuple.\n\nIndex[T0: Intable, T1: Intable, T2: Intable](x: T0, y: T1, z: T2) -> StaticIntTuple[3]\n\nConstructs a 3-D Index from the given values.\n\nParameters:\n\n​T0 (Intable): The type of the 1st argument.\n​T1 (Intable): The type of the 2nd argument.\n​T2 (Intable): The type of the 3rd argument.\n\nArgs:\n\n​x (T0): The 1st initial value.\n​y (T1): The 2nd initial value.\n​z (T2): The 3nd initial value.\n\nReturns:\n\nThe constructed StaticIntTuple.\n\nIndex[T0: Intable, T1: Intable, T2: Intable, T3: Intable](x: T0, y: T1, z: T2, w: T3) -> StaticIntTuple[4]\n\nConstructs a 4-D Index from the given values.\n\nParameters:\n\n​T0 (Intable): The type of the 1st argument.\n​T1 (Intable): The type of the 2nd argument.\n​T2 (Intable): The type of the 3rd argument.\n​T3 (Intable): The type of the 4th argument.\n\nArgs:\n\n​x (T0): The 1st initial value.\n​y (T1): The 2nd initial value.\n​z (T2): The 3nd initial value.\n​w (T3): The 4th initial value.\n\nReturns:\n\nThe constructed StaticIntTuple.\n\nIndex[T0: Intable, T1: Intable, T2: Intable, T3: Intable, T4: Intable](x: T0, y: T1, z: T2, w: T3, v: T4) -> StaticIntTuple[5]\n\nConstructs a 5-D Index from the given values.\n\nParameters:\n\n​T0 (Intable): The type of the 1st argument.\n​T1 (Intable): The type of the 2nd argument.\n​T2 (Intable): The type of the 3rd argument.\n​T3 (Intable): The type of the 4th argument.\n​T4 (Intable): The type of the 5th argument.\n\nArgs:\n\n​x (T0): The 1st initial value.\n​y (T1): The 2nd initial value.\n​z (T2): The 3nd initial value.\n​w (T3): The 4th initial value.\n​v (T4): The 5th initial value.\n\nReturns:\n\nThe constructed StaticIntTuple.\n\nproduct\n\nproduct[size: Int](tuple: StaticIntTuple[size], end_idx: Int) -> Int\n\nComputes a product of values in the tuple up to the given index.\n\nParameters:\n\n​size (Int): The tuple size.\n\nArgs:\n\n​tuple (StaticIntTuple[size]): The tuple to get a product of.\n​end_idx (Int): The end index.\n\nReturns:\n\nThe product of all tuple elements in the given range.\n\nproduct[size: Int](tuple: StaticIntTuple[size], start_idx: Int, end_idx: Int) -> Int\n\nComputes a product of values in the tuple in the given index range.\n\nParameters:\n\n​size (Int): The tuple size.\n\nArgs:\n\n​tuple (StaticIntTuple[size]): The tuple to get a product of.\n​start_idx (Int): The start index of the range.\n​end_idx (Int): The end index of the range.\n\nReturns:\n\nThe product of all tuple elements in the given range.\n\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - tensor_spec",
    "url": "https://docs.modular.com/mojo/stdlib/tensor/tensor_spec.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntensor\ntensor_shape\ntensor_spec\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nTensorSpec\n__init__\n__copyinit__\n__moveinit__\n__getitem__\n__eq__\n__ne__\nrank\ndtype\nnum_elements\nbytecount\n__repr__\n__str__\nfrom_bytes\ntensor_spec\n\nModule\n\nImplements the TensorSpec type.\n\nYou can import these APIs from the tensor package. For example:\n\nfrom tensor import TensorSpec\nTensorSpec\n\nA space efficient representation of a tensor shape and dtype. This struct implements value semantics and owns its underlying data.\n\nFields:\n\n​shape (TensorShape): The underlying shape of the specification.\n\nFunctions:\n\n__init__\n\n__init__(inout self: Self)\n\nDefault initializer for TensorShape.\n\n__init__(inout self: Self, type: DType, *shapes: Int)\n\nInitializes a Tensorspec from the dtype and shapes provided.\n\nArgs:\n\n​type (DType): The dtype of the specification.\n​shapes (*Int): The shapes to initialize the shape with.\n\n__init__(inout self: Self, type: DType, shapes: VariadicList[Int])\n\nInitializes a Tensorspec from the dtype and shapes provided.\n\nArgs:\n\n​type (DType): The dtype of the specification.\n​shapes (VariadicList[Int]): The shapes to initialize the shape with.\n\n__init__(inout self: Self, type: DType, shapes: DynamicVector[Int])\n\nInitializes a Tensorspec from the dtype and shapes provided.\n\nArgs:\n\n​type (DType): The dtype of the specification.\n​shapes (DynamicVector[Int]): The shapes to initialize the shape with.\n\n__init__(inout self: Self, type: DType, owned shape: TensorShape)\n\nInitializes a Tensorspec from the dtype and shape provided.\n\nArgs:\n\n​type (DType): The dtype of the specification.\n​shape (TensorShape): The shapes to initialize the shape with.\n__copyinit__\n\n__copyinit__(inout self: Self, other: Self)\n\nCreates a deep copy of an existing spec.\n\nArgs:\n\n​other (Self): The spec to copy.\n__moveinit__\n\n__moveinit__(inout self: Self, owned existing: Self)\n\nMove initializer for the spec.\n\nArgs:\n\n​existing (Self): The spec to move.\n__getitem__\n\n__getitem__(self: Self, index: Int) -> Int\n\nGets the dimension at the specified index.\n\nArgs:\n\n​index (Int): The dimension index.\n\nReturns:\n\nThe dimension at the specified index.\n\n__eq__\n\n__eq__(self: Self, other: Self) -> Bool\n\nReturns True if the two values are the same and False otherwise.\n\nArgs:\n\n​other (Self): The other TensorSpec to compare against.\n\nReturns:\n\nTrue if the two specs are the same and False otherwise.\n\n__ne__\n\n__ne__(self: Self, other: Self) -> Bool\n\nReturns True if the two values are not the same and False otherwise.\n\nArgs:\n\n​other (Self): The other TensorSpec to compare against.\n\nReturns:\n\nTrue if the two specs are the not the same and False otherwise.\n\nrank\n\nrank(self: Self) -> Int\n\nGets the rank of the spec.\n\nReturns:\n\nThe rank of the spec.\n\ndtype\n\ndtype(self: Self) -> DType\n\nGets the DType of the spec.\n\nReturns:\n\nThe DType of the spec.\n\nnum_elements\n\nnum_elements(self: Self) -> Int\n\nGets the total number of elements in the spec.\n\nReturns:\n\nThe total number of elements in the spec.\n\nbytecount\n\nbytecount(self: Self) -> Int\n\nGets the total byte count.\n\nReturns:\n\nThe total byte count.\n\n__repr__\n\n__repr__(self: Self) -> String\n\nReturns the string representation of the spec.\n\nReturns:\n\nThe string representation of the spec.\n\n__str__\n\n__str__(self: Self) -> String\n\nReturns the string representation of the spec.\n\nReturns:\n\nThe string representation of the spec.\n\nfrom_bytes\n\nstatic from_bytes(data: DTypePointer[si8, 0]) -> Self\n\nCreate a TensorSpec object from serialized bytes.\n\nArgs:\n\n​data (DTypePointer[si8, 0]): DTypePointer to serialized bytes.\n\nReturns:\n\nGiven bytes as TensorSpec.\n\nImplemented Traits:\n\n​Destructable\n​Stringable\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - testing",
    "url": "https://docs.modular.com/mojo/stdlib/testing/testing.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nassert_true\nassert_false\nassert_equal\nassert_not_equal\nassert_almost_equal\ntesting\n\nModule\n\nImplements various testing utils.\n\nYou can import these APIs from the testing package. For example:\n\nfrom testing import assert_true\nassert_true\n\nassert_true(val: object, msg: String)\n\nAsserts that the input value is True. If it is not then an Error is raised.\n\nRaises: An Error with the provided message if assert fails and None otherwise.\n\nArgs:\n\n​val (object): The value to assert to be True.\n​msg (String): The message to be printed if the assertion fails.\n\nassert_true(val: Bool, msg: String)\n\nAsserts that the input value is True. If it is not then an Error is raised.\n\nRaises: An Error with the provided message if assert fails and None otherwise.\n\nArgs:\n\n​val (Bool): The value to assert to be True.\n​msg (String): The message to be printed if the assertion fails.\nassert_false\n\nassert_false(val: object, msg: String)\n\nAsserts that the input value is False. If it is not then an Error is raised.\n\nRaises: An Error with the provided message if assert fails and None otherwise.\n\nArgs:\n\n​val (object): The value to assert to be False.\n​msg (String): The message to be printed if the assertion fails.\n\nassert_false(val: Bool, msg: String)\n\nAsserts that the input value is False. If it is not then an Error is raised.\n\nRaises: An Error with the provided message if assert fails and None otherwise.\n\nArgs:\n\n​val (Bool): The value to assert to be False.\n​msg (String): The message to be printed if the assertion fails.\nassert_equal\n\nassert_equal(lhs: Int, rhs: Int)\n\nAsserts that the input values are equal. If it is not then an Error is raised.\n\nRaises: An Error with the provided message if assert fails and None otherwise.\n\nArgs:\n\n​lhs (Int): The lhs of the equality.\n​rhs (Int): The rhs of the equality.\n\nassert_equal(lhs: String, rhs: String)\n\nAsserts that the input values are equal. If it is not then an Error is raised.\n\nRaises: An Error with the provided message if assert fails and None otherwise.\n\nArgs:\n\n​lhs (String): The lhs of the equality.\n​rhs (String): The rhs of the equality.\n\nassert_equal[type: DType, size: Int](lhs: SIMD[type, size], rhs: SIMD[type, size])\n\nAsserts that the input values are equal. If it is not then an Error is raised.\n\nRaises: An Error with the provided message if assert fails and None otherwise.\n\nParameters:\n\n​type (DType): The dtype of the left- and right-hand-side SIMD vectors.\n​size (Int): The width of the left- and right-hand-side SIMD vectors.\n\nArgs:\n\n​lhs (SIMD[type, size]): The lhs of the equality.\n​rhs (SIMD[type, size]): The rhs of the equality.\nassert_not_equal\n\nassert_not_equal(lhs: Int, rhs: Int)\n\nAsserts that the input values are not equal. If it is not then an Error is raised.\n\nRaises: An Error with the provided message if assert fails and None otherwise.\n\nArgs:\n\n​lhs (Int): The lhs of the inequality.\n​rhs (Int): The rhs of the inequality.\n\nassert_not_equal(lhs: String, rhs: String)\n\nAsserts that the input values are not equal. If it is not then an an Error is raised.\n\nRaises: An Error with the provided message if assert fails and None otherwise.\n\nArgs:\n\n​lhs (String): The lhs of the inequality.\n​rhs (String): The rhs of the inequality.\n\nassert_not_equal[type: DType, size: Int](lhs: SIMD[type, size], rhs: SIMD[type, size])\n\nAsserts that the input values are not equal. If it is not then an Error is raised.\n\nRaises: An Error with the provided message if assert fails and None otherwise.\n\nParameters:\n\n​type (DType): The dtype of the left- and right-hand-side SIMD vectors.\n​size (Int): The width of the left- and right-hand-side SIMD vectors.\n\nArgs:\n\n​lhs (SIMD[type, size]): The lhs of the inequality.\n​rhs (SIMD[type, size]): The rhs of the inequality.\nassert_almost_equal\n\nassert_almost_equal[type: DType, size: Int](lhs: SIMD[type, size], rhs: SIMD[type, size], absolute_tolerance: SIMD[type, 1], relative_tolerance: SIMD[type, 1])\n\nAsserts that the input values are equal up to a tolerance. If it is not then an Error is raised.\n\nRaises: An Error with the provided message if assert fails and None otherwise.\n\nParameters:\n\n​type (DType): The dtype of the left- and right-hand-side SIMD vectors.\n​size (Int): The width of the left- and right-hand-side SIMD vectors.\n\nArgs:\n\n​lhs (SIMD[type, size]): The lhs of the equality.\n​rhs (SIMD[type, size]): The rhs of the equality.\n​absolute_tolerance (SIMD[type, 1]): The absolute tolerance.\n​relative_tolerance (SIMD[type, 1]): The relative tolerance.\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - time",
    "url": "https://docs.modular.com/mojo/stdlib/time/time.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nnow\ntime_function\nsleep\ntime\n\nModule\n\nImplements basic utils for working with time.\n\nYou can import these APIs from the time package. For example:\n\nfrom time import now\nnow\n\nnow() -> Int\n\nReturns the current monotonic time time in nanoseconds. This function queries the current platform’s monotonic clock, making it useful for measuring time differences, but the significance of the returned value varies depending on the underlying implementation.\n\nReturns:\n\nThe current time in ns.\n\ntime_function\n\ntime_function[func: fn() capturing -> None]() -> Int\n\nMeasures the time spent in the function.\n\nParameters:\n\n​func (fn() capturing -> None): The function to time.\n\nReturns:\n\nThe time elapsed in the function in ns.\n\nsleep\n\nsleep(sec: SIMD[f64, 1])\n\nSuspends the current thread for the seconds specified.\n\nArgs:\n\n​sec (SIMD[f64, 1]): The number of seconds to sleep for.\n\nsleep(sec: Int)\n\nSuspends the current thread for the seconds specified.\n\nArgs:\n\n​sec (Int): The number of seconds to sleep for.\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - tensor_shape",
    "url": "https://docs.modular.com/mojo/stdlib/tensor/tensor_shape.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntensor\ntensor_shape\ntensor_spec\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nTensorShape\n__init__\n__copyinit__\n__moveinit__\n__del__\n__getitem__\n__eq__\n__ne__\nrank\nnum_elements\n__repr__\n__str__\ntensor_shape\n\nModule\n\nImplements the TensorShape type.\n\nYou can import these APIs from the tensor package. For example:\n\nfrom tensor import TensorShape\nTensorShape\n\nA space efficient representation of a tensor shape. This struct implements value semantics and owns its underlying data.\n\nFunctions:\n\n__init__\n\n__init__(inout self: Self)\n\nDefault initializer for TensorShape.\n\n__init__(inout self: Self, *shapes: Int)\n\nInitializes a TensorShape from the values provided.\n\nArgs:\n\n​shapes (*Int): The shapes to initialize the shape with.\n\n__init__(inout self: Self, shapes: VariadicList[Int])\n\nInitializes a TensorShape from the values provided.\n\nArgs:\n\n​shapes (VariadicList[Int]): The shapes to initialize the shape with.\n\n__init__(inout self: Self, shapes: DynamicVector[Int])\n\nInitializes a TensorShape from the vector provided.\n\nArgs:\n\n​shapes (DynamicVector[Int]): The vector to initialize the shape with.\n\n__init__[rank: Int](inout self: Self, shapes: StaticIntTuple[rank])\n\nInitializes a TensorShape from the values provided.\n\nArgs:\n\n​shapes (StaticIntTuple[rank]): The shapes to initialize the shape with.\n__copyinit__\n\n__copyinit__(inout self: Self, other: Self)\n\nCreates a deep copy of an existing shape.\n\nArgs:\n\n​other (Self): The shape to copy.\n__moveinit__\n\n__moveinit__(inout self: Self, owned existing: Self)\n\nMove initializer for the shape.\n\nArgs:\n\n​existing (Self): The shape to move.\n__del__\n\n__del__(owned self: Self)\n\nDelete the shape and release any owned memory.\n\n__getitem__\n\n__getitem__(self: Self, index: Int) -> Int\n\nGets the dimension at the specified index.\n\nArgs:\n\n​index (Int): The dimension index.\n\nReturns:\n\nThe dimension at the specified index.\n\n__eq__\n\n__eq__(self: Self, other: Self) -> Bool\n\nReturns True if the two values are the same and False otherwise.\n\nArgs:\n\n​other (Self): The other TensorShape to compare against.\n\nReturns:\n\nTrue if the two shapes are the same and False otherwise.\n\n__ne__\n\n__ne__(self: Self, other: Self) -> Bool\n\nReturns True if the two values are not the same and False otherwise.\n\nArgs:\n\n​other (Self): The other TensorShape to compare against.\n\nReturns:\n\nTrue if the two shapes are the not the same and False otherwise.\n\nrank\n\nrank(self: Self) -> Int\n\nGets the rank of the shape.\n\nReturns:\n\nThe rank of the shape.\n\nnum_elements\n\nnum_elements(self: Self) -> Int\n\nGets the total number of elements in the shape.\n\nReturns:\n\nThe total number of elements in the shape.\n\n__repr__\n\n__repr__(self: Self) -> String\n\nReturns the string representation of the shape.\n\nReturns:\n\nThe string representation of the shape.\n\n__str__\n\n__str__(self: Self) -> String\n\nReturns the string representation of the shape.\n\nReturns:\n\nThe string representation of the shape.\n\nImplemented Traits:\n\n​Destructable\n​Stringable\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - tensor",
    "url": "https://docs.modular.com/mojo/stdlib/tensor/tensor.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntensor\ntensor_shape\ntensor_spec\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nTensor\n__init__\n__copyinit__\n__moveinit__\n__del__\n__getitem__\n__setitem__\n__eq__\n__ne__\n__add__\n__sub__\n__mul__\n__truediv__\n__pow__\n__radd__\n__rsub__\n__rmul__\n__rtruediv__\n__ipow__\nireshape\nreshape\nastype\ndata\ntype\nrank\nnum_elements\nbytecount\nspec\nshape\ndim\n__str__\n__repr__\nsimd_load\nsimd_store\ntofile\nfromfile\nsave\nload\ntensor\n\nModule\n\nImplements the Tensor type.\n\nExample:\n\nfrom tensor import Tensor, TensorSpec, TensorShape\nfrom utils.index import Index\nfrom random import rand\n\nlet height = 256\nlet width = 256\nlet channels = 3\n\n# Create the tensor of dimensions height, width, channels\n# and fill with random values.\nlet image = rand[DType.float32](height, width, channels)\n\n# Declare the grayscale image.\nlet spec = TensorSpec(DType.float32, height, width)\nvar gray_scale_image = Tensor[DType.float32](spec)\n\n# Perform the RGB to grayscale transform.\nfor y in range(height):\n  for x in range(width):\n    let r = image[y,x,0]\n    let g = image[y,x,1]\n    let b = image[y,x,2]\n    gray_scale_image[Index(y,x)] = 0.299 * r + 0.587 * g + 0.114 * b\n\nprint(gray_scale_image.shape().__str__())\nTensor\n\nA tensor type which owns its underlying data and is parameterized on DType.\n\nParameters:\n\n​dtype (DType): The underlying element type of the tensor.\n\nFunctions:\n\n__init__\n\n__init__(inout self: Self)\n\nDefault initializer for TensorShape.\n\n__init__(inout self: Self, *dims: Int)\n\nAllocates a tensor using the shape provided.\n\nArgs:\n\n​dims (*Int): The tensor dimensions.\n\n__init__(inout self: Self, owned shape: TensorShape)\n\nAllocates a tensor using the shape provided.\n\nArgs:\n\n​shape (TensorShape): The tensor shape.\n\n__init__(inout self: Self, owned spec: TensorSpec)\n\nAllocates a tensor using the spec provided.\n\nArgs:\n\n​spec (TensorSpec): The tensor spec.\n\n__init__(inout self: Self, owned ptr: DTypePointer[dtype, 0], owned shape: TensorShape)\n\nInitializes a Tensor from the pointer and shape provided. The caller relinquishes the ownership of the pointer being passed in.\n\nArgs:\n\n​ptr (DTypePointer[dtype, 0]): The data pointer.\n​shape (TensorShape): The tensor shapes.\n\n__init__(inout self: Self, owned ptr: DTypePointer[dtype, 0], owned spec: TensorSpec)\n\nInitializes a Tensor from the pointer and shape provided. The caller relinquishes the ownership of the pointer being passed in.\n\nArgs:\n\n​ptr (DTypePointer[dtype, 0]): The data pointer.\n​spec (TensorSpec): The tensor spec.\n\n__init__(inout self: Self, shape: TensorShape, *data: SIMD[dtype, 1])\n\nInitializes a Tensor from the shape and data provided. The caller assumes ownership of the new tensor data.\n\nArgs:\n\n​shape (TensorShape): The tensor shape.\n​data (*SIMD[dtype, 1]): Elements to place into the created tensor.\n__copyinit__\n\n__copyinit__(inout self: Self, other: Self)\n\nCreates a deep copy of an existing tensor.\n\nArgs:\n\n​other (Self): The tensor to copy from.\n__moveinit__\n\n__moveinit__(inout self: Self, owned existing: Self)\n\nMove initializer for the tensor.\n\nArgs:\n\n​existing (Self): The tensor to move.\n__del__\n\n__del__(owned self: Self)\n\nDelete the spec and release any owned memory.\n\n__getitem__\n\n__getitem__(self: Self, index: Int) -> SIMD[dtype, 1]\n\nGets the value at the specified index.\n\nArgs:\n\n​index (Int): The index of the value to retrieve.\n\nReturns:\n\nThe value at the specified indices.\n\n__getitem__(self: Self, *indices: Int) -> SIMD[dtype, 1]\n\nGets the value at the specified indices.\n\nArgs:\n\n​indices (*Int): The indices of the value to retrieve.\n\nReturns:\n\nThe value at the specified indices.\n\n__getitem__(self: Self, indices: VariadicList[Int]) -> SIMD[dtype, 1]\n\nGets the value at the specified indices.\n\nArgs:\n\n​indices (VariadicList[Int]): The indices of the value to retrieve.\n\nReturns:\n\nThe value at the specified indices.\n\n__getitem__[len: Int](self: Self, indices: StaticIntTuple[len]) -> SIMD[dtype, 1]\n\nGets the SIMD value at the specified indices.\n\nParameters:\n\n​len (Int): The length of the indecies.\n\nArgs:\n\n​indices (StaticIntTuple[len]): The indices of the value to retrieve.\n\nReturns:\n\nThe value at the specified indices.\n\n__setitem__\n\n__setitem__(inout self: Self, index: Int, val: SIMD[dtype, 1])\n\nSets the value at the specified index.\n\nArgs:\n\n​index (Int): The index of the value to set.\n​val (SIMD[dtype, 1]): The value to store.\n\n__setitem__(inout self: Self, indices: VariadicList[Int], val: SIMD[dtype, 1])\n\nSets the value at the specified indices.\n\nArgs:\n\n​indices (VariadicList[Int]): The indices of the value to set.\n​val (SIMD[dtype, 1]): The value to store.\n\n__setitem__[len: Int](inout self: Self, indices: StaticIntTuple[len], val: SIMD[dtype, 1])\n\nSets the value at the specified indices.\n\nParameters:\n\n​len (Int): The length of the indecies.\n\nArgs:\n\n​indices (StaticIntTuple[len]): The indices of the value to set.\n​val (SIMD[dtype, 1]): The value to store.\n__eq__\n\n__eq__(self: Self, other: Self) -> Bool\n\nReturns True if the two tensors are the same and False otherwise.\n\nArgs:\n\n​other (Self): The other Tensor to compare against.\n\nReturns:\n\nTrue if the two tensors are the same and False otherwise.\n\n__ne__\n\n__ne__(self: Self, other: Self) -> Bool\n\nReturns True if the two tensors are not the same and False otherwise.\n\nArgs:\n\n​other (Self): The other Tensor to compare against.\n\nReturns:\n\nTrue if the two tensors are the not the same and False otherwise.\n\n__add__\n\n__add__(self: Self, other: Self) -> Self\n\nAdds this tensor with another tensor.\n\nConstraints:\n\nThe two tensors must have the same rank, type, and dimensions.\n\nArgs:\n\n​other (Self): The RHS of the add operation.\n\nReturns:\n\nThe addition of both tensors.\n\n__add__(self: Self, other: SIMD[dtype, 1]) -> Self\n\nAdds this tensor with a scalar.\n\nArgs:\n\n​other (SIMD[dtype, 1]): The RHS of the add operation.\n\nReturns:\n\nThe addition result.\n\n__sub__\n\n__sub__(self: Self, other: Self) -> Self\n\nSubtracts a tensor from this tensor.\n\nConstraints:\n\nThe two tensors must have the same rank, type, and dimensions.\n\nArgs:\n\n​other (Self): The RHS of the sub operation.\n\nReturns:\n\nThe addition of both tensors.\n\n__sub__(self: Self, other: SIMD[dtype, 1]) -> Self\n\nSubtracts a scalar from this tensor.\n\nArgs:\n\n​other (SIMD[dtype, 1]): The RHS of the sub operation.\n\nReturns:\n\nThe subtraction result.\n\n__mul__\n\n__mul__(self: Self, other: Self) -> Self\n\nMultiplies this tensor with another tensor.\n\nConstraints:\n\nThe two tensors must have the same rank, type, and dimensions.\n\nArgs:\n\n​other (Self): The RHS of the mul operation.\n\nReturns:\n\nThe multiplication of both tensors.\n\n__mul__(self: Self, other: SIMD[dtype, 1]) -> Self\n\nMultiplies this tensor with a scalar.\n\nArgs:\n\n​other (SIMD[dtype, 1]): The RHS of the mul operation.\n\nReturns:\n\nThe multiplication result.\n\n__truediv__\n\n__truediv__(self: Self, other: Self) -> Self\n\nDivides this tensor by another tensor.\n\nTODO: Change the return type if inputs are int\n\nConstraints:\n\nThe two tensors must have the same rank, type, and dimensions.\n\nArgs:\n\n​other (Self): The RHS of the div operation.\n\nReturns:\n\nThe division of both tensors.\n\n__truediv__(self: Self, other: SIMD[dtype, 1]) -> Self\n\nDivides this tensor by a scalar.\n\nArgs:\n\n​other (SIMD[dtype, 1]): The RHS of the div operation.\n\nReturns:\n\nThe division result.\n\n__pow__\n\n__pow__(self: Self, exponent: Int) -> Self\n\nReturns a copy of the tensor with each element raised to the power of exponent.\n\nConstraints:\n\nFor integral values the exponent cannot be negative.\n\nArgs:\n\n​exponent (Int): Integer power to raise tensor to.\n\nReturns:\n\nAn exponentiated copy of tensor.\n\n__radd__\n\n__radd__(self: Self, other: SIMD[dtype, 1]) -> Self\n\nAdds this tensor with a scalar.\n\nArgs:\n\n​other (SIMD[dtype, 1]): The LHS of the add operation.\n\nReturns:\n\nThe addition result.\n\n__rsub__\n\n__rsub__(self: Self, other: SIMD[dtype, 1]) -> Self\n\nSubtracts this tensor from a scalar.\n\nArgs:\n\n​other (SIMD[dtype, 1]): The LHS of the sub operation.\n\nReturns:\n\nThe addition result.\n\n__rmul__\n\n__rmul__(self: Self, other: SIMD[dtype, 1]) -> Self\n\nMultiplies this tensor with a scalar.\n\nArgs:\n\n​other (SIMD[dtype, 1]): The LHS of the mul operation.\n\nReturns:\n\nThe multiplication result.\n\n__rtruediv__\n\n__rtruediv__(self: Self, other: SIMD[dtype, 1]) -> Self\n\nDivides a scalar by this tensor, broadcasting elementwise.\n\nArgs:\n\n​other (SIMD[dtype, 1]): The LHS of the div operation.\n\nReturns:\n\nThe division result.\n\n__ipow__\n\n__ipow__(inout self: Self, exponent: Int)\n\nIn-place pow operator.\n\nRaises each element of the tensor to the power of exponent in place.\n\nConstraints:\n\nFor integral values the exponent cannot be negative.\n\nArgs:\n\n​exponent (Int): Integer power to raise tensor to.\nireshape\n\nireshape(inout self: Self, new_shape: TensorShape)\n\n(Inplace) Reshapes the tensor by assigning it a new shape.\n\nArgs:\n\n​new_shape (TensorShape): The new shape.\nreshape\n\nreshape(inout self: Self, new_shape: TensorShape) -> Self\n\nReturns a reshaped tensor.\n\nArgs:\n\n​new_shape (TensorShape): The new shape.\n\nReturns:\n\nA Tensor that is a reshaped version of the original tensor.\n\nastype\n\nastype[new_dtype: DType](self: Self) -> Tensor[new_dtype]\n\nCopy the Tensor with elements cast to the new type.\n\nParameters:\n\n​new_dtype (DType): The type to cast the values to.\n\nReturns:\n\nA new tensor with the same values but the new type.\n\ndata\n\ndata(self: Self) -> DTypePointer[dtype, 0]\n\nGets the underlying Data pointer to the Tensor.\n\nReturns:\n\nThe underlying data pointer of the tensor.\n\ntype\n\ntype(self: Self) -> DType\n\nGets the underlying DType of the tensor.\n\nReturns:\n\nThe underlying DType of the tensor.\n\nrank\n\nrank(self: Self) -> Int\n\nGets the rank of the tensor.\n\nReturns:\n\nThe rank of the tensor.\n\nnum_elements\n\nnum_elements(self: Self) -> Int\n\nGets the total number of elements in the tensor.\n\nReturns:\n\nThe total number of elements in the tensor.\n\nbytecount\n\nbytecount(self: Self) -> Int\n\nGets the total bytecount of the tensor.\n\nReturns:\n\nThe total bytecount of the tensor.\n\nspec\n\nspec(self: Self) -> TensorSpec\n\nGets the specification of the tensor.\n\nReturns:\n\nThe underlying tensor spec of the tensor.\n\nshape\n\nshape(self: Self) -> TensorShape\n\nGets the shape of the tensor.\n\nReturns:\n\nThe underlying tensor shape of the tensor.\n\ndim\n\ndim(self: Self, idx: Int) -> Int\n\nGets the dimension at the specified index.\n\nArgs:\n\n​idx (Int): The dimension index.\n\nReturns:\n\nThe dimension at the specified index.\n\n__str__\n\n__str__(self: Self) -> String\n\nGets the tensor as a string.\n\nReturns:\n\nA compact string of the tensor.\n\n__repr__\n\n__repr__(self: Self) -> String\n\nGets the tensor as a string.\n\nReturns:\n\nA compact string representation of the tensor.\n\nsimd_load\n\nsimd_load[simd_width: Int](self: Self, index: Int) -> SIMD[dtype, simd_width]\n\nGets the SIMD value at the specified index.\n\nParameters:\n\n​simd_width (Int): The SIMD width of the vector.\n\nArgs:\n\n​index (Int): The index of the value to retrieve.\n\nReturns:\n\nThe SIMD value at the specified indices.\n\nsimd_load[simd_width: Int](self: Self, *indices: Int) -> SIMD[dtype, simd_width]\n\nGets the SIMD value at the specified indices.\n\nParameters:\n\n​simd_width (Int): The SIMD width of the vector.\n\nArgs:\n\n​indices (*Int): The indices of the value to retrieve.\n\nReturns:\n\nThe SIMD value at the specified indices.\n\nsimd_load[simd_width: Int](self: Self, indices: VariadicList[Int]) -> SIMD[dtype, simd_width]\n\nGets the SIMD value at the specified indices.\n\nParameters:\n\n​simd_width (Int): The SIMD width of the vector.\n\nArgs:\n\n​indices (VariadicList[Int]): The indices of the value to retrieve.\n\nReturns:\n\nThe SIMD value at the specified indices.\n\nsimd_load[simd_width: Int, len: Int](self: Self, indices: StaticIntTuple[len]) -> SIMD[dtype, simd_width]\n\nGets the SIMD value at the specified indices.\n\nParameters:\n\n​simd_width (Int): The SIMD width of the vector.\n​len (Int): The length of the indecies.\n\nArgs:\n\n​indices (StaticIntTuple[len]): The indices of the value to retrieve.\n\nReturns:\n\nThe SIMD value at the specified indices.\n\nsimd_store\n\nsimd_store[simd_width: Int](inout self: Self, index: Int, val: SIMD[dtype, simd_width])\n\nSets the SIMD value at the specified index.\n\nParameters:\n\n​simd_width (Int): The SIMD width of the vector.\n\nArgs:\n\n​index (Int): The index of the value to set.\n​val (SIMD[dtype, simd_width]): The SIMD value to store.\n\nsimd_store[simd_width: Int](inout self: Self, indices: VariadicList[Int], val: SIMD[dtype, simd_width])\n\nSets the SIMD value at the specified indices.\n\nParameters:\n\n​simd_width (Int): The SIMD width of the vector.\n\nArgs:\n\n​indices (VariadicList[Int]): The indices of the value to set.\n​val (SIMD[dtype, simd_width]): The SIMD value to store.\n\nsimd_store[simd_width: Int, len: Int](inout self: Self, indices: StaticIntTuple[len], val: SIMD[dtype, simd_width])\n\nSets the SIMD value at the specified indices.\n\nParameters:\n\n​simd_width (Int): The SIMD width of the vector.\n​len (Int): The length of the indecies.\n\nArgs:\n\n​indices (StaticIntTuple[len]): The indices of the value to set.\n​val (SIMD[dtype, simd_width]): The SIMD value to store.\ntofile\n\ntofile(self: Self, path: Path)\n\nWrite values to a file.\n\nArgs:\n\n​path (Path): Path to the output file.\nfromfile\n\nstatic fromfile(path: Path) -> Self\n\nRead tensor from a file.\n\nArgs:\n\n​path (Path): Path to the output file.\n\nReturns:\n\nThe tensor read from file.\n\nsave\n\nsave(self: Self, path: Path)\n\nSave given tensor to file. This method preserves shape and datatype information.\n\nArgs:\n\n​path (Path): Path of file.\nload\n\nstatic load(path: Path) -> Self\n\nRead tensor from a file. The path should be a file saved with Tensor.save method.\n\nArgs:\n\n​path (Path): Path to the output file.\n\nReturns:\n\nThe tensor read from file.\n\nImplemented Traits:\n\n​Destructable\n​Stringable\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - param_env",
    "url": "https://docs.modular.com/mojo/stdlib/sys/param_env.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\narg\ninfo\nintrinsics\nparam_env\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nis_defined\nenv_get_int\nenv_get_string\nparam_env\n\nModule\n\nImplements functions for retrieving compile-time defines.\n\nYou can use these functions to set parameter values or runtime constants based on name-value pairs defined on the command line. For example:\n\nfrom sys.param_env import is_defined\nfrom tensor import Tensor, TensorSpec\n\nalias float_type: DType = DType.float32 if is_defined[\"FLOAT32\"]() else DType.float64\n\nlet spec = TensorSpec(float_type, 256, 256)\nvar image = Tensor[float_type](spec)\n\nAnd on the command line:\n\n  mojo -D FLOAT_32 main.mojo\n\nFor more information, see the Mojo build docs. The mojo run command also supports the -D option.\n\nYou can import these APIs from the sys package. For example:\n\nfrom sys.param_env import is_defined\nis_defined\n\nis_defined[name: StringLiteral]() -> Bool\n\nReturn true if the named value is defined.\n\nParameters:\n\n​name (StringLiteral): The name to test.\n\nReturns:\n\nTrue if the name is defined.\n\nenv_get_int\n\nenv_get_int[name: StringLiteral]() -> Int\n\nTry to get an integer-valued define. Compilation fails if the name is not defined.\n\nParameters:\n\n​name (StringLiteral): The name of the define.\n\nReturns:\n\nAn integer parameter value.\n\nenv_get_int[name: StringLiteral, default: Int]() -> Int\n\nTry to get an integer-valued define. If the name is not defined, return a default value instead.\n\nParameters:\n\n​name (StringLiteral): The name of the define.\n​default (Int): The default value to use.\n\nReturns:\n\nAn integer parameter value.\n\nenv_get_string\n\nenv_get_string[name: StringLiteral]() -> StringLiteral\n\nTry to get a string-valued define. Compilation fails if the name is not defined.\n\nParameters:\n\n​name (StringLiteral): The name of the define.\n\nReturns:\n\nA string parameter value.\n\nenv_get_string[name: StringLiteral, default: StringLiteral]() -> StringLiteral\n\nTry to get a string-valued define. If the name is not defined, return a default value instead.\n\nParameters:\n\n​name (StringLiteral): The name of the define.\n​default (StringLiteral): The default value to use.\n\nReturns:\n\nA string parameter value.\n\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - intrinsics",
    "url": "https://docs.modular.com/mojo/stdlib/sys/intrinsics.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\narg\ninfo\nintrinsics\nparam_env\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nPrefetchLocality\n__init__\nPrefetchRW\nPrefetchCache\nPrefetchOptions\nllvm_intrinsic\nexternal_call\ngather\nscatter\nprefetch\nmasked_load\nmasked_store\ncompressed_store\nstrided_load\nstrided_store\nintrinsics\n\nModule\n\nDefines intrinsics.\n\nYou can import these APIs from the complex package. For example:\n\nfrom sys.intrinsics import PrefetchLocality\nPrefetchLocality\n\nThe prefetch locality.\n\nThe locality, rw, and cache type correspond to LLVM prefetch intrinsic’s inputs (see LLVM prefetch locality)\n\nAliases:\n\n​NONE = PrefetchLocality(0): No locality.\n​LOW = PrefetchLocality(1): Low locality.\n​MEDIUM = PrefetchLocality(2): Medium locality.\n​HIGH = PrefetchLocality(3): Extremely local locality (keep in cache).\n\nFields:\n\n​value (SIMD[si32, 1]): The prefetch locality to use. It should be a value in [0, 3].\n\nFunctions:\n\n__init__\n\n__init__(value: Int) -> Self\n\nConstructs a prefetch locality option.\n\nArgs:\n\n​value (Int): An integer value representing the locality. Should be a value in the range [0, 3].\n\nReturns:\n\nThe prefetch locality constructed.\n\nPrefetchRW\n\nPrefetch read or write.\n\nAliases:\n\n​READ = PrefetchRW(0): Read prefetch.\n​WRITE = PrefetchRW(1): Write prefetch.\n\nFields:\n\n​value (SIMD[si32, 1]): The read-write prefetch. It should be in [0, 1].\n\nFunctions:\n\n__init__\n\n__init__(value: Int) -> Self\n\nConstructs a prefetch read-write option.\n\nArgs:\n\n​value (Int): An integer value representing the prefetch read-write option to be used. Should be a value in the range [0, 1].\n\nReturns:\n\nThe prefetch read-write option constructed.\n\nPrefetchCache\n\nPrefetch cache type.\n\nAliases:\n\n​INSTRUCTION = PrefetchCache(0): The instruction prefetching option.\n​DATA = PrefetchCache(1): The data prefetching option.\n\nFields:\n\n​value (SIMD[si32, 1]): The cache prefetch. It should be in [0, 1].\n\nFunctions:\n\n__init__\n\n__init__(value: Int) -> Self\n\nConstructs a prefetch option.\n\nArgs:\n\n​value (Int): An integer value representing the prefetch cache option to be used. Should be a value in the range [0, 1].\n\nReturns:\n\nThe prefetch cache type that was constructed.\n\nPrefetchOptions\n\nCollection of configuration parameters for a prefetch intrinsic call.\n\nThe op configuration follows similar interface as LLVM intrinsic prefetch op, with a “locality” attribute that specifies the level of temporal locality in the application, that is, how soon would the same data be visited again. Possible locality values are: NONE, LOW, MEDIUM, and HIGH.\n\nThe op also takes a “cache tag” attribute giving hints on how the prefetched data will be used. Possible tags are: ReadICache, ReadDCache and WriteDCache.\n\nNote: the actual behavior of the prefetch op and concrete interpretation of these attributes are target-dependent.\n\nFields:\n\n​rw (PrefetchRW): Indicates prefetching for read or write.\n​locality (PrefetchLocality): Indicates locality level.\n​cache (PrefetchCache): Indicates i-cache or d-cache prefetching.\n\nFunctions:\n\n__init__\n\n__init__() -> Self\n\nConstructs an instance of PrefetchOptions with default params.\n\nReturns:\n\nThe Prefetch configuration constructed.\n\nfor_read\n\nfor_read(self: Self) -> Self\n\nSets the prefetch purpose to read.\n\nReturns:\n\nThe updated prefetch parameter.\n\nfor_write\n\nfor_write(self: Self) -> Self\n\nSets the prefetch purpose to write.\n\nReturns:\n\nThe updated prefetch parameter.\n\nno_locality\n\nno_locality(self: Self) -> Self\n\nSets the prefetch locality to none.\n\nReturns:\n\nThe updated prefetch parameter.\n\nlow_locality\n\nlow_locality(self: Self) -> Self\n\nSets the prefetch locality to low.\n\nReturns:\n\nThe updated prefetch parameter.\n\nmedium_locality\n\nmedium_locality(self: Self) -> Self\n\nSets the prefetch locality to medium.\n\nReturns:\n\nThe updated prefetch parameter.\n\nhigh_locality\n\nhigh_locality(self: Self) -> Self\n\nSets the prefetch locality to high.\n\nReturns:\n\nThe updated prefetch parameter.\n\nto_data_cache\n\nto_data_cache(self: Self) -> Self\n\nSets the prefetch target to data cache.\n\nReturns:\n\nThe updated prefetch parameter.\n\nto_instruction_cache\n\nto_instruction_cache(self: Self) -> Self\n\nSets the prefetch target to instruction cache.\n\nReturns:\n\nThe updated prefetch parameter.\n\nllvm_intrinsic\n\nllvm_intrinsic[intrin: StringLiteral, type: AnyRegType]() -> *\"type\"\n\nCalls an LLVM intrinsic with no arguments.\n\nCalls an LLVM intrinsic with the name intrin and return type type.\n\nParameters:\n\n​intrin (StringLiteral): The name of the llvm intrinsic.\n​type (AnyRegType): The return type of the intrinsic.\n\nReturns:\n\nThe result of calling the llvm intrinsic with no arguments.\n\nllvm_intrinsic[intrin: StringLiteral, type: AnyRegType, T0: AnyRegType](arg0: T0) -> *\"type\"\n\nCalls an LLVM intrinsic with one argument.\n\nCalls the intrinsic with the name intrin and return type type on argument arg0.\n\nParameters:\n\n​intrin (StringLiteral): The name of the llvm intrinsic.\n​type (AnyRegType): The return type of the intrinsic.\n​T0 (AnyRegType): The type of the first argument to the intrinsic (arg0).\n\nArgs:\n\n​arg0 (T0): The argument to call the LLVM intrinsic with. The type of arg0 must be T0.\n\nReturns:\n\nThe result of calling the llvm intrinsic with arg0 as an argument.\n\nllvm_intrinsic[intrin: StringLiteral, type: AnyRegType, T0: AnyRegType, T1: AnyRegType](arg0: T0, arg1: T1) -> *\"type\"\n\nCalls an LLVM intrinsic with two arguments.\n\nCalls the LLVM intrinsic with the name intrin and return type type on arguments arg0 and arg1.\n\nParameters:\n\n​intrin (StringLiteral): The name of the llvm intrinsic.\n​type (AnyRegType): The return type of the intrinsic.\n​T0 (AnyRegType): The type of the first argument to the intrinsic (arg0).\n​T1 (AnyRegType): The type of the second argument to the intrinsic (arg1).\n\nArgs:\n\n​arg0 (T0): The first argument to call the LLVM intrinsic with. The type of arg0 must be T0.\n​arg1 (T1): The second argument to call the LLVM intrinsic with. The type of arg1 must be T1.\n\nReturns:\n\nThe result of calling the llvm intrinsic with arg0 and arg1 as arguments.\n\nllvm_intrinsic[intrin: StringLiteral, type: AnyRegType, T0: AnyRegType, T1: AnyRegType, T2: AnyRegType](arg0: T0, arg1: T1, arg2: T2) -> *\"type\"\n\nCalls an LLVM intrinsic with three arguments.\n\nCalls the LLVM intrinsic with the name intrin and return type type on arguments arg0, arg1 and arg2.\n\nParameters:\n\n​intrin (StringLiteral): The name of the llvm intrinsic.\n​type (AnyRegType): The return type of the intrinsic.\n​T0 (AnyRegType): The type of the first argument to the intrinsic (arg0).\n​T1 (AnyRegType): The type of the second argument to the intrinsic (arg1).\n​T2 (AnyRegType): The type of the third argument to the intrinsic (arg2).\n\nArgs:\n\n​arg0 (T0): The first argument to call the LLVM intrinsic with. The type of arg0 must be T0.\n​arg1 (T1): The second argument to call the LLVM intrinsic with. The type of arg1 must be T1.\n​arg2 (T2): The third argument to call the LLVM intrinsic with. The type of arg2 must be T2.\n\nReturns:\n\nThe result of calling the llvm intrinsic with arg0, arg1 and arg2 as arguments.\n\nllvm_intrinsic[intrin: StringLiteral, type: AnyRegType, T0: AnyRegType, T1: AnyRegType, T2: AnyRegType, T3: AnyRegType](arg0: T0, arg1: T1, arg2: T2, arg3: T3) -> *\"type\"\n\nCalls an LLVM intrinsic with four arguments.\n\nCalls the LLVM intrinsic with the name intrin and return type type on arguments arg0, arg1, arg2 and arg3.\n\nParameters:\n\n​intrin (StringLiteral): The name of the llvm intrinsic.\n​type (AnyRegType): The return type of the intrinsic.\n​T0 (AnyRegType): The type of the first argument to the intrinsic (arg0).\n​T1 (AnyRegType): The type of the second argument to the intrinsic (arg1).\n​T2 (AnyRegType): The type of the third argument to the intrinsic (arg2).\n​T3 (AnyRegType): The type of the fourth argument to the intrinsic (arg3).\n\nArgs:\n\n​arg0 (T0): The first argument to call the LLVM intrinsic with. The type of arg0 must be T0.\n​arg1 (T1): The second argument to call the LLVM intrinsic with. The type of arg1 must be T1.\n​arg2 (T2): The third argument to call the LLVM intrinsic with. The type of arg2 must be T2.\n​arg3 (T3): The fourth argument to call the LLVM intrinsic with. The type of arg3 must be T3.\n\nReturns:\n\nThe result of calling the llvm intrinsic with arg0, arg1, arg2 and arg3 as arguments.\n\nllvm_intrinsic[intrin: StringLiteral, type: AnyRegType, T0: AnyRegType, T1: AnyRegType, T2: AnyRegType, T3: AnyRegType, T4: AnyRegType](arg0: T0, arg1: T1, arg2: T2, arg3: T3, arg4: T4) -> *\"type\"\n\nCalls an LLVM intrinsic with five arguments.\n\nCalls the LLVM intrinsic with the name intrin and return type type on arguments arg0, arg1, arg2, arg3 and arg4.\n\nParameters:\n\n​intrin (StringLiteral): The name of the llvm intrinsic.\n​type (AnyRegType): The return type of the intrinsic.\n​T0 (AnyRegType): The type of the first argument to the intrinsic (arg0).\n​T1 (AnyRegType): The type of the second argument to the intrinsic (arg1).\n​T2 (AnyRegType): The type of the third argument to the intrinsic (arg2).\n​T3 (AnyRegType): The type of the fourth argument to the intrinsic (arg3).\n​T4 (AnyRegType): The type of the fifth argument to the intrinsic (arg4).\n\nArgs:\n\n​arg0 (T0): The first argument to call the LLVM intrinsic with. The type of arg0 must be T0.\n​arg1 (T1): The second argument to call the LLVM intrinsic with. The type of arg1 must be T1.\n​arg2 (T2): The third argument to call the LLVM intrinsic with. The type of arg2 must be T2.\n​arg3 (T3): The fourth argument to call the LLVM intrinsic with. The type of arg3 must be T3.\n​arg4 (T4): The fourth argument to call the LLVM intrinsic with. The type of arg4 must be T4.\n\nReturns:\n\nThe result of calling the llvm intrinsic with arg0, arg1, arg2, arg3 and arg4 as arguments.\n\nexternal_call\n\nexternal_call[callee: StringLiteral, type: AnyRegType]() -> *\"type\"\n\nCalls an external function.\n\nParameters:\n\n​callee (StringLiteral): The name of the external function.\n​type (AnyRegType): The return type.\n\nReturns:\n\nThe external call result.\n\nexternal_call[callee: StringLiteral, type: AnyRegType, T0: AnyRegType](arg0: T0) -> *\"type\"\n\nCalls an external function.\n\nParameters:\n\n​callee (StringLiteral): The name of the external function.\n​type (AnyRegType): The return type.\n​T0 (AnyRegType): The first argument type.\n\nArgs:\n\n​arg0 (T0): The first argument.\n\nReturns:\n\nThe external call result.\n\nexternal_call[callee: StringLiteral, type: AnyRegType, T0: AnyRegType, T1: AnyRegType](arg0: T0, arg1: T1) -> *\"type\"\n\nCalls an external function.\n\nParameters:\n\n​callee (StringLiteral): The name of the external function.\n​type (AnyRegType): The return type.\n​T0 (AnyRegType): The first argument type.\n​T1 (AnyRegType): The second argument type.\n\nArgs:\n\n​arg0 (T0): The first argument.\n​arg1 (T1): The second argument.\n\nReturns:\n\nThe external call result.\n\nexternal_call[callee: StringLiteral, type: AnyRegType, T0: AnyRegType, T1: AnyRegType, T2: AnyRegType](arg0: T0, arg1: T1, arg2: T2) -> *\"type\"\n\nCalls an external function.\n\nParameters:\n\n​callee (StringLiteral): The name of the external function.\n​type (AnyRegType): The return type.\n​T0 (AnyRegType): The first argument type.\n​T1 (AnyRegType): The second argument type.\n​T2 (AnyRegType): The third argument type.\n\nArgs:\n\n​arg0 (T0): The first argument.\n​arg1 (T1): The second argument.\n​arg2 (T2): The third argument.\n\nReturns:\n\nThe external call result.\n\nexternal_call[callee: StringLiteral, type: AnyRegType, T0: AnyRegType, T1: AnyRegType, T2: AnyRegType, T3: AnyRegType](arg0: T0, arg1: T1, arg2: T2, arg3: T3) -> *\"type\"\n\nCalls an external function.\n\nParameters:\n\n​callee (StringLiteral): The name of the external function.\n​type (AnyRegType): The return type.\n​T0 (AnyRegType): The first argument type.\n​T1 (AnyRegType): The second argument type.\n​T2 (AnyRegType): The third argument type.\n​T3 (AnyRegType): The fourth argument type.\n\nArgs:\n\n​arg0 (T0): The first argument.\n​arg1 (T1): The second argument.\n​arg2 (T2): The third argument.\n​arg3 (T3): The fourth argument.\n\nReturns:\n\nThe external call result.\n\nexternal_call[callee: StringLiteral, type: AnyRegType, T0: AnyRegType, T1: AnyRegType, T2: AnyRegType, T3: AnyRegType, T4: AnyRegType](arg0: T0, arg1: T1, arg2: T2, arg3: T3, arg4: T4) -> *\"type\"\n\nCalls an external function.\n\nParameters:\n\n​callee (StringLiteral): The name of the external function.\n​type (AnyRegType): The return type.\n​T0 (AnyRegType): The first argument type.\n​T1 (AnyRegType): The second argument type.\n​T2 (AnyRegType): The third argument type.\n​T3 (AnyRegType): The fourth argument type.\n​T4 (AnyRegType): The fifth argument type.\n\nArgs:\n\n​arg0 (T0): The first argument.\n​arg1 (T1): The second argument.\n​arg2 (T2): The third argument.\n​arg3 (T3): The fourth argument.\n​arg4 (T4): The fifth argument.\n\nReturns:\n\nThe external call result.\n\ngather\n\ngather[type: DType, size: Int](base: SIMD[address, size], mask: SIMD[bool, size], passthrough: SIMD[type, size], alignment: Int) -> SIMD[type, size]\n\nReads scalar values from a SIMD vector, and gathers them into one vector.\n\nThe gather function reads scalar values from a SIMD vector of memory locations and gathers them into one vector. The memory locations are provided in the vector of pointers base as addresses. The memory is accessed according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes. The masked-off lanes in the result vector are taken from the corresponding lanes of the passthrough operand.\n\nIn general, for some vector of pointers base, mask mask, and passthrough pass a call of the form:\n\ngather(base, mask, pass)\n\nis equivalent to the following sequence of scalar loads in C++:\n\nfor (int i = 0; i < N; i++)\n  result[i] = mask[i] ? *base[i] : passthrough[i];\n\nParameters:\n\n​type (DType): DType of the return SIMD buffer.\n​size (Int): Size of the return SIMD buffer.\n\nArgs:\n\n​base (SIMD[address, size]): The vector containing memory addresses that gather will access.\n​mask (SIMD[bool, size]): A binary vector which prevents memory access to certain lanes of the base vector.\n​passthrough (SIMD[type, size]): In the result vector, the masked-off lanes are replaced with the passthrough vector.\n​alignment (Int): The alignment of the source addresses. Must be 0 or a power of two constant integer value.\n\nReturns:\n\nA SIMD[type, size] containing the result of the gather operation.\n\nscatter\n\nscatter[type: DType, size: Int](value: SIMD[type, size], base: SIMD[address, size], mask: SIMD[bool, size], alignment: Int)\n\nTakes scalar values from a SIMD vector and scatters them into a vector of pointers.\n\nThe scatter operation stores scalar values from a SIMD vector of memory locations and scatters them into a vector of pointers. The memory locations are provided in the vector of pointers base as addresses. The memory is stored according to the provided mask. The mask holds a bit for each vector lane, and is used to prevent memory accesses to the masked-off lanes.\n\nThe value operand is a vector value to be written to memory. The base operand is a vector of pointers, pointing to where the value elements should be stored. It has the same underlying type as the value operand. The mask operand, mask, is a vector of boolean values. The types of the mask and the value operand must have the same number of vector elements.\n\nThe behavior of the _scatter is undefined if the op stores into the same memory location more than once.\n\nIn general, for some vector %value, vector of pointers %base, and mask %mask instructions of the form:\n\n%0 = pop.simd.scatter %value, %base[%mask] : !pop.simd<N, type>\n\nis equivalent to the following sequence of scalar loads in C++:\n\nfor (int i = 0; i < N; i++)\n  if (mask[i])\n    base[i] = value[i];\n\nParameters:\n\n​type (DType): DType of value, the result SIMD buffer.\n​size (Int): Size of value, the result SIMD buffer.\n\nArgs:\n\n​value (SIMD[type, size]): The vector that will contain the result of the scatter operation.\n​base (SIMD[address, size]): The vector containing memory addresses that scatter will access.\n​mask (SIMD[bool, size]): A binary vector which prevents memory access to certain lanes of the base vector.\n​alignment (Int): The alignment of the source addresses. Must be 0 or a power of two constant integer value.\nprefetch\n\nprefetch[params: PrefetchOptions, type: DType, address_space: AddressSpace](addr: DTypePointer[type, address_space])\n\nPrefetches an instruction or data into cache before it is used.\n\nThe prefetch function provides prefetching hints for the target to prefetch instruction or data into cache before they are used.\n\nParameters:\n\n​params (PrefetchOptions): Configuration options for the prefect intrinsic.\n​type (DType): The DType of value stored in addr.\n​address_space (AddressSpace): The address space of the pointer.\n\nArgs:\n\n​addr (DTypePointer[type, address_space]): The data pointer to prefetch.\nmasked_load\n\nmasked_load[type: DType, size: Int](addr: DTypePointer[type, 0], mask: SIMD[bool, size], passthrough: SIMD[type, size], alignment: Int) -> SIMD[type, size]\n\nLoads data from memory and return it, replacing masked lanes with values from the passthrough vector.\n\nParameters:\n\n​type (DType): DType of the return SIMD buffer.\n​size (Int): Size of the return SIMD buffer.\n\nArgs:\n\n​addr (DTypePointer[type, 0]): The base pointer for the load.\n​mask (SIMD[bool, size]): A binary vector which prevents memory access to certain lanes of the memory stored at addr.\n​passthrough (SIMD[type, size]): In the result vector, the masked-off lanes are replaced with the passthrough vector.\n​alignment (Int): The alignment of the source addresses. Must be 0 or a power of two constant integer value. Default is 1.\n\nReturns:\n\nThe loaded memory stored in a vector of type SIMD[type, size].\n\nmasked_store\n\nmasked_store[type: DType, size: Int](value: SIMD[type, size], addr: DTypePointer[type, 0], mask: SIMD[bool, size], alignment: Int)\n\nStores a value at a memory location, skipping masked lanes.\n\nParameters:\n\n​type (DType): DType of value, the data to store.\n​size (Int): Size of value, the data to store.\n\nArgs:\n\n​value (SIMD[type, size]): The vector containing data to store.\n​addr (DTypePointer[type, 0]): A vector of memory location to store data at.\n​mask (SIMD[bool, size]): A binary vector which prevents memory access to certain lanes of value.\n​alignment (Int): The alignment of the destination locations. Must be 0 or a power of two constant integer value.\ncompressed_store\n\ncompressed_store[type: DType, size: Int](value: SIMD[type, size], addr: DTypePointer[type, 0], mask: SIMD[bool, size])\n\nCompresses the lanes of value, skipping mask lanes, and stores at addr.\n\nParameters:\n\n​type (DType): DType of value, the value to store.\n​size (Int): Size of value, the value to store.\n\nArgs:\n\n​value (SIMD[type, size]): The vector containing data to store.\n​addr (DTypePointer[type, 0]): The memory location to store the compressed data.\n​mask (SIMD[bool, size]): A binary vector which prevents memory access to certain lanes of value.\nstrided_load\n\nstrided_load[type: DType, simd_width: Int, address_space: AddressSpace](addr: DTypePointer[type, address_space], stride: Int, mask: SIMD[bool, simd_width]) -> SIMD[type, simd_width]\n\nLoads values from addr according to a specific stride.\n\nParameters:\n\n​type (DType): DType of value, the value to store.\n​simd_width (Int): The width of the SIMD vectors.\n​address_space (AddressSpace): The address space of the memory location.\n\nArgs:\n\n​addr (DTypePointer[type, address_space]): The memory location to load data from.\n​stride (Int): How many lanes to skip before loading again.\n​mask (SIMD[bool, simd_width]): A binary vector which prevents memory access to certain lanes of value.\n\nReturns:\n\nA vector containing the loaded data.\n\nstrided_load[type: DType, simd_width: Int, address_space: AddressSpace](addr: DTypePointer[type, address_space], stride: Int) -> SIMD[type, simd_width]\n\nLoads values from addr according to a specific stride.\n\nParameters:\n\n​type (DType): DType of value, the value to store.\n​simd_width (Int): The width of the SIMD vectors.\n​address_space (AddressSpace): The address space of the memory location.\n\nArgs:\n\n​addr (DTypePointer[type, address_space]): The memory location to load data from.\n​stride (Int): How many lanes to skip before loading again.\n\nReturns:\n\nA vector containing the loaded data.\n\nstrided_store\n\nstrided_store[type: DType, simd_width: Int, address_space: AddressSpace](value: SIMD[type, simd_width], addr: DTypePointer[type, address_space], stride: Int, mask: SIMD[bool, simd_width])\n\nLoads values from addr according to a specific stride.\n\nParameters:\n\n​type (DType): DType of value, the value to store.\n​simd_width (Int): The width of the SIMD vectors.\n​address_space (AddressSpace): The address space of the memory location.\n\nArgs:\n\n​value (SIMD[type, simd_width]): The values to store.\n​addr (DTypePointer[type, address_space]): The location to store values at.\n​stride (Int): How many lanes to skip before storing again.\n​mask (SIMD[bool, simd_width]): A binary vector which prevents memory access to certain lanes of value.\n\nstrided_store[type: DType, simd_width: Int](value: SIMD[type, simd_width], addr: DTypePointer[type, 0], stride: Int)\n\nLoads values from addr according to a specific stride.\n\nParameters:\n\n​type (DType): DType of value, the value to store.\n​simd_width (Int): The width of the SIMD vectors.\n\nArgs:\n\n​value (SIMD[type, simd_width]): The values to store.\n​addr (DTypePointer[type, 0]): The location to store values at.\n​stride (Int): How many lanes to skip before storing again.\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - info",
    "url": "https://docs.modular.com/mojo/stdlib/sys/info.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\narg\ninfo\nintrinsics\nparam_env\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nis_x86\nhas_sse4\nhas_avx\nhas_avx2\nhas_avx512f\nhas_vnni\nhas_neon\nhas_neon_int8_dotprod\nhas_neon_int8_matmul\nis_apple_m1\nis_neoverse_n1\nhas_intel_amx\nos_is_macos\nos_is_linux\nos_is_windows\nis_triple\ntriple_is_nvidia_cuda\nis_little_endian\nis_big_endian\nsimdbitwidth\nsimdbytewidth\nsizeof\nalignof\nbitwidthof\nsimdwidthof\ninfo\n\nModule\n\nImplements methods for querying the host target info.\n\nYou can import these APIs from the sys package. For example:\n\nfrom sys.info import is_x86\nis_x86\n\nis_x86() -> Bool\n\nReturns True if the host system architecture is X86 and False otherwise.\n\nReturns:\n\nTrue if the host system architecture is X86 and False otherwise.\n\nhas_sse4\n\nhas_sse4() -> Bool\n\nReturns True if the host system has sse4, otherwise returns False.\n\nReturns:\n\nTrue if the host system has sse4, otherwise returns False.\n\nhas_avx\n\nhas_avx() -> Bool\n\nReturns True if the host system has AVX, otherwise returns False.\n\nReturns:\n\nTrue if the host system has AVX, otherwise returns False.\n\nhas_avx2\n\nhas_avx2() -> Bool\n\nReturns True if the host system has AVX2, otherwise returns False.\n\nReturns:\n\nTrue if the host system has AVX2, otherwise returns False.\n\nhas_avx512f\n\nhas_avx512f() -> Bool\n\nReturns True if the host system has AVX512, otherwise returns False.\n\nReturns:\n\nTrue if the host system has AVX512, otherwise returns False.\n\nhas_vnni\n\nhas_vnni() -> Bool\n\nReturns True if the host system has avx512_vnni, otherwise returns False.\n\nReturns:\n\nTrue if the host system has avx512_vnni, otherwise returns False.\n\nhas_neon\n\nhas_neon() -> Bool\n\nReturns True if the host system has Neon support, otherwise returns False.\n\nReturns:\n\nTrue if the host system support the Neon instruction set.\n\nhas_neon_int8_dotprod\n\nhas_neon_int8_dotprod() -> Bool\n\nReturns True if the host system has the Neon int8 dot product extension, otherwise returns False.\n\nReturns:\n\nTrue if the host system support the Neon int8 dot product extension and False otherwise.\n\nhas_neon_int8_matmul\n\nhas_neon_int8_matmul() -> Bool\n\nReturns True if the host system has the Neon int8 matrix multiplication extension (I8MM), otherwise returns False.\n\nReturns:\n\nTrue if the host system support the Neon int8 matrix multiplication extension (I8MM) and False otherwise.\n\nis_apple_m1\n\nis_apple_m1() -> Bool\n\nReturns True if the host system is an Apple M1 with AMX support, otherwise returns False.\n\nReturns:\n\nTrue if the host system is an Apple M1 with AMX support and False otherwise.\n\nis_neoverse_n1\n\nis_neoverse_n1() -> Bool\n\nReturns True if the host system is a Neoverse N1 system, otherwise returns False.\n\nReturns:\n\nTrue if the host system is a Neoverse N1 system and False otherwise.\n\nhas_intel_amx\n\nhas_intel_amx() -> Bool\n\nReturns True if the host system has Intel AMX support, otherwise returns False.\n\nReturns:\n\nTrue if the host system has Intel AMX and False otherwise.\n\nos_is_macos\n\nos_is_macos() -> Bool\n\nReturns True if the host operating system is macOS.\n\nReturns:\n\nTrue if the host operating system is macOS and False otherwise.\n\nos_is_linux\n\nos_is_linux() -> Bool\n\nReturns True if the host operating system is Linux.\n\nReturns:\n\nTrue if the host operating system is Linux and False otherwise.\n\nos_is_windows\n\nos_is_windows() -> Bool\n\nReturns True if the host operating system is Windows.\n\nReturns:\n\nTrue if the host operating system is Windows and False otherwise.\n\nis_triple\n\nis_triple[triple: StringLiteral]() -> Bool\n\nReturns True if the target triple of the compiler matches the input and False otherwise.\n\nParameters:\n\n​triple (StringLiteral): The triple value to be checked against.\n\nReturns:\n\nTrue if the triple matches and False otherwise.\n\ntriple_is_nvidia_cuda\n\ntriple_is_nvidia_cuda() -> Bool\n\nReturns True if the target triple of the compiler is nvptx64-nvidia-cuda False otherwise.\n\nReturns:\n\nTrue if the triple target is cuda and False otherwise.\n\nis_little_endian\n\nis_little_endian[target: target]() -> Bool\n\nReturns True if the host endianness is little and False otherwise.\n\nParameters:\n\n​target (target): The target architecture.\n\nReturns:\n\nTrue if the host target is little endian and False otherwise.\n\nis_big_endian\n\nis_big_endian[target: target]() -> Bool\n\nReturns True if the host endianness is big and False otherwise.\n\nParameters:\n\n​target (target): The target architecture.\n\nReturns:\n\nTrue if the host target is big endian and False otherwise.\n\nsimdbitwidth\n\nsimdbitwidth[target: target]() -> Int\n\nReturns the vector size (in bits) of the host system.\n\nParameters:\n\n​target (target): The target architecture.\n\nReturns:\n\nThe vector size (in bits) of the host system.\n\nsimdbytewidth\n\nsimdbytewidth[target: target]() -> Int\n\nReturns the vector size (in bytes) of the host system.\n\nParameters:\n\n​target (target): The target architecture.\n\nReturns:\n\nThe vector size (in bytes) of the host system.\n\nsizeof\n\nsizeof[type: AnyTypeType, target: target]() -> Int\n\nReturns the size of (in bytes) of the type.\n\nParameters:\n\n​type (AnyTypeType): The type in question.\n​target (target): The target architecture.\n\nReturns:\n\nThe size of the type in bytes.\n\nsizeof[type: DType, target: target]() -> Int\n\nReturns the size of (in bytes) of the dtype.\n\nParameters:\n\n​type (DType): The DType in question.\n​target (target): The target architecture.\n\nReturns:\n\nThe size of the dtype in bytes.\n\nalignof\n\nalignof[type: AnyTypeType, target: target]() -> Int\n\nReturns the align of (in bytes) of the type.\n\nParameters:\n\n​type (AnyTypeType): The type in question.\n​target (target): The target architecture.\n\nReturns:\n\nThe alignment of the type in bytes.\n\nalignof[type: DType, target: target]() -> Int\n\nReturns the align of (in bytes) of the dtype.\n\nParameters:\n\n​type (DType): The DType in question.\n​target (target): The target architecture.\n\nReturns:\n\nThe alignment of the dtype in bytes.\n\nbitwidthof\n\nbitwidthof[type: AnyRegType, target: target]() -> Int\n\nReturns the size of (in bits) of the type.\n\nParameters:\n\n​type (AnyRegType): The type in question.\n​target (target): The target architecture.\n\nReturns:\n\nThe size of the type in bits.\n\nbitwidthof[type: DType, target: target]() -> Int\n\nReturns the size of (in bits) of the dtype.\n\nParameters:\n\n​type (DType): The type in question.\n​target (target): The target architecture.\n\nReturns:\n\nThe size of the dtype in bits.\n\nsimdwidthof\n\nsimdwidthof[type: AnyRegType, target: target]() -> Int\n\nReturns the vector size of the type on the host system.\n\nParameters:\n\n​type (AnyRegType): The type in question.\n​target (target): The target architecture.\n\nReturns:\n\nThe vector size of the type on the host system.\n\nsimdwidthof[type: DType, target: target]() -> Int\n\nReturns the vector size of the type on the host system.\n\nParameters:\n\n​type (DType): The DType in question.\n​target (target): The target architecture.\n\nReturns:\n\nThe vector size of the dtype on the host system.\n\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - arg",
    "url": "https://docs.modular.com/mojo/stdlib/sys/arg.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\narg\ninfo\nintrinsics\nparam_env\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nargv\narg\n\nModule\n\nImplements functions and variables for interacting with execution and system environment.\n\nYou can import these APIs from the sys package. For example:\n\nfrom sys import argv\nargv\n\nargv() -> VariadicList[StringRef]\n\nThe list of command line arguments.\n\nReturns:\n\nThe list of command line arguments provided when mojo was invoked.\n\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - random",
    "url": "https://docs.modular.com/mojo/stdlib/random/random.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nseed\nrandom_float64\nrandom_si64\nrandom_ui64\nrandint\nrand\nrandn_float64\nrandn\nrandom\n\nModule\n\nProvides functions for random numbers.\n\nYou can import these APIs from the random package. For example:\n\nfrom random import seed\nseed\n\nseed()\n\nSeeds the random number generator using the current time.\n\nseed(a: Int)\n\nSeeds the random number generator using the value provided.\n\nArgs:\n\n​a (Int): The seed value.\nrandom_float64\n\nrandom_float64(min: SIMD[f64, 1], max: SIMD[f64, 1]) -> SIMD[f64, 1]\n\nReturns a random Float64 number from the given range.\n\nArgs:\n\n​min (SIMD[f64, 1]): The minimum number in the range (default is 0.0).\n​max (SIMD[f64, 1]): The maximum number in the range (default is 1.0).\n\nReturns:\n\nA random number from the specified range.\n\nrandom_si64\n\nrandom_si64(min: SIMD[si64, 1], max: SIMD[si64, 1]) -> SIMD[si64, 1]\n\nReturns a random Int64 number from the given range.\n\nArgs:\n\n​min (SIMD[si64, 1]): The minimum number in the range.\n​max (SIMD[si64, 1]): The maximum number in the range.\n\nReturns:\n\nA random number from the specified range.\n\nrandom_ui64\n\nrandom_ui64(min: SIMD[ui64, 1], max: SIMD[ui64, 1]) -> SIMD[ui64, 1]\n\nReturns a random UInt64 number from the given range.\n\nArgs:\n\n​min (SIMD[ui64, 1]): The minimum number in the range.\n​max (SIMD[ui64, 1]): The maximum number in the range.\n\nReturns:\n\nA random number from the specified range.\n\nrandint\n\nrandint[type: DType](ptr: DTypePointer[type, 0], size: Int, low: Int, high: Int)\n\nFills memory with uniform random in range [low, high].\n\nConstraints:\n\nThe type should be integral.\n\nParameters:\n\n​type (DType): The dtype of the pointer.\n\nArgs:\n\n​ptr (DTypePointer[type, 0]): The pointer to the memory area to fill.\n​size (Int): The number of elements to fill.\n​low (Int): The minimal value for random.\n​high (Int): The maximal value for random.\nrand\n\nrand[type: DType](ptr: DTypePointer[type, 0], size: Int)\n\nFills memory with random values from a uniform distribution.\n\nParameters:\n\n​type (DType): The dtype of the pointer.\n\nArgs:\n\n​ptr (DTypePointer[type, 0]): The pointer to the memory area to fill.\n​size (Int): The number of elements to fill.\n\nrand[type: DType](*shape: Int) -> Tensor[type]\n\nConstructs a new tensor with the specified shape and fills it with random elements.\n\nParameters:\n\n​type (DType): The dtype of the tensor.\n\nArgs:\n\n​shape (*Int): The tensor shape.\n\nReturns:\n\nA new tensor of specified shape and filled with random elements.\n\nrand[type: DType](owned shape: TensorShape) -> Tensor[type]\n\nConstructs a new tensor with the specified shape and fills it with random elements.\n\nParameters:\n\n​type (DType): The dtype of the tensor.\n\nArgs:\n\n​shape (TensorShape): The tensor shape.\n\nReturns:\n\nA new tensor of specified shape and filled with random elements.\n\nrand[type: DType](owned spec: TensorSpec) -> Tensor[type]\n\nConstructs a new tensor with the specified specification and fills it with random elements.\n\nParameters:\n\n​type (DType): The dtype of the tensor.\n\nArgs:\n\n​spec (TensorSpec): The tensor specification.\n\nReturns:\n\nA new tensor of specified specification and filled with random elements.\n\nrandn_float64\n\nrandn_float64(mean: SIMD[f64, 1], variance: SIMD[f64, 1]) -> SIMD[f64, 1]\n\nReturns a random double sampled from Normal(mean, variance) distribution.\n\nArgs:\n\n​mean (SIMD[f64, 1]): Normal distribution mean.\n​variance (SIMD[f64, 1]): Normal distribution variance.\n\nReturns:\n\nA random float64 sampled from Normal(mean, variance).\n\nrandn\n\nrandn[type: DType](ptr: DTypePointer[type, 0], size: Int, mean: SIMD[f64, 1], variance: SIMD[f64, 1])\n\nFills memory with random values from a Normal(mean, variance) distribution.\n\nConstraints:\n\nThe type should be floating point.\n\nParameters:\n\n​type (DType): The dtype of the pointer.\n\nArgs:\n\n​ptr (DTypePointer[type, 0]): The pointer to the memory area to fill.\n​size (Int): The number of elements to fill.\n​mean (SIMD[f64, 1]): Normal distribution mean.\n​variance (SIMD[f64, 1]): Normal distribution variance.\n\nrandn[type: DType](owned shape: TensorShape, mean: SIMD[f64, 1], variance: SIMD[f64, 1]) -> Tensor[type]\n\nConstructs a new Tensor from the shape and fills it with random values from a Normal(mean, variance) distribution.\n\nConstraints:\n\nThe type should be floating point.\n\nParameters:\n\n​type (DType): The dtype of the pointer.\n\nArgs:\n\n​shape (TensorShape): The shape of the Tensor to fill with random values.\n​mean (SIMD[f64, 1]): Normal distribution mean.\n​variance (SIMD[f64, 1]): Normal distribution variance.\n\nReturns:\n\nA Tensor filled with random dtype samples from Normal(mean, variance).\n\nrandn[type: DType](owned spec: TensorSpec, mean: SIMD[f64, 1], variance: SIMD[f64, 1]) -> Tensor[type]\n\nConstructs a new Tensor from the spec and fills it with random values from a Normal(mean, variance) distribution.\n\nConstraints:\n\nThe type should be floating point.\n\nParameters:\n\n​type (DType): The dtype of the pointer.\n\nArgs:\n\n​spec (TensorSpec): The spec of the Tensor to fill with random values.\n​mean (SIMD[f64, 1]): Normal distribution mean.\n​variance (SIMD[f64, 1]): Normal distribution variance.\n\nReturns:\n\nA Tensor filled with random dtype samples from Normal(mean, variance).\n\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - python",
    "url": "https://docs.modular.com/mojo/stdlib/python/python.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nmemory\nos\npathlib\npython\nobject\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nPython\n__init__\n__copyinit__\neval\nevaluate\nadd_to_path\nimport_module\ndict\n__str__\nthrow_python_exception_if_error_state\nis_type\ntype\nnone\npython\n\nModule\n\nImplements Python interoperability.\n\nYou can import these APIs from the python package. For example:\n\nfrom python import Python\nPython\n\nProvides methods that help you use Python code in Mojo.\n\nFields:\n\n​impl (_PythonInterfaceImpl): The underlying implementation of Mojo’s Python interface.\n\nFunctions:\n\n__init__\n\n__init__(inout self: Self)\n\nDefault constructor.\n\n__copyinit__\n\n__copyinit__(inout self: Self, existing: Self)\n\nCopy constructor.\n\nArgs:\n\n​existing (Self): The existing instance to copy from.\neval\n\neval(inout self: Self, str: StringRef) -> Bool\n\nExecutes the given Python code.\n\nArgs:\n\n​str (StringRef): The python code to execute.\n\nReturns:\n\nTrue if the code executed successfully or False if the code raised an exception.\n\nevaluate\n\nstatic evaluate(str: StringRef) -> PythonObject\n\nExecutes the given Python code.\n\nArgs:\n\n​str (StringRef): The Python expression to evaluate.\n\nReturns:\n\nPythonObject containing the result of the evaluation.\n\nadd_to_path\n\nstatic add_to_path(str: StringRef)\n\nAdds a directory to the Python path.\n\nThis might be necessary to import a Python module via import_module(). For example:\n\nfrom python import Python\n\n# Specify path to `mypython.py` module\nPython.add_to_path(\"path/to/module\")\nlet mypython = Python.import_module(\"mypython\")\n\nlet c = mypython.my_algorithm(2, 3)\n\nArgs:\n\n​str (StringRef): The path to a Python module you want to import.\nimport_module\n\nstatic import_module(str: StringRef) -> PythonObject\n\nImports a Python module.\n\nThis provides you with a module object you can use just like you would in Python. For example:\n\nfrom python import Python\n\n# This is equivalent to Python's `import numpy as np`\nlet np = Python.import_module(\"numpy\")\na = np.array([1, 2, 3])\n\nArgs:\n\n​str (StringRef): The Python module name. This module must be visible from the list of available Python paths (you might need to add the module’s path with add_to_path()).\n\nReturns:\n\nThe Python module.\n\ndict\n\nstatic dict() -> Dictionary\n\nConstruct an empty Python dictionary.\n\nReturns:\n\nThe constructed empty Python dictionary.\n\n__str__\n\n__str__(inout self: Self, str: PythonObject) -> StringRef\n\nReturn a string representing the given Python object.\n\nThis function allows to convert Python objects to Mojo string type.\n\nReturns:\n\nMojo string representing the given Python object.\n\nthrow_python_exception_if_error_state\n\nstatic throw_python_exception_if_error_state(inout cpython: CPython)\n\nRaise an exception if CPython interpreter is in an error state.\n\nArgs:\n\n​cpython (CPython): The cpython instance we wish to error check.\nis_type\n\nstatic is_type(x: PythonObject, y: PythonObject) -> Bool\n\nTest if the x object is the y object, the same as x is y in Python.\n\nArgs:\n\n​x (PythonObject): The left-hand-side value in the comparison.\n​y (PythonObject): The right-hand-side type value in the comparison.\n\nReturns:\n\nTrue if x and y are the same object and False otherwise.\n\ntype\n\nstatic type(obj: PythonObject) -> PythonObject\n\nReturn Type of this PythonObject.\n\nArgs:\n\n​obj (PythonObject): PythonObject we want the type of.\n\nReturns:\n\nA PythonObject that holds the type object.\n\nnone\n\nstatic none() -> PythonObject\n\nGet a PythonObject representing None.\n\nReturns:\n\nPythonObject representing None.\n\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - object",
    "url": "https://docs.modular.com/mojo/stdlib/python/object.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nmemory\nos\npathlib\npython\nobject\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nPythonObject\n__init__\n__copyinit__\n__del__\n__bool__\n__getitem__\n__neg__\n__pos__\n__invert__\n__lt__\n__le__\n__eq__\n__ne__\n__gt__\n__ge__\n__add__\n__sub__\n__mul__\n__truediv__\n__floordiv__\n__mod__\n__pow__\n__lshift__\n__rshift__\n__and__\n__or__\n__xor__\n__radd__\n__rsub__\n__rmul__\n__rtruediv__\n__rfloordiv__\n__rmod__\n__rpow__\n__rlshift__\n__rrshift__\n__rand__\n__ror__\n__rxor__\n__iadd__\n__isub__\n__imul__\n__itruediv__\n__ifloordiv__\n__imod__\n__ipow__\n__ilshift__\n__irshift__\n__iand__\n__ixor__\n__ior__\n__iter__\n__getattr__\n__setattr__\n__call__\nto_float64\n__index__\n__int__\n__str__\nobject\n\nModule\n\nImplements PythonObject.\n\nYou can import these APIs from the python package. For example:\n\nfrom python.object import PythonObject\nPythonObject\n\nA Python object.\n\nFields:\n\n​py_object (PyObjectPtr): A pointer to the underlying Python object.\n\nFunctions:\n\n__init__\n\n__init__(inout self: Self)\n\nInitialize the object with a None value.\n\n__init__(inout self: Self, none: None)\n\nInitialize a none value object from a None literal.\n\nArgs:\n\n​none (None): None.\n\n__init__(inout self: Self, integer: Int)\n\nInitialize the object with an integer value.\n\nArgs:\n\n​integer (Int): The integer value.\n\n__init__(inout self: Self, float: FloatLiteral)\n\nInitialize the object with an floating-point value.\n\nArgs:\n\n​float (FloatLiteral): The float value.\n\n__init__[dt: DType](inout self: Self, value: SIMD[dt, 1])\n\nInitialize the object with a generic scalar value. If the scalar value type is bool, it is converted to a boolean. Otherwise, it is converted to the appropriate integer or floating point type.\n\nParameters:\n\n​dt (DType): The scalar value type.\n\nArgs:\n\n​value (SIMD[dt, 1]): The scalar value.\n\n__init__(inout self: Self, value: Bool)\n\nInitialize the object from a bool.\n\nArgs:\n\n​value (Bool): The boolean value.\n\n__init__(inout self: Self, str: StringLiteral)\n\nInitialize the object from a string literal.\n\nArgs:\n\n​str (StringLiteral): The string value.\n\n__init__(inout self: Self, str: StringRef)\n\nInitialize the object from a string reference.\n\nArgs:\n\n​str (StringRef): The string value.\n\n__init__(inout self: Self, str: String)\n\nInitialize the object from a string.\n\nArgs:\n\n​str (String): The string value.\n\n__init__[*Ts: AnyRegType](inout self: Self, value: ListLiteral[Ts])\n\nInitialize the object from a list literal.\n\nParameters:\n\n​Ts (*AnyRegType): The list element types.\n\nArgs:\n\n​value (ListLiteral[Ts]): The list value.\n\n__init__[*Ts: AnyRegType](inout self: Self, value: Tuple[Ts])\n\nInitialize the object from a tuple literal.\n\nParameters:\n\n​Ts (*AnyRegType): The tuple element types.\n\nArgs:\n\n​value (Tuple[Ts]): The tuple value.\n__copyinit__\n\n__copyinit__(inout self: Self, existing: Self)\n\nCopy the object.\n\nThis increments the underlying refcount of the existing object.\n\nArgs:\n\n​existing (Self): The value to copy.\n__del__\n\n__del__(owned self: Self)\n\nDestroy the object.\n\nThis decrements the underlying refcount of the pointed-to object.\n\n__bool__\n\n__bool__(self: Self) -> Bool\n\nEvaluate the boolean value of the object.\n\nReturns:\n\nWhether the object evaluates as true.\n\n__getitem__\n\n__getitem__(self: Self, *args: Self) -> Self\n\nReturn the value for the given key or keys.\n\nArgs:\n\n​args (*Self): The key or keys to access on this object.\n\nReturns:\n\nThe value corresponding to the given key for this object.\n\n__neg__\n\n__neg__(self: Self) -> Self\n\nNegative.\n\nCalls the underlying object’s __neg__ method.\n\nReturns:\n\nThe result of prefixing this object with a - operator. For most numerical objects, this returns the negative.\n\n__pos__\n\n__pos__(self: Self) -> Self\n\nPositive.\n\nCalls the underlying object’s __pos__ method.\n\nReturns:\n\nThe result of prefixing this object with a + operator. For most numerical objects, this does nothing.\n\n__invert__\n\n__invert__(self: Self) -> Self\n\nInversion.\n\nCalls the underlying object’s __invert__ method.\n\nReturns:\n\nThe logical inverse of this object: a bitwise representation where all bits are flipped, from zero to one, and from one to zero.\n\n__lt__\n\n__lt__(self: Self, rhs: Self) -> Self\n\nLess than comparator. This lexicographically compares strings and lists.\n\nArgs:\n\n​rhs (Self): Right hand value.\n\nReturns:\n\nTrue if the object is less than the right hard argument.\n\n__le__\n\n__le__(self: Self, rhs: Self) -> Self\n\nLess than or equal to comparator. This lexicographically compares strings and lists.\n\nArgs:\n\n​rhs (Self): Right hand value.\n\nReturns:\n\nTrue if the object is less than or equal to the right hard argument.\n\n__eq__\n\n__eq__(self: Self, rhs: Self) -> Self\n\nEquality comparator. This compares the elements of strings and lists.\n\nArgs:\n\n​rhs (Self): Right hand value.\n\nReturns:\n\nTrue if the objects are equal.\n\n__ne__\n\n__ne__(self: Self, rhs: Self) -> Self\n\nInequality comparator. This compares the elements of strings and lists.\n\nArgs:\n\n​rhs (Self): Right hand value.\n\nReturns:\n\nTrue if the objects are not equal.\n\n__gt__\n\n__gt__(self: Self, rhs: Self) -> Self\n\nGreater than comparator. This lexicographically compares the elements of strings and lists.\n\nArgs:\n\n​rhs (Self): Right hand value.\n\nReturns:\n\nTrue if the left hand value is greater.\n\n__ge__\n\n__ge__(self: Self, rhs: Self) -> Self\n\nGreater than or equal to comparator. This lexicographically compares the elements of strings and lists.\n\nArgs:\n\n​rhs (Self): Right hand value.\n\nReturns:\n\nTrue if the left hand value is greater than or equal to the right hand value.\n\n__add__\n\n__add__(self: Self, rhs: Self) -> Self\n\nAddition and concatenation.\n\nCalls the underlying object’s __add__ method.\n\nArgs:\n\n​rhs (Self): Right hand value.\n\nReturns:\n\nThe sum or concatenated values.\n\n__sub__\n\n__sub__(self: Self, rhs: Self) -> Self\n\nSubtraction.\n\nCalls the underlying object’s __sub__ method.\n\nArgs:\n\n​rhs (Self): Right hand value.\n\nReturns:\n\nThe difference.\n\n__mul__\n\n__mul__(self: Self, rhs: Self) -> Self\n\nMultiplication.\n\nCalls the underlying object’s __mul__ method.\n\nArgs:\n\n​rhs (Self): Right hand value.\n\nReturns:\n\nThe product.\n\n__truediv__\n\n__truediv__(self: Self, rhs: Self) -> Self\n\nDivision.\n\nCalls the underlying object’s __truediv__ method.\n\nArgs:\n\n​rhs (Self): The right-hand-side value by which this object is divided.\n\nReturns:\n\nThe result of dividing the right-hand-side value by this.\n\n__floordiv__\n\n__floordiv__(self: Self, rhs: Self) -> Self\n\nReturn the division of self and rhs rounded down to the nearest integer.\n\nCalls the underlying object’s __floordiv__ method.\n\nArgs:\n\n​rhs (Self): The right-hand-side value by which this object is divided.\n\nReturns:\n\nThe result of dividing this by the right-hand-side value, modulo any remainder.\n\n__mod__\n\n__mod__(self: Self, rhs: Self) -> Self\n\nReturn the remainder of self divided by rhs.\n\nCalls the underlying object’s __mod__ method.\n\nArgs:\n\n​rhs (Self): The value to divide on.\n\nReturns:\n\nThe remainder of dividing self by rhs.\n\n__pow__\n\n__pow__(self: Self, rhs: Self) -> Self\n\nRaises this object to the power of the given value.\n\nArgs:\n\n​rhs (Self): The exponent.\n\nReturns:\n\nThe result of raising this by the given exponent.\n\n__lshift__\n\n__lshift__(self: Self, rhs: Self) -> Self\n\nBitwise left shift.\n\nArgs:\n\n​rhs (Self): The right-hand-side value by which this object is bitwise shifted to the left.\n\nReturns:\n\nThis value, shifted left by the given value.\n\n__rshift__\n\n__rshift__(self: Self, rhs: Self) -> Self\n\nBitwise right shift.\n\nArgs:\n\n​rhs (Self): The right-hand-side value by which this object is bitwise shifted to the right.\n\nReturns:\n\nThis value, shifted right by the given value.\n\n__and__\n\n__and__(self: Self, rhs: Self) -> Self\n\nBitwise AND.\n\nArgs:\n\n​rhs (Self): The right-hand-side value with which this object is bitwise AND’ed.\n\nReturns:\n\nThe bitwise AND result of this and the given value.\n\n__or__\n\n__or__(self: Self, rhs: Self) -> Self\n\nBitwise OR.\n\nArgs:\n\n​rhs (Self): The right-hand-side value with which this object is bitwise OR’ed.\n\nReturns:\n\nThe bitwise OR result of this and the given value.\n\n__xor__\n\n__xor__(self: Self, rhs: Self) -> Self\n\nExclusive OR.\n\nArgs:\n\n​rhs (Self): The right-hand-side value with which this object is exclusive OR’ed.\n\nReturns:\n\nThe exclusive OR result of this and the given value.\n\n__radd__\n\n__radd__(self: Self, lhs: Self) -> Self\n\nReverse addition and concatenation.\n\nCalls the underlying object’s __radd__ method.\n\nArgs:\n\n​lhs (Self): The left-hand-side value to which this object is added or concatenated.\n\nReturns:\n\nThe sum.\n\n__rsub__\n\n__rsub__(self: Self, lhs: Self) -> Self\n\nReverse subtraction.\n\nCalls the underlying object’s __rsub__ method.\n\nArgs:\n\n​lhs (Self): The left-hand-side value from which this object is subtracted.\n\nReturns:\n\nThe result of subtracting this from the given value.\n\n__rmul__\n\n__rmul__(self: Self, lhs: Self) -> Self\n\nReverse multiplication.\n\nCalls the underlying object’s __rmul__ method.\n\nArgs:\n\n​lhs (Self): The left-hand-side value that is multiplied by this object.\n\nReturns:\n\nThe product of the multiplication.\n\n__rtruediv__\n\n__rtruediv__(self: Self, lhs: Self) -> Self\n\nReverse division.\n\nCalls the underlying object’s __rtruediv__ method.\n\nArgs:\n\n​lhs (Self): The left-hand-side value that is divided by this object.\n\nReturns:\n\nThe result of dividing the given value by this.\n\n__rfloordiv__\n\n__rfloordiv__(self: Self, lhs: Self) -> Self\n\nReverse floor division.\n\nCalls the underlying object’s __rfloordiv__ method.\n\nArgs:\n\n​lhs (Self): The left-hand-side value that is divided by this object.\n\nReturns:\n\nThe result of dividing the given value by this, modulo any remainder.\n\n__rmod__\n\n__rmod__(self: Self, lhs: Self) -> Self\n\nReverse modulo.\n\nCalls the underlying object’s __rmod__ method.\n\nArgs:\n\n​lhs (Self): The left-hand-side value that is divided by this object.\n\nReturns:\n\nThe remainder from dividing the given value by this.\n\n__rpow__\n\n__rpow__(self: Self, lhs: Self) -> Self\n\nReverse power of.\n\nArgs:\n\n​lhs (Self): The number that is raised to the power of this object.\n\nReturns:\n\nThe result of raising the given value by this exponent.\n\n__rlshift__\n\n__rlshift__(self: Self, lhs: Self) -> Self\n\nReverse bitwise left shift.\n\nArgs:\n\n​lhs (Self): The left-hand-side value that is bitwise shifted to the left by this object.\n\nReturns:\n\nThe given value, shifted left by this.\n\n__rrshift__\n\n__rrshift__(self: Self, lhs: Self) -> Self\n\nReverse bitwise right shift.\n\nArgs:\n\n​lhs (Self): The left-hand-side value that is bitwise shifted to the right by this object.\n\nReturns:\n\nThe given value, shifted right by this.\n\n__rand__\n\n__rand__(self: Self, lhs: Self) -> Self\n\nReverse bitwise and.\n\nArgs:\n\n​lhs (Self): The left-hand-side value that is bitwise AND’ed with this object.\n\nReturns:\n\nThe bitwise AND result of the given value and this.\n\n__ror__\n\n__ror__(self: Self, lhs: Self) -> Self\n\nReverse bitwise OR.\n\nArgs:\n\n​lhs (Self): The left-hand-side value that is bitwise OR’ed with this object.\n\nReturns:\n\nThe bitwise OR result of the given value and this.\n\n__rxor__\n\n__rxor__(self: Self, lhs: Self) -> Self\n\nReverse exclusive OR.\n\nArgs:\n\n​lhs (Self): The left-hand-side value that is exclusive OR’ed with this object.\n\nReturns:\n\nThe exclusive OR result of the given value and this.\n\n__iadd__\n\n__iadd__(inout self: Self, rhs: Self)\n\nImmediate addition and concatenation.\n\nArgs:\n\n​rhs (Self): The right-hand-side value that is added to this object.\n__isub__\n\n__isub__(inout self: Self, rhs: Self)\n\nImmediate subtraction.\n\nArgs:\n\n​rhs (Self): The right-hand-side value that is subtracted from this object.\n__imul__\n\n__imul__(inout self: Self, rhs: Self)\n\nIn-place multiplication.\n\nCalls the underlying object’s __imul__ method.\n\nArgs:\n\n​rhs (Self): The right-hand-side value by which this object is multiplied.\n__itruediv__\n\n__itruediv__(inout self: Self, rhs: Self)\n\nImmediate division.\n\nArgs:\n\n​rhs (Self): The value by which this object is divided.\n__ifloordiv__\n\n__ifloordiv__(inout self: Self, rhs: Self)\n\nImmediate floor division.\n\nArgs:\n\n​rhs (Self): The value by which this object is divided.\n__imod__\n\n__imod__(inout self: Self, rhs: Self)\n\nImmediate modulo.\n\nArgs:\n\n​rhs (Self): The right-hand-side value that is used to divide this object.\n__ipow__\n\n__ipow__(inout self: Self, rhs: Self)\n\nImmediate power of.\n\nArgs:\n\n​rhs (Self): The exponent.\n__ilshift__\n\n__ilshift__(inout self: Self, rhs: Self)\n\nImmediate bitwise left shift.\n\nArgs:\n\n​rhs (Self): The right-hand-side value by which this object is bitwise shifted to the left.\n__irshift__\n\n__irshift__(inout self: Self, rhs: Self)\n\nImmediate bitwise right shift.\n\nArgs:\n\n​rhs (Self): The right-hand-side value by which this object is bitwise shifted to the right.\n__iand__\n\n__iand__(inout self: Self, rhs: Self)\n\nImmediate bitwise AND.\n\nArgs:\n\n​rhs (Self): The right-hand-side value with which this object is bitwise AND’ed.\n__ixor__\n\n__ixor__(inout self: Self, rhs: Self)\n\nImmediate exclusive OR.\n\nArgs:\n\n​rhs (Self): The right-hand-side value with which this object is exclusive OR’ed.\n__ior__\n\n__ior__(inout self: Self, rhs: Self)\n\nImmediate bitwise OR.\n\nArgs:\n\n​rhs (Self): The right-hand-side value with which this object is bitwise OR’ed.\n__iter__\n\n__iter__(inout self: Self) -> _PyIter\n\nIterate over object if supported.\n\nReturns:\n\nAn iterator object.\n\n__getattr__\n\n__getattr__(self: Self, name: StringLiteral) -> Self\n\nReturn the value of the object attribute with the given name.\n\nArgs:\n\n​name (StringLiteral): The name of the object attribute to return.\n\nReturns:\n\nThe value of the object attribute with the given name.\n\n__setattr__\n\n__setattr__(self: Self, name: StringLiteral, newValue: Self)\n\nSet the given value for the object attribute with the given name.\n\nArgs:\n\n​name (StringLiteral): The name of the object attribute to set.\n​newValue (Self): The new value to be set for that attribute.\n\n__setattr__(self: Self, name: StringLiteral, newValue: Dictionary)\n\nSet the given dict for the object attribute with the given name.\n\nArgs:\n\n​name (StringLiteral): The name of the object attribute to set.\n​newValue (Dictionary): The new dict value to be set for that attribute.\n__call__\n\n__call__(self: Self, *args: Self) -> Self\n\nCall the underlying object as if it were a function.\n\nReturns:\n\nThe return value from the called object.\n\nto_float64\n\nto_float64(self: Self) -> SIMD[f64, 1]\n\nReturns a float representation of the object.\n\nReturns:\n\nA floating point value that represents this object.\n\n__index__\n\n__index__(self: Self) -> Int\n\nReturns an index representation of the object.\n\nReturns:\n\nAn index value that represents this object.\n\n__int__\n\n__int__(self: Self) -> Int\n\nReturns an integral representation of the object.\n\nReturns:\n\nAn integral value that represents this object.\n\n__str__\n\n__str__(self: Self) -> String\n\nReturns a string representation of the object.\n\nCalls the underlying object’s __str__ method.\n\nReturns:\n\nA string that represents this object.\n\nImplemented Traits:\n\n​Destructable\n​Intable\n​Stringable\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - path",
    "url": "https://docs.modular.com/mojo/stdlib/pathlib/path.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nmemory\nos\npathlib\npath\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nPath\n__init__\n__copyinit__\n__eq__\n__ne__\n__truediv__\n__str__\n__repr__\nexists\nread_text\nread_bytes\nsuffix\ncwd\npath\n\nModule\n\nImplements Path and related functions.\n\nAliases:\n\n​DIR_SEPARATOR = cond(apply(:!lit.signature<(\"self\": !kgen.declref<@\"$builtin\"::@\"$bool\"::@Bool, !lit.metatype<@\"$builtin\"::@\"$bool\"::@Bool>> borrow) -> i1> @\"$builtin\"::@\"$bool\"::@Bool::@\"__mlir_i1__($builtin::$bool::Bool)\", apply(:!lit.signature<() -> !kgen.declref<@\"$builtin\"::@\"$bool\"::@Bool, !lit.metatype<@\"$builtin\"::@\"$bool\"::@Bool>>> @\"$sys\"::@\"$info\"::@\"os_is_windows()\")), #lit.struct<{value: string = \"\\\\\"}>, #lit.struct<{value: string = \"/\"}>)\nPath\n\nThe Path object.\n\nFields:\n\n​path (String): The underlying path string representation.\n\nFunctions:\n\n__init__\n\n__init__(inout self: Self)\n\nInitializes a path with the current directory.\n\n__init__(inout self: Self, path: StringLiteral)\n\nInitializes a path with the provided path.\n\nArgs:\n\n​path (StringLiteral): The file system path.\n\n__init__(inout self: Self, path: StringRef)\n\nInitializes a path with the provided path.\n\nArgs:\n\n​path (StringRef): The file system path.\n\n__init__(inout self: Self, path: String)\n\nInitializes a path with the provided path.\n\nArgs:\n\n​path (String): The file system path.\n__copyinit__\n\n__copyinit__(inout self: Self, existing: Self)\n\nCopy constructor for the path struct.\n\nArgs:\n\n​existing (Self): The existing struct to copy from.\n__eq__\n\n__eq__(self: Self, other: Self) -> Bool\n\nReturns True if the two paths are equal.\n\nArgs:\n\n​other (Self): The other path to compare against.\n\nReturns:\n\nTrue if the paths are equal and False otherwise.\n\n__ne__\n\n__ne__(self: Self, other: Self) -> Bool\n\nReturns True if the two paths are not equal.\n\nArgs:\n\n​other (Self): The other path to compare against.\n\nReturns:\n\nTrue if the paths are not equal and False otherwise.\n\n__truediv__\n\n__truediv__(self: Self, suffix: Self) -> Self\n\nJoins two paths using the system-defined path separator.\n\nArgs:\n\n​suffix (Self): The suffix to append to the path.\n\nReturns:\n\nA new path with the suffix appended to the current path.\n\n__truediv__(self: Self, suffix: StringLiteral) -> Self\n\nJoins two paths using the system-defined path separator.\n\nArgs:\n\n​suffix (StringLiteral): The suffix to append to the path.\n\nReturns:\n\nA new path with the suffix appended to the current path.\n\n__truediv__(self: Self, suffix: StringRef) -> Self\n\nJoins two paths using the system-defined path separator.\n\nArgs:\n\n​suffix (StringRef): The suffix to append to the path.\n\nReturns:\n\nA new path with the suffix appended to the current path.\n\n__truediv__(self: Self, suffix: String) -> Self\n\nJoins two paths using the system-defined path separator.\n\nArgs:\n\n​suffix (String): The suffix to append to the path.\n\nReturns:\n\nA new path with the suffix appended to the current path.\n\n__str__\n\n__str__(self: Self) -> String\n\nReturns a string representation of the path.\n\nReturns:\n\nA string represntation of the path.\n\n__repr__\n\n__repr__(self: Self) -> String\n\nReturns a printable representation of the path.\n\nReturns:\n\nA printable represntation of the path.\n\nexists\n\nexists(self: Self) -> Bool\n\nReturns True if the path exists and False otherwise.\n\nReturns:\n\nTrue if the path exists on disk and False otherwise.\n\nread_text\n\nread_text(self: Self) -> String\n\nReturns content of the file.\n\nReturns:\n\nContents of file as string.\n\nread_bytes\n\nread_bytes(self: Self) -> Tensor[si8]\n\nReturns content of the file as bytes.\n\nReturns:\n\nContents of file as 1D Tensor of bytes.\n\nsuffix\n\nsuffix(self: Self) -> String\n\nThe path’s extension, if any. This includes the leading period. For example: ‘.txt’. If no extension is found, returns the empty string.\n\nReturns:\n\nThe path’s extension.\n\nImplemented Traits:\n\n​Destructable\n​Stringable\ncwd\n\ncwd() -> Path\n\nGets the current directory.\n\nReturns:\n\nThe current directory.\n\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - env",
    "url": "https://docs.modular.com/mojo/stdlib/os/env.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nmemory\nos\natomic\nenv\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nsetenv\ngetenv\nenv\n\nModule\n\nImplements basic routines for working with the OS.\n\nYou can import these APIs from the os package. For example:\n\nfrom os import setenv\nsetenv\n\nsetenv(name: StringRef, value: StringRef, overwrite: Bool) -> Bool\n\nChanges or adds an environment variable.\n\nConstraints:\n\nThe function only works on macOS or Linux and returns False otherwise.\n\nArgs:\n\n​name (StringRef): The name of the environment variable.\n​value (StringRef): The value of the environment variable.\n​overwrite (Bool): If an environment variable with the given name already exists, its value is not changed unless overwrite is True.\n\nReturns:\n\nFalse if the name is empty or contains an = character. In any other case, True is returned.\n\ngetenv\n\ngetenv(name: StringRef, default: StringRef) -> StringRef\n\nReturns the value of the given environment variable.\n\nConstraints:\n\nThe function only works on macOS or Linux and returns an empty string otherwise.\n\nArgs:\n\n​name (StringRef): The name of the environment variable.\n​default (StringRef): The default value to return if the environment variable doesn’t exist.\n\nReturns:\n\nThe value of the environment variable.\n\ngetenv(name: StringRef) -> StringRef\n\nReturns the value of the given environment variable. If the environment variable is not found, then an empty string is returned.\n\nConstraints:\n\nThe function only works on macOS or Linux and returns an empty string otherwise.\n\nArgs:\n\n​name (StringRef): The name of the environment variable.\n\nReturns:\n\nThe value of the environment variable.\n\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - atomic",
    "url": "https://docs.modular.com/mojo/stdlib/os/atomic.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nmemory\nos\natomic\nenv\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nAtomic\n__init__\n__iadd__\n__isub__\nfetch_add\nfetch_sub\nmax\nmin\natomic\n\nModule\n\nImplements the Atomic class.\n\nYou can import these APIs from the os package. For example:\n\nfrom os.atomic import Atomic\nAtomic\n\nRepresents a value with atomic operations.\n\nThe class provides atomic add and sub methods for mutating the value.\n\nParameters:\n\n​type (DType): DType of the value.\n\nFields:\n\n​value (SIMD[type, 1]): The atomic value.\n\nFunctions:\n\n__init__\n\n__init__(inout self: Self, value: SIMD[type, 1])\n\nConstructs a new atomic value.\n\nArgs:\n\n​value (SIMD[type, 1]): Initial value represented as SIMD[type, 1] type.\n\n__init__(inout self: Self, value: Int)\n\nConstructs a new atomic value.\n\nArgs:\n\n​value (Int): Initial value represented as mlir.index type.\n__iadd__\n\n__iadd__(inout self: Self, rhs: SIMD[type, 1])\n\nPerforms atomic in-place add.\n\nAtomically replaces the current value with the result of arithmetic addition of the value and arg. That is, it performs atomic post-increment. The operation is a read-modify-write operation. Memory is affected according to the value of order which is sequentially consistent.\n\nArgs:\n\n​rhs (SIMD[type, 1]): Value to add.\n__isub__\n\n__isub__(inout self: Self, rhs: SIMD[type, 1])\n\nPerforms atomic in-place sub.\n\nAtomically replaces the current value with the result of arithmetic subtraction of the value and arg. That is, it performs atomic post-decrement. The operation is a read-modify-write operation. Memory is affected according to the value of order which is sequentially consistent.\n\nArgs:\n\n​rhs (SIMD[type, 1]): Value to subtract.\nfetch_add\n\nfetch_add(inout self: Self, rhs: SIMD[type, 1]) -> SIMD[type, 1]\n\nPerforms atomic in-place add.\n\nAtomically replaces the current value with the result of arithmetic addition of the value and arg. That is, it performs atomic post-increment. The operation is a read-modify-write operation. Memory is affected according to the value of order which is sequentially consistent.\n\nArgs:\n\n​rhs (SIMD[type, 1]): Value to add.\n\nReturns:\n\nThe original value before addition.\n\nfetch_sub\n\nfetch_sub(inout self: Self, rhs: SIMD[type, 1]) -> SIMD[type, 1]\n\nPerforms atomic in-place sub.\n\nAtomically replaces the current value with the result of arithmetic subtraction of the value and arg. That is, it performs atomic post-decrement. The operation is a read-modify-write operation. Memory is affected according to the value of order which is sequentially consistent.\n\nArgs:\n\n​rhs (SIMD[type, 1]): Value to subtract.\n\nReturns:\n\nThe original value before subtraction.\n\nmax\n\nmax(inout self: Self, rhs: SIMD[type, 1])\n\nPerforms atomic in-place max.\n\nAtomically replaces the current value with the result of max of the value and arg. The operation is a read-modify-write operation perform according to sequential consistency semantics.\n\nConstraints:\n\nThe input type must be either integral or floating-point type.\n\nArgs:\n\n​rhs (SIMD[type, 1]): Value to max.\nmin\n\nmin(inout self: Self, rhs: SIMD[type, 1])\n\nPerforms atomic in-place min.\n\nAtomically replaces the current value with the result of min of the value and arg. The operation is a read-modify-write operation. The operation is a read-modify-write operation perform according to sequential consistency semantics.\n\nConstraints:\n\nThe input type must be either integral or floating-point type.\n\nArgs:\n\n​rhs (SIMD[type, 1]): Value to min.\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - unsafe",
    "url": "https://docs.modular.com/mojo/stdlib/memory/unsafe.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nmemory\nbuffer\nmemory\nunsafe\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nAddressSpace\n__init__\n__eq__\nvalue\nPointer\nDTypePointer\nbitcast\nunsafe\n\nModule\n\nImplements classes for working with unsafe pointers.\n\nYou can import these APIs from the memory package. For example:\n\nfrom memory.unsafe import Pointer\nAddressSpace\n\nAddress space of the pointer.\n\nAliases:\n\n​GENERIC = 0: Generic address space.\n\nFunctions:\n\n__init__\n\n__init__(value: Int) -> Self\n\nInitializes the address space from the underlying integeral value.\n\nArgs:\n\n​value (Int): The address space value.\n\nReturns:\n\nThe address space.\n\n__init__(value: AddressSpace) -> Self\n\nInitializes the address space from the underlying value.\n\nArgs:\n\n​value (AddressSpace): The address space value.\n\nReturns:\n\nThe address space.\n\n__eq__\n\n__eq__(self: Self, other: Self) -> Bool\n\nThe True if the two address spaces are equal and False otherwise.\n\nArgs:\n\n​other (Self): The other address space value.\n\nReturns:\n\nTrue if the two address spaces are equal and False otherwise.\n\nvalue\n\nvalue(self: Self) -> Int\n\nThe integral value of the address space.\n\nReturns:\n\nThe integral value of the address space.\n\nPointer\n\nDefines a Pointer struct that contains the address of a register passable type.\n\nParameters:\n\n​type (AnyRegType): Type of the underlying data.\n​address_space (AddressSpace): The address space the pointer is in.\n\nAliases:\n\n​pointer_type = pointer<*\"type\", #lit.struct.extract<:!kgen.declref<@\"$builtin\"::@\"$int\"::@Int, !lit.metatype<@\"$builtin\"::@\"$int\"::@Int>> apply(:!lit.signature<(\"self\": !kgen.declref<@\"$memory\"::@\"$unsafe\"::@AddressSpace, !lit.metatype<@\"$memory\"::@\"$unsafe\"::@AddressSpace>> borrow) -> !kgen.declref<@\"$builtin\"::@\"$int\"::@Int, !lit.metatype<@\"$builtin\"::@\"$int\"::@Int>>> @\"$memory\"::@\"$unsafe\"::@AddressSpace::@\"value($memory::$unsafe::AddressSpace)\", address_space), \"value\">>\n\nFields:\n\n​address (pointer<*\"type\", #lit.struct.extract<:!kgen.declref<@\"$builtin\"::@\"$int\"::@Int, !lit.metatype<@\"$builtin\"::@\"$int\"::@Int>> apply(:!lit.signature<(\"self\": !kgen.declref<@\"$memory\"::@\"$unsafe\"::@AddressSpace, !lit.metatype<@\"$memory\"::@\"$unsafe\"::@AddressSpace>> borrow) -> !kgen.declref<@\"$builtin\"::@\"$int\"::@Int, !lit.metatype<@\"$builtin\"::@\"$int\"::@Int>>> @\"$memory\"::@\"$unsafe\"::@AddressSpace::@\"value($memory::$unsafe::AddressSpace)\", address_space), \"value\">>): The pointed-to address.\n\nFunctions:\n\n__init__\n\n__init__() -> Self\n\nConstructs a null Pointer from the value of pop.pointer type.\n\nReturns:\n\nConstructed Pointer object.\n\n__init__(address: Self) -> Self\n\nConstructs a Pointer from the address.\n\nArgs:\n\n​address (Self): The input pointer.\n\nReturns:\n\nConstructed Pointer object.\n\n__init__(address: pointer<*\"type\", #lit.struct.extract<:!kgen.declref<_\"$builtin\"::_\"$int\"::_Int, !lit.metatype<_\"$builtin\"::_\"$int\"::_Int>> apply(:!lit.signature<(\"self\": !kgen.declref<_\"$memory\"::_\"$unsafe\"::_AddressSpace, !lit.metatype<_\"$memory\"::_\"$unsafe\"::_AddressSpace>> borrow) -> !kgen.declref<_\"$builtin\"::_\"$int\"::_Int, !lit.metatype<_\"$builtin\"::_\"$int\"::_Int>>> _\"$memory\"::_\"$unsafe\"::_AddressSpace::_\"value($memory::$unsafe::AddressSpace)\", address_space), \"value\">>) -> Self\n\nConstructs a Pointer from the address.\n\nArgs:\n\n​address (pointer<*\"type\", #lit.struct.extract<:!kgen.declref<_\"$builtin\"::_\"$int\"::_Int, !lit.metatype<_\"$builtin\"::_\"$int\"::_Int>> apply(:!lit.signature<(\"self\": !kgen.declref<_\"$memory\"::_\"$unsafe\"::_AddressSpace, !lit.metatype<_\"$memory\"::_\"$unsafe\"::_AddressSpace>> borrow) -> !kgen.declref<_\"$builtin\"::_\"$int\"::_Int, !lit.metatype<_\"$builtin\"::_\"$int\"::_Int>>> _\"$memory\"::_\"$unsafe\"::_AddressSpace::_\"value($memory::$unsafe::AddressSpace)\", address_space), \"value\">>): The input pointer address.\n\nReturns:\n\nConstructed Pointer object.\n\n__init__(value: SIMD[address, 1]) -> Self\n\nConstructs a Pointer from the value of scalar address.\n\nArgs:\n\n​value (SIMD[address, 1]): The input pointer index.\n\nReturns:\n\nConstructed Pointer object.\n\n__bool__\n\n__bool__(self: Self) -> Bool\n\nChecks if the Pointer is null.\n\nReturns:\n\nReturns False if the Pointer is null and True otherwise.\n\n__getitem__\n\n__getitem__(self: Self, offset: Int) -> *\"type\"\n\nLoads the value the Pointer object points to with the given offset.\n\nArgs:\n\n​offset (Int): The offset to load from.\n\nReturns:\n\nThe loaded value.\n\n__setitem__\n\n__setitem__(self: Self, offset: Int, *val: \"type\")\n\nStores the specified value to the location the Pointer object points to with the given offset.\n\nArgs:\n\n​offset (Int): The offset to store to.\n​val (*\"type\"): The value to store.\n__lt__\n\n__lt__(self: Self, rhs: Self) -> Bool\n\nReturns True if this pointer represents a lower address than rhs.\n\nArgs:\n\n​rhs (Self): The value of the other pointer.\n\nReturns:\n\nTrue if this pointer represents a lower address and False otherwise.\n\n__eq__\n\n__eq__(self: Self, rhs: Self) -> Bool\n\nReturns True if the two pointers are equal.\n\nArgs:\n\n​rhs (Self): The value of the other pointer.\n\nReturns:\n\nTrue if the two pointers are equal and False otherwise.\n\n__ne__\n\n__ne__(self: Self, rhs: Self) -> Bool\n\nReturns True if the two pointers are not equal.\n\nArgs:\n\n​rhs (Self): The value of the other pointer.\n\nReturns:\n\nTrue if the two pointers are not equal and False otherwise.\n\n__add__\n\n__add__(self: Self, rhs: Int) -> Self\n\nReturns a new pointer shifted by the specified offset.\n\nArgs:\n\n​rhs (Int): The offset.\n\nReturns:\n\nThe new Pointer shifted by the offset.\n\n__sub__\n\n__sub__(self: Self, rhs: Int) -> Self\n\nReturns a new pointer shifted back by the specified offset.\n\nArgs:\n\n​rhs (Int): The offset.\n\nReturns:\n\nThe new Pointer shifted back by the offset.\n\n__iadd__\n\n__iadd__(inout self: Self, rhs: Int)\n\nShifts the current pointer by the specified offset.\n\nArgs:\n\n​rhs (Int): The offset.\n__isub__\n\n__isub__(inout self: Self, rhs: Int)\n\nShifts back the current pointer by the specified offset.\n\nArgs:\n\n​rhs (Int): The offset.\nget_null\n\nstatic get_null() -> Self\n\nConstructs a Pointer representing nullptr.\n\nReturns:\n\nConstructed nullptr Pointer object.\n\naddress_of\n\nstatic address_of(inout *arg: \"type\") -> Self\n\nGets the address of the argument.\n\nArgs:\n\n​arg (*\"type\"): The value to get the address of.\n\nReturns:\n\nA Pointer struct which contains the address of the argument.\n\nload\n\nload(self: Self, offset: Int) -> *\"type\"\n\nLoads the value the Pointer object points to with the given offset.\n\nArgs:\n\n​offset (Int): The offset to load from.\n\nReturns:\n\nThe loaded value.\n\naligned_load\n\naligned_load[alignment: Int](self: Self, offset: Int) -> *\"type\"\n\nLoads a value from the pointer with the guaranteed specified alignment.\n\nParameters:\n\n​alignment (Int): The minimal alignment of the address.\n\nArgs:\n\n​offset (Int): The offset to load from.\n\nReturns:\n\nThe loaded value.\n\nstore\n\nstore(self: Self, offset: Int, *value: \"type\")\n\nStores the specified value to the location the Pointer object points to with the given offset.\n\nArgs:\n\n​offset (Int): The offset to store to.\n​value (*\"type\"): The value to store.\n\nstore(self: Self, *value: \"type\")\n\nStores the specified value to the location the Pointer object points to.\n\nArgs:\n\n​value (*\"type\"): The value to store.\naligned_store\n\naligned_store[alignment: Int](self: Self, *val: \"type\")\n\nStores a value with a guaranteed alignment.\n\nParameters:\n\n​alignment (Int): The minimal alignment of the address.\n\nArgs:\n\n​val (*\"type\"): The value to store.\nnt_store\n\nnt_store(self: Self, *val: \"type\")\n\nStores a value using non-temporal store.\n\nThe address must be properly aligned, 64B for avx512, 32B for avx2, and 16B for avx.\n\nArgs:\n\n​val (*\"type\"): The value to store.\nalloc\n\nstatic alloc(count: Int) -> Self\n\nHeap-allocates a number of element of the specified type.\n\nArgs:\n\n​count (Int): The number of elements to allocate (note that this is not the bytecount).\n\nReturns:\n\nA new Pointer object which has been allocated on the heap.\n\naligned_alloc\n\nstatic aligned_alloc(alignment: Int, count: Int) -> Self\n\nHeap-allocates a number of element of the specified type using the specified alignment.\n\nArgs:\n\n​alignment (Int): The alignment used for the allocation.\n​count (Int): The number of elements to allocate (note that this is not the bytecount).\n\nReturns:\n\nA new Pointer object which has been allocated on the heap.\n\nfree\n\nfree(self: Self)\n\nFrees the heap allocated memory.\n\nbitcast\n\nbitcast[new_type: AnyRegType](self: Self) -> Pointer[new_type, address_space]\n\nBitcasts a Pointer to a different type.\n\nParameters:\n\n​new_type (AnyRegType): The target type.\n\nReturns:\n\nA new Pointer object with the specified type and the same address, as the original Pointer.\n\naddress_space_cast\n\naddress_space_cast[new_address_space: AddressSpace](self: Self) -> Pointer[*\"type\", new_address_space]\n\nCasts a Pointer to a different address space.\n\nParameters:\n\n​new_address_space (AddressSpace): The address space.\n\nReturns:\n\nA new Pointer object with the specified type and the same address, as the original Pointer but located in a different address space.\n\noffset\n\noffset(self: Self, idx: Int) -> Self\n\nReturns a new pointer shifted by the specified offset.\n\nArgs:\n\n​idx (Int): The offset.\n\nReturns:\n\nThe new Pointer shifted by the offset.\n\nDTypePointer\n\nDefines a DTypePointer struct that contains an address of the given dtype.\n\nParameters:\n\n​type (DType): DType of the underlying data.\n​address_space (AddressSpace): The address space the pointer is in.\n\nAliases:\n\n​element_type = SIMD[type, 1]\n​pointer_type = Pointer[SIMD[type, 1], address_space]\n\nFields:\n\n​address (Pointer[SIMD[type, 1], address_space]): The pointed-to address.\n\nFunctions:\n\n__init__\n\n__init__() -> Self\n\nConstructs a null DTypePointer from the given type.\n\nReturns:\n\nConstructed DTypePointer object.\n\n__init__(value: pointer<scalar<#lit.struct.extract<:!kgen.declref<_\"$builtin\"::_\"$dtype\"::_DType, !lit.metatype<_\"$builtin\"::_\"$dtype\"::_DType>> type, \"value\">>, #lit.struct.extract<:!kgen.declref<_\"$builtin\"::_\"$int\"::_Int, !lit.metatype<_\"$builtin\"::_\"$int\"::_Int>> apply(:!lit.signature<(\"self\": !kgen.declref<_\"$memory\"::_\"$unsafe\"::_AddressSpace, !lit.metatype<_\"$memory\"::_\"$unsafe\"::_AddressSpace>> borrow) -> !kgen.declref<_\"$builtin\"::_\"$int\"::_Int, !lit.metatype<_\"$builtin\"::_\"$int\"::_Int>>> _\"$memory\"::_\"$unsafe\"::_AddressSpace::_\"value($memory::$unsafe::AddressSpace)\", address_space), \"value\">>) -> Self\n\nConstructs a DTypePointer from a scalar pointer of the same type.\n\nArgs:\n\n​value (pointer<scalar<#lit.struct.extract<:!kgen.declref<_\"$builtin\"::_\"$dtype\"::_DType, !lit.metatype<_\"$builtin\"::_\"$dtype\"::_DType>> type, \"value\">>, #lit.struct.extract<:!kgen.declref<_\"$builtin\"::_\"$int\"::_Int, !lit.metatype<_\"$builtin\"::_\"$int\"::_Int>> apply(:!lit.signature<(\"self\": !kgen.declref<_\"$memory\"::_\"$unsafe\"::_AddressSpace, !lit.metatype<_\"$memory\"::_\"$unsafe\"::_AddressSpace>> borrow) -> !kgen.declref<_\"$builtin\"::_\"$int\"::_Int, !lit.metatype<_\"$builtin\"::_\"$int\"::_Int>>> _\"$memory\"::_\"$unsafe\"::_AddressSpace::_\"value($memory::$unsafe::AddressSpace)\", address_space), \"value\">>): The scalar pointer.\n\nReturns:\n\nConstructed DTypePointer.\n\n__init__(value: Pointer[SIMD[type, 1], address_space]) -> Self\n\nConstructs a DTypePointer from a scalar pointer of the same type.\n\nArgs:\n\n​value (Pointer[SIMD[type, 1], address_space]): The scalar pointer.\n\nReturns:\n\nConstructed DTypePointer.\n\n__init__(value: SIMD[address, 1]) -> Self\n\nConstructs a DTypePointer from the value of scalar address.\n\nArgs:\n\n​value (SIMD[address, 1]): The input pointer index.\n\nReturns:\n\nConstructed DTypePointer object.\n\n__bool__\n\n__bool__(self: Self) -> Bool\n\nChecks if the DTypePointer is null.\n\nReturns:\n\nReturns False if the DTypePointer is null and True otherwise.\n\n__getitem__\n\n__getitem__(self: Self, offset: Int) -> SIMD[type, 1]\n\nLoads a single element (SIMD of size 1) from the pointer at the specified index.\n\nArgs:\n\n​offset (Int): The offset to load from.\n\nReturns:\n\nThe loaded value.\n\n__setitem__\n\n__setitem__(self: Self, offset: Int, val: SIMD[type, 1])\n\nStores a single element value at the given offset.\n\nArgs:\n\n​offset (Int): The offset to store to.\n​val (SIMD[type, 1]): The value to store.\n__lt__\n\n__lt__(self: Self, rhs: Self) -> Bool\n\nReturns True if this pointer represents a lower address than rhs.\n\nArgs:\n\n​rhs (Self): The value of the other pointer.\n\nReturns:\n\nTrue if this pointer represents a lower address and False otherwise.\n\n__eq__\n\n__eq__(self: Self, rhs: Self) -> Bool\n\nReturns True if the two pointers are equal.\n\nArgs:\n\n​rhs (Self): The value of the other pointer.\n\nReturns:\n\nTrue if the two pointers are equal and False otherwise.\n\n__ne__\n\n__ne__(self: Self, rhs: Self) -> Bool\n\nReturns True if the two pointers are not equal.\n\nArgs:\n\n​rhs (Self): The value of the other pointer.\n\nReturns:\n\nTrue if the two pointers are not equal and False otherwise.\n\n__add__\n\n__add__(self: Self, rhs: Int) -> Self\n\nReturns a new pointer shifted by the specified offset.\n\nArgs:\n\n​rhs (Int): The offset.\n\nReturns:\n\nThe new DTypePointer shifted by the offset.\n\n__sub__\n\n__sub__(self: Self, rhs: Int) -> Self\n\nReturns a new pointer shifted back by the specified offset.\n\nArgs:\n\n​rhs (Int): The offset.\n\nReturns:\n\nThe new DTypePointer shifted by the offset.\n\n__iadd__\n\n__iadd__(inout self: Self, rhs: Int)\n\nShifts the current pointer by the specified offset.\n\nArgs:\n\n​rhs (Int): The offset.\n__isub__\n\n__isub__(inout self: Self, rhs: Int)\n\nShifts back the current pointer by the specified offset.\n\nArgs:\n\n​rhs (Int): The offset.\nget_null\n\nstatic get_null() -> Self\n\nConstructs a DTypePointer representing nullptr.\n\nReturns:\n\nConstructed nullptr DTypePointer object.\n\naddress_of\n\nstatic address_of(inout arg: SIMD[type, 1]) -> Self\n\nGets the address of the argument.\n\nArgs:\n\n​arg (SIMD[type, 1]): The value to get the address of.\n\nReturns:\n\nA DTypePointer struct which contains the address of the argument.\n\nalloc\n\nstatic alloc(count: Int) -> Self\n\nHeap-allocates a number of element of the specified type.\n\nArgs:\n\n​count (Int): The number of elements to allocate (note that this is not the bytecount).\n\nReturns:\n\nA new DTypePointer object which has been allocated on the heap.\n\naligned_alloc\n\nstatic aligned_alloc(alignment: Int, count: Int) -> Self\n\nHeap-allocates a number of element of the specified type using the specified alignment.\n\nArgs:\n\n​alignment (Int): The alignment used for the allocation.\n​count (Int): The number of elements to allocate (note that this is not the bytecount).\n\nReturns:\n\nA new DTypePointer object which has been allocated on the heap.\n\nfree\n\nfree(self: Self)\n\nFrees the heap allocates memory.\n\nbitcast\n\nbitcast[new_type: DType](self: Self) -> DTypePointer[new_type, address_space]\n\nBitcasts DTypePointer to a different dtype.\n\nParameters:\n\n​new_type (DType): The target dtype.\n\nReturns:\n\nA new DTypePointer object with the specified dtype and the same address, as the original DTypePointer.\n\nload\n\nload(self: Self, offset: Int) -> SIMD[type, 1]\n\nLoads a single element (SIMD of size 1) from the pointer at the specified index.\n\nArgs:\n\n​offset (Int): The offset to load from.\n\nReturns:\n\nThe loaded value.\n\nload(self: Self) -> SIMD[type, 1]\n\nLoads a single element (SIMD of size 1) from the pointer.\n\nReturns:\n\nThe loaded value.\n\nprefetch\n\nprefetch[params: PrefetchOptions](self: Self)\n\nPrefetches memory at the underlying address.\n\nParameters:\n\n​params (PrefetchOptions): Prefetch options (see PrefetchOptions for details).\nsimd_load\n\nsimd_load[width: Int](self: Self, offset: Int) -> SIMD[type, width]\n\nLoads a SIMD vector of elements from the pointer at the specified offset.\n\nParameters:\n\n​width (Int): The SIMD width.\n\nArgs:\n\n​offset (Int): The offset to load from.\n\nReturns:\n\nThe loaded value.\n\nsimd_load[width: Int](self: Self) -> SIMD[type, width]\n\nLoads a SIMD vector of elements from the pointer.\n\nParameters:\n\n​width (Int): The SIMD width.\n\nReturns:\n\nThe loaded SIMD value.\n\naligned_simd_load\n\naligned_simd_load[width: Int, alignment: Int](self: Self, offset: Int) -> SIMD[type, width]\n\nLoads a SIMD vector of elements from the pointer at the specified offset with the guaranteed specified alignment.\n\nParameters:\n\n​width (Int): The SIMD width.\n​alignment (Int): The minimal alignment of the address.\n\nArgs:\n\n​offset (Int): The offset to load from.\n\nReturns:\n\nThe loaded SIMD value.\n\naligned_simd_load[width: Int, alignment: Int](self: Self) -> SIMD[type, width]\n\nLoads a SIMD vector of elements from the pointer with the guaranteed specified alignment.\n\nParameters:\n\n​width (Int): The SIMD width.\n​alignment (Int): The minimal alignment of the address.\n\nReturns:\n\nThe loaded SIMD value.\n\nstore\n\nstore(self: Self, offset: Int, val: SIMD[type, 1])\n\nStores a single element value at the given offset.\n\nArgs:\n\n​offset (Int): The offset to store to.\n​val (SIMD[type, 1]): The value to store.\n\nstore(self: Self, val: SIMD[type, 1])\n\nStores a single element value.\n\nArgs:\n\n​val (SIMD[type, 1]): The value to store.\nsimd_store\n\nsimd_store[width: Int](self: Self, offset: Int, val: SIMD[type, width])\n\nStores a SIMD vector at the given offset.\n\nParameters:\n\n​width (Int): The SIMD width.\n\nArgs:\n\n​offset (Int): The offset to store to.\n​val (SIMD[type, width]): The SIMD value to store.\n\nsimd_store[width: Int](self: Self, val: SIMD[type, width])\n\nStores a SIMD vector.\n\nParameters:\n\n​width (Int): The SIMD width.\n\nArgs:\n\n​val (SIMD[type, width]): The SIMD value to store.\nsimd_nt_store\n\nsimd_nt_store[width: Int](self: Self, offset: Int, val: SIMD[type, width])\n\nStores a SIMD vector using non-temporal store.\n\nParameters:\n\n​width (Int): The SIMD width.\n\nArgs:\n\n​offset (Int): The offset to store to.\n​val (SIMD[type, width]): The SIMD value to store.\n\nsimd_nt_store[width: Int](self: Self, val: SIMD[type, width])\n\nStores a SIMD vector using non-temporal store.\n\nThe address must be properly aligned, 64B for avx512, 32B for avx2, and 16B for avx.\n\nParameters:\n\n​width (Int): The SIMD width.\n\nArgs:\n\n​val (SIMD[type, width]): The SIMD value to store.\nsimd_strided_load\n\nsimd_strided_load[width: Int](self: Self, stride: Int) -> SIMD[type, width]\n\nPerforms a strided load of the SIMD vector.\n\nParameters:\n\n​width (Int): The SIMD width.\n\nArgs:\n\n​stride (Int): The stride between loads.\n\nReturns:\n\nA vector which is stride loaded.\n\nsimd_strided_store\n\nsimd_strided_store[width: Int](self: Self, val: SIMD[type, width], stride: Int)\n\nPerforms a strided store of the SIMD vector.\n\nParameters:\n\n​width (Int): The SIMD width.\n\nArgs:\n\n​val (SIMD[type, width]): The SIMD value to store.\n​stride (Int): The stride between stores.\naligned_simd_store\n\naligned_simd_store[width: Int, alignment: Int](self: Self, offset: Int, val: SIMD[type, width])\n\nStores a SIMD vector at the given offset with a guaranteed alignment.\n\nParameters:\n\n​width (Int): The SIMD width.\n​alignment (Int): The minimal alignment of the address.\n\nArgs:\n\n​offset (Int): The offset to store to.\n​val (SIMD[type, width]): The SIMD value to store.\n\naligned_simd_store[width: Int, alignment: Int](self: Self, val: SIMD[type, width])\n\nStores a SIMD vector with a guaranteed alignment.\n\nParameters:\n\n​width (Int): The SIMD width.\n​alignment (Int): The minimal alignment of the address.\n\nArgs:\n\n​val (SIMD[type, width]): The SIMD value to store.\nis_aligned\n\nis_aligned[alignment: Int](self: Self) -> Bool\n\nChecks if the pointer is aligned.\n\nParameters:\n\n​alignment (Int): The minimal desired alignment.\n\nReturns:\n\nTrue if the pointer is at least alignment-aligned or False otherwise.\n\noffset\n\noffset(self: Self, idx: Int) -> Self\n\nReturns a new pointer shifted by the specified offset.\n\nArgs:\n\n​idx (Int): The offset of the new pointer.\n\nReturns:\n\nThe new constructed DTypePointer.\n\nbitcast\n\nbitcast[type: AnyRegType, address_space: AddressSpace](val: Int) -> Pointer[*\"type\", address_space]\n\nBitcasts an integer to a pointer.\n\nParameters:\n\n​type (AnyRegType): The target type.\n​address_space (AddressSpace): The address space the pointer is in.\n\nArgs:\n\n​val (Int): The pointer address.\n\nReturns:\n\nA new Pointer with the specified address.\n\nbitcast[type: DType, address_space: AddressSpace](val: Int) -> DTypePointer[type, address_space]\n\nBitcasts an integer to a pointer.\n\nParameters:\n\n​type (DType): The target type.\n​address_space (AddressSpace): The address space the pointer is in.\n\nArgs:\n\n​val (Int): The pointer address.\n\nReturns:\n\nA new Pointer with the specified address.\n\nbitcast[new_type: AnyRegType, src_type: AnyRegType, address_space: AddressSpace](ptr: Pointer[src_type, address_space]) -> Pointer[new_type, address_space]\n\nBitcasts a Pointer to a different type.\n\nParameters:\n\n​new_type (AnyRegType): The target type.\n​src_type (AnyRegType): The source type.\n​address_space (AddressSpace): The address space the pointer is in.\n\nArgs:\n\n​ptr (Pointer[src_type, address_space]): The source pointer.\n\nReturns:\n\nA new Pointer with the specified type and the same address, as the original Pointer.\n\nbitcast[new_type: DType, src_type: DType, address_space: AddressSpace](ptr: DTypePointer[src_type, address_space]) -> DTypePointer[new_type, address_space]\n\nBitcasts a DTypePointer to a different type.\n\nParameters:\n\n​new_type (DType): The target type.\n​src_type (DType): The source type.\n​address_space (AddressSpace): The address space the pointer is in.\n\nArgs:\n\n​ptr (DTypePointer[src_type, address_space]): The source pointer.\n\nReturns:\n\nA new DTypePointer with the specified type and the same address, as the original DTypePointer.\n\nbitcast[new_type: DType, new_width: Int, src_type: DType, src_width: Int](val: SIMD[src_type, src_width]) -> SIMD[new_type, new_width]\n\nBitcasts a SIMD value to another SIMD value.\n\nConstraints:\n\nThe bitwidth of the two types must be the same.\n\nParameters:\n\n​new_type (DType): The target type.\n​new_width (Int): The target width.\n​src_type (DType): The source type.\n​src_width (Int): The source width.\n\nArgs:\n\n​val (SIMD[src_type, src_width]): The source value.\n\nReturns:\n\nA new SIMD value with the specified type and width with a bitcopy of the source SIMD value.\n\nbitcast[new_type: DType, src_type: DType](val: SIMD[src_type, 1]) -> SIMD[new_type, 1]\n\nBitcasts a SIMD value to another SIMD value.\n\nConstraints:\n\nThe bitwidth of the two types must be the same.\n\nParameters:\n\n​new_type (DType): The target type.\n​src_type (DType): The source type.\n\nArgs:\n\n​val (SIMD[src_type, 1]): The source value.\n\nReturns:\n\nA new SIMD value with the specified type and width with a bitcopy of the source SIMD value.\n\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - math",
    "url": "https://docs.modular.com/mojo/stdlib/math/math.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nbit\nlimit\nmath\npolynomial\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nmod\nmul\nsub\nadd\ndiv\nclamp\nabs\nrotate_bits_left\nrotate_bits_right\nrotate_left\nrotate_right\nfloor\nceil\nceildiv\ntrunc\nround\nroundeven\nround_half_down\nround_half_up\nsqrt\nrsqrt\nexp2\nldexp\nexp\nfrexp\nlog\nlog2\ncopysign\nerf\ntanh\nisclose\nall_true\nany_true\nnone_true\nreduce_bit_count\niota\nis_power_of_2\nis_odd\nis_even\nfma\nreciprocal\nidentity\ngreater\ngreater_equal\nless\nless_equal\nequal\nlogical_and\nlogical_not\nlogical_xor\nnot_equal\nselect\nmax\nmin\npow\ndiv_ceil\nalign_down\nalign_down_residual\nalign_up\nacos\nasin\natan\natan2\ncos\nsin\ntan\nacosh\nasinh\natanh\ncosh\nsinh\nexpm1\nlog10\nlog1p\nlogb\ncbrt\nhypot\nerfc\nlgamma\ntgamma\nnearbyint\nrint\nremainder\nnextafter\nj0\nj1\ny0\ny1\nscalb\ngcd\nlcm\nfactorial\nnan\nisnan\ndivmod\nmath\n\nModule\n\nDefines math utilities.\n\nYou can import these APIs from the math package. For example:\n\nfrom math import mul\nmod\n\nmod[type: DType, simd_width: Int](x: SIMD[type, simd_width], y: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nPerforms elementwise modulo operation of two SIMD vectors.\n\nParameters:\n\n​type (DType): DType of the input SIMD vectors.\n​simd_width (Int): Width of the input SIMD vectors.\n\nArgs:\n\n​x (SIMD[type, simd_width]): The numerator of the operation.\n​y (SIMD[type, simd_width]): The denominator of the operation.\n\nReturns:\n\nThe remainder of x divided by y.\n\nmul\n\nmul[type: DType, simd_width: Int](x: SIMD[type, simd_width], y: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nPerforms elementwise multiplication of two SIMD vectors.\n\nParameters:\n\n​type (DType): DType of the input SIMD vectors.\n​simd_width (Int): Width of the input SIMD vectors.\n\nArgs:\n\n​x (SIMD[type, simd_width]): First SIMD vector to multiply.\n​y (SIMD[type, simd_width]): Second SIMD vector to multiply.\n\nReturns:\n\nElementwise multiplication of x and y.\n\nsub\n\nsub[type: DType, simd_width: Int](x: SIMD[type, simd_width], y: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nPerforms elementwise subtraction of two SIMD vectors.\n\nParameters:\n\n​type (DType): DType of the input SIMD vectors.\n​simd_width (Int): Width of the input SIMD vectors.\n\nArgs:\n\n​x (SIMD[type, simd_width]): SIMD vector which y will be subtracted from.\n​y (SIMD[type, simd_width]): SIMD vector to subtract from x.\n\nReturns:\n\nElementwise subtraction of SIMD vector y x - y).\n\nadd\n\nadd[type: DType, simd_width: Int](x: SIMD[type, simd_width], y: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nPerforms elementwise addition of two SIMD vectors.\n\nParameters:\n\n​type (DType): DType of the input SIMD vectors.\n​simd_width (Int): Width of the input SIMD vectors.\n\nArgs:\n\n​x (SIMD[type, simd_width]): First SIMD vector to add.\n​y (SIMD[type, simd_width]): Second SIMD vector to add.\n\nReturns:\n\nElementwise addition of x and y.\n\ndiv\n\ndiv[type: DType, simd_width: Int](x: SIMD[type, simd_width], y: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nPerforms elementwise division of two SIMD vectors.\n\nParameters:\n\n​type (DType): DType of the input SIMD vectors.\n​simd_width (Int): Width of the input SIMD vectors.\n\nArgs:\n\n​x (SIMD[type, simd_width]): SIMD vector containing the dividends.\n​y (SIMD[type, simd_width]): SIMD vector containing the quotients.\n\nReturns:\n\nElementwise division of SIMD vector x by SIMD vector y (this is x / y).\n\nclamp\n\nclamp[type: DType, simd_width: Int](x: SIMD[type, simd_width], lower_bound: SIMD[type, simd_width], upper_bound: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nClamps the values in a SIMD vector to be in a certain range.\n\nClamp cuts values in the input SIMD vector off at the upper bound and lower bound values. For example, SIMD vector [0, 1, 2, 3] clamped to a lower bound of 1 and an upper bound of 2 would return [1, 1, 2, 2].\n\nParameters:\n\n​type (DType): DType of the input SIMD vectors.\n​simd_width (Int): Width of the input SIMD vectors.\n\nArgs:\n\n​x (SIMD[type, simd_width]): SIMD vector to perform the clamp operation on.\n​lower_bound (SIMD[type, simd_width]): Minimum of the range to clamp to.\n​upper_bound (SIMD[type, simd_width]): Maximum of the range to clamp to.\n\nReturns:\n\nA new SIMD vector containing x clamped to be within lower_bound and upper_bound.\n\nabs\n\nabs(x: Int) -> Int\n\nGets the absolute value of an integer.\n\nArgs:\n\n​x (Int): Value to take the absolute value of.\n\nReturns:\n\nThe absolute value of x.\n\nabs[type: DType, simd_width: Int](x: ComplexSIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nPerforms elementwise abs (norm) on each element of the complex value.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (ComplexSIMD[type, simd_width]): The complex vector to perform absolute value on.\n\nReturns:\n\nThe elementwise abs of x.\n\nabs[type: DType, simd_width: Int](x: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nPerforms elementwise absolute value on the elements of a SIMD vector.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, simd_width]): SIMD vector to perform absolute value on.\n\nReturns:\n\nThe elementwise absolute value of x.\n\nrotate_bits_left\n\nrotate_bits_left[shift: Int](x: Int) -> Int\n\nShifts the bits of a input to the left by shift bits (with wrap-around).\n\nConstraints:\n\n-size <= shift < size\n\nParameters:\n\n​shift (Int): The number of bit positions by which to rotate the bits of the integer to the left (with wrap-around).\n\nArgs:\n\n​x (Int): The input value.\n\nReturns:\n\nThe input rotated to the left by shift elements (with wrap-around).\n\nrotate_bits_left[shift: Int, type: DType, width: Int](x: SIMD[type, width]) -> SIMD[type, width]\n\nShifts bits to the left by shift positions (with wrap-around) for each element of a SIMD vector.\n\nConstraints:\n\n0 <= shift < size Only unsigned types can be rotated.\n\nParameters:\n\n​shift (Int): The number of positions by which to shift left the bits for each element of a SIMD vector to the left (with wrap-around).\n​type (DType): The dtype of the input and output SIMD vector.\n​width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, width]): SIMD vector to perform the operation on.\n\nReturns:\n\nThe SIMD vector with each element’s bits shifted to the left by shift bits (with wrap-around).\n\nrotate_bits_right\n\nrotate_bits_right[shift: Int](x: Int) -> Int\n\nShifts the bits of a input to the left by shift bits (with wrap-around).\n\nConstraints:\n\n-size <= shift < size\n\nParameters:\n\n​shift (Int): The number of bit positions by which to rotate the bits of the integer to the left (with wrap-around).\n\nArgs:\n\n​x (Int): The input value.\n\nReturns:\n\nThe input rotated to the left by shift elements (with wrap-around).\n\nrotate_bits_right[shift: Int, type: DType, width: Int](x: SIMD[type, width]) -> SIMD[type, width]\n\nShifts bits to the right by shift positions (with wrap-around) for each element of a SIMD vector.\n\nConstraints:\n\n0 <= shift < size Only unsigned types can be rotated.\n\nParameters:\n\n​shift (Int): The number of positions by which to shift right the bits for each element of a SIMD vector to the left (with wrap-around).\n​type (DType): The dtype of the input and output SIMD vector.\n​width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, width]): SIMD vector to perform the operation on.\n\nReturns:\n\nThe SIMD vector with each element’s bits shifted to the right by shift bits (with wrap-around).\n\nrotate_left\n\nrotate_left[shift: Int](x: Int) -> Int\n\nShifts the bits of a input to the left by shift bits (with wrap-around).\n\nConstraints:\n\n-size <= shift < size\n\nParameters:\n\n​shift (Int): The number of bit positions by which to rotate the bits of the integer to the left (with wrap-around).\n\nArgs:\n\n​x (Int): The input value.\n\nReturns:\n\nThe input rotated to the left by shift elements (with wrap-around).\n\nrotate_left[shift: Int, type: DType, size: Int](x: SIMD[type, size]) -> SIMD[type, size]\n\nShifts the elements of a SIMD vector to the left by shift elements (with wrap-around).\n\nConstraints:\n\n-size <= shift < size\n\nParameters:\n\n​shift (Int): The number of positions by which to rotate the elements of SIMD vector to the left (with wrap-around).\n​type (DType): The DType of the input and output SIMD vector.\n​size (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, size]): The input value.\n\nReturns:\n\nThe SIMD vector rotated to the left by shift elements (with wrap-around).\n\nrotate_right\n\nrotate_right[shift: Int](x: Int) -> Int\n\nShifts the bits of a input to the right by shift bits (with wrap-around).\n\nConstraints:\n\n-size <= shift < size\n\nParameters:\n\n​shift (Int): The number of bit positions by which to rotate the bits of the integer to the right (with wrap-around).\n\nArgs:\n\n​x (Int): The input value.\n\nReturns:\n\nThe input rotated to the right by shift elements (with wrap-around).\n\nrotate_right[shift: Int, type: DType, size: Int](x: SIMD[type, size]) -> SIMD[type, size]\n\nShifts the elements of a SIMD vector to the right by shift elements (with wrap-around).\n\nConstraints:\n\n-size < shift <= size\n\nParameters:\n\n​shift (Int): The number of positions by which to rotate the elements of SIMD vector to the right (with wrap-around).\n​type (DType): The DType of the input and output SIMD vector.\n​size (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, size]): The input value.\n\nReturns:\n\nThe SIMD vector rotated to the right by shift elements (with wrap-around).\n\nfloor\n\nfloor[type: DType, simd_width: Int](x: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nPerforms elementwise floor on the elements of a SIMD vector.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, simd_width]): SIMD vector to perform floor on.\n\nReturns:\n\nThe elementwise floor of x.\n\nceil\n\nceil[type: DType, simd_width: Int](x: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nPerforms elementwise ceiling on the elements of a SIMD vector.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, simd_width]): SIMD vector to perform ceiling on.\n\nReturns:\n\nThe elementwise ceiling of x.\n\nceildiv\n\nceildiv(x: Int, y: Int) -> Int\n\nReturn the rounded-up result of dividing x by y.\n\nArgs:\n\n​x (Int): The numerator.\n​y (Int): The denominator.\n\nReturns:\n\nThe ceiling of dividing x by y.\n\ntrunc\n\ntrunc[type: DType, simd_width: Int](x: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nPerforms elementwise truncation on the elements of a SIMD vector.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, simd_width]): SIMD vector to perform trunc on.\n\nReturns:\n\nThe elementwise truncation of x.\n\nround\n\nround[type: DType, simd_width: Int](x: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nPerforms elementwise rounding on the elements of a SIMD vector.\n\nThis rounding goes to the nearest integer with ties away from zero.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, simd_width]): SIMD vector to perform rounding on.\n\nReturns:\n\nThe elementwise rounding of x.\n\nroundeven\n\nroundeven[type: DType, simd_width: Int](x: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nPerforms elementwise banker’s rounding on the elements of a SIMD vector.\n\nThis rounding goes to the nearest integer with ties toward the nearest even integer.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, simd_width]): SIMD vector to perform rounding on.\n\nReturns:\n\nThe elementwise banker’s rounding of x.\n\nround_half_down\n\nround_half_down[type: DType, simd_width: Int](x: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nRounds ties towards the smaller integer”.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, simd_width]): SIMD vector to perform rounding on.\n\nReturns:\n\nThe elementwise rounding of x evaluating ties towards the smaller integer.\n\nround_half_up\n\nround_half_up[type: DType, simd_width: Int](x: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nRounds ties towards the larger integer”.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, simd_width]): SIMD vector to perform rounding on.\n\nReturns:\n\nThe elementwise rounding of x evaluating ties towards the larger integer.\n\nsqrt\n\nsqrt(x: Int) -> Int\n\nPerforms square root on an integer.\n\nArgs:\n\n​x (Int): The integer value to perform square root on.\n\nReturns:\n\nThe square root of x.\n\nsqrt[type: DType, simd_width: Int](x: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nPerforms elementwise square root on the elements of a SIMD vector.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, simd_width]): SIMD vector to perform square root on.\n\nReturns:\n\nThe elementwise square root of x.\n\nrsqrt\n\nrsqrt[type: DType, simd_width: Int](x: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nPerforms elementwise reciprocal square root on the elements of a SIMD vector.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, simd_width]): SIMD vector to perform reciprocal square root on.\n\nReturns:\n\nThe elementwise reciprocal square root of x.\n\nexp2\n\nexp2[type: DType, simd_width: Int](x: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes elementwise 2 raised to the power of n, where n is an element of the input SIMD vector.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, simd_width]): SIMD vector to perform exp2 on.\n\nReturns:\n\nVector containing \n2\n𝑛\n computed elementwise, where n is an element in the input SIMD vector.\n\nldexp\n\nldexp[type: DType, simd_width: Int](x: SIMD[type, simd_width], exp: SIMD[si32, simd_width]) -> SIMD[type, simd_width]\n\nComputes elementwise ldexp function.\n\nThe ldexp function multiplies a floating point value x by the number 2 raised to the exp power. I.e. \n𝑙\n𝑑\n𝑒\n𝑥\n𝑝\n(\n𝑥\n,\n𝑒\n𝑥\n𝑝\n)\n calculate the value of \n𝑥\n∗\n2\n𝑒\n𝑥\n𝑝\n and is used within the \n𝑒\n𝑟\n𝑓\n function.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, simd_width]): SIMD vector of floating point values.\n​exp (SIMD[si32, simd_width]): SIMD vector containing the exponents.\n\nReturns:\n\nVector containing elementwise result of ldexp on x and exp.\n\nexp\n\nexp[type: DType, simd_width: Int](x: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nCalculates elementwise e^{X_i}, where X_i is an element in the input SIMD vector at position i.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, simd_width]): The input SIMD vector.\n\nReturns:\n\nA SIMD vector containing e raised to the power Xi where Xi is an element in the input SIMD vector.\n\nfrexp\n\nfrexp[type: DType, simd_width: Int](x: SIMD[type, simd_width]) -> StaticTuple[2, SIMD[type, simd_width]]\n\nBreaks floating point values into a fractional part and an exponent part.\n\nConstraints:\n\ntype must be a floating point value.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, simd_width]): The input values.\n\nReturns:\n\nA tuple of two SIMD vectors containing the fractional and exponent parts of the input floating point values.\n\nlog\n\nlog[type: DType, simd_width: Int](x: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nPerforms elementwise natural log (base E) of a SIMD vector.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, simd_width]): Vector to perform logarithm operation on.\n\nReturns:\n\nVector containing result of performing natural log base E on x.\n\nlog2\n\nlog2[type: DType, simd_width: Int](x: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nPerforms elementwise log (base 2) of a SIMD vector.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, simd_width]): Vector to perform logarithm operation on.\n\nReturns:\n\nVector containing result of performing log base 2 on x.\n\ncopysign\n\ncopysign[type: DType, simd_width: Int](magnitude: SIMD[type, simd_width], sign: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nReturns a value with the magnitude of the first operand and the sign of the second operand.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​magnitude (SIMD[type, simd_width]): The magnitude to use.\n​sign (SIMD[type, simd_width]): The sign to copy.\n\nReturns:\n\nCopies the sign from sign to magnitude.\n\nerf\n\nerf[type: DType, simd_width: Int](x: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nPerforms the elementwise Erf on a SIMD vector.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, simd_width]): SIMD vector to perform elementwise Erf on.\n\nReturns:\n\nThe result of the elementwise Erf operation.\n\ntanh\n\ntanh[type: DType, simd_width: Int](x: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nPerforms elementwise evaluation of the tanh function.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, simd_width]): The vector to perform the elementwise tanh on.\n\nReturns:\n\nThe result of the elementwise tanh operation.\n\nisclose\n\nisclose[type: DType, simd_width: Int](a: SIMD[type, simd_width], b: SIMD[type, simd_width], absolute_tolerance: SIMD[type, 1], relative_tolerance: SIMD[type, 1]) -> SIMD[bool, simd_width]\n\nChecks if the two input values are numerically within a tolerance.\n\nWhen the type is integral, then equality is checked. When the type is floating point, then this checks if the two input values are numerically the close using the \n𝑎\n𝑏\n𝑠\n(\n𝑎\n−\n𝑏\n)\n<=\n𝑚\n𝑎\n𝑥\n(\n𝑟\n𝑡\n𝑜\n𝑙\n∗\n𝑚\n𝑎\n𝑥\n(\n𝑎\n𝑏\n𝑠\n(\n𝑎\n)\n,\n𝑎\n𝑏\n𝑠\n(\n𝑏\n)\n)\n,\n𝑎\n𝑡\n𝑜\n𝑙\n)\n formula.\n\nUnlike Pythons’s math.isclose, this implementation is symmetric. I.e. isclose(a,b) == isclose(b,a).\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​a (SIMD[type, simd_width]): The first value to compare.\n​b (SIMD[type, simd_width]): The second value to compare.\n​absolute_tolerance (SIMD[type, 1]): The absolute tolerance.\n​relative_tolerance (SIMD[type, 1]): The relative tolerance.\n\nReturns:\n\nA boolean vector where a and b are equal within the specified tolerance.\n\nall_true\n\nall_true[simd_width: Int](val: SIMD[bool, simd_width]) -> Bool\n\nReturns True if all elements in the SIMD vector are True and False otherwise.\n\nParameters:\n\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​val (SIMD[bool, simd_width]): The SIMD vector to reduce.\n\nReturns:\n\nTrue if all values in the SIMD vector are True and False otherwise.\n\nany_true\n\nany_true[simd_width: Int](val: SIMD[bool, simd_width]) -> Bool\n\nReturns True if any elements in the SIMD vector is True and False otherwise.\n\nParameters:\n\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​val (SIMD[bool, simd_width]): The SIMD vector to reduce.\n\nReturns:\n\nTrue if any values in the SIMD vector is True and False otherwise.\n\nnone_true\n\nnone_true[simd_width: Int](val: SIMD[bool, simd_width]) -> Bool\n\nReturns True if all element in the SIMD vector are False and False otherwise.\n\nParameters:\n\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​val (SIMD[bool, simd_width]): The SIMD vector to reduce.\n\nReturns:\n\nTrue if all values in the SIMD vector are False and False otherwise.\n\nreduce_bit_count\n\nreduce_bit_count[type: DType, simd_width: Int](val: SIMD[type, simd_width]) -> Int\n\nReturns a scalar containing total number of bits set in given vector.\n\nConstraints:\n\nThe input must be either integral or boolean type.\n\nParameters:\n\n​type (DType): The dtype of the input SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​val (SIMD[type, simd_width]): The SIMD vector to reduce.\n\nReturns:\n\nCount of set bits across all elements of the vector.\n\niota\n\niota[type: DType, simd_width: Int]() -> SIMD[type, simd_width]\n\nCreates a SIMD vector containing an increasing sequence, starting from 0.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nReturns:\n\nAn increasing sequence of values, starting from 0.\n\niota[type: DType, simd_width: Int](offset: SIMD[type, 1]) -> SIMD[type, simd_width]\n\nCreates a SIMD vector containing an increasing sequence, starting from offset.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​offset (SIMD[type, 1]): The value to start the sequence at. Default is zero.\n\nReturns:\n\nAn increasing sequence of values, starting from offset.\n\niota[type: DType](buff: DTypePointer[type, 0], len: Int, offset: Int)\n\nFill the buffer with numbers ranging from offset to offset + len - 1, spaced by 1.\n\nThe function doesn’t return anything, the buffer is updated inplace.\n\nParameters:\n\n​type (DType): DType of the underlying data.\n\nArgs:\n\n​buff (DTypePointer[type, 0]): The buffer to fill.\n​len (Int): The length of the buffer to fill.\n​offset (Int): The value to fill at index 0.\n\niota[type: DType](v: DynamicVector[SIMD[type, 1]], offset: Int)\n\nFill the vector with numbers ranging from offset to offset + len - 1, spaced by 1.\n\nThe function doesn’t return anything, the vector is updated inplace.\n\nParameters:\n\n​type (DType): DType of the underlying data.\n\nArgs:\n\n​v (DynamicVector[SIMD[type, 1]]): The vector to fill.\n​offset (Int): The value to fill at index 0.\n\niota(v: DynamicVector[Int], offset: Int)\n\nFill the vector with numbers ranging from offset to offset + len - 1, spaced by 1.\n\nThe function doesn’t return anything, the vector is updated inplace.\n\nArgs:\n\n​v (DynamicVector[Int]): The vector to fill.\n​offset (Int): The value to fill at index 0.\nis_power_of_2\n\nis_power_of_2[type: DType, simd_width: Int](val: SIMD[type, simd_width]) -> SIMD[bool, simd_width]\n\nPerforms elementwise check of whether SIMD vector contains integer powers of two.\n\nAn element of the result SIMD vector will be True if the value is an integer power of two, and False otherwise.\n\nParameters:\n\n​type (DType): The dtype of the input SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​val (SIMD[type, simd_width]): The SIMD vector to perform is_power_of_2 on.\n\nReturns:\n\nA SIMD vector containing True if the corresponding element in val is a power of two, otherwise False.\n\nis_power_of_2(val: Int) -> Bool\n\nChecks whether an integer is a power of two.\n\nArgs:\n\n​val (Int): The integer to check.\n\nReturns:\n\nTrue if val is a power of two, otherwise False.\n\nis_odd\n\nis_odd(val: Int) -> Bool\n\nPerforms elementwise check of whether an integer value is odd.\n\nArgs:\n\n​val (Int): The int value to check.\n\nReturns:\n\nTrue if the input is odd and False otherwise.\n\nis_odd[type: DType, simd_width: Int](val: SIMD[type, simd_width]) -> SIMD[bool, simd_width]\n\nPerforms elementwise check of whether SIMD vector contains odd values.\n\nAn element of the result SIMD vector will be True if the value is odd, and False otherwise.\n\nParameters:\n\n​type (DType): The dtype of the input SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​val (SIMD[type, simd_width]): The SIMD vector to check.\n\nReturns:\n\nA SIMD vector containing True if the corresponding element in val is odd, otherwise False.\n\nis_even\n\nis_even(val: Int) -> Bool\n\nPerforms elementwise check of whether an integer value is even.\n\nArgs:\n\n​val (Int): The int value to check.\n\nReturns:\n\nTrue if the input is even and False otherwise.\n\nis_even[type: DType, simd_width: Int](val: SIMD[type, simd_width]) -> SIMD[bool, simd_width]\n\nPerforms elementwise check of whether SIMD vector contains even values.\n\nAn element of the result SIMD vector will be True if the value is even, and False otherwise.\n\nParameters:\n\n​type (DType): The dtype of the input SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​val (SIMD[type, simd_width]): The SIMD vector to check.\n\nReturns:\n\nA SIMD vector containing True if the corresponding element in val is even, otherwise False.\n\nfma\n\nfma(a: Int, b: Int, c: Int) -> Int\n\nPerforms fma (fused multiply-add) on the inputs.\n\nThe result is (a * b) + c.\n\nArgs:\n\n​a (Int): The first input.\n​b (Int): The second input.\n​c (Int): The third input.\n\nReturns:\n\n(a * b) + c.\n\nfma[type: DType, simd_width: Int](a: SIMD[type, simd_width], b: SIMD[type, simd_width], c: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nPerforms elementwise fma (fused multiply-add) on the inputs.\n\nEach element in the result SIMD vector is \n(\n𝐴\n𝑖\n∗\n𝐵\n𝑖\n)\n+\n𝐶\n𝑖\n, where \n𝐴\n𝑖\n, \n𝐵\n𝑖\n and \n𝐶\n𝑖\n are elements at index \n𝑖\n in a, b, and c respectively.\n\nParameters:\n\n​type (DType): The dtype of the input SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​a (SIMD[type, simd_width]): The first vector of inputs.\n​b (SIMD[type, simd_width]): The second vector of inputs.\n​c (SIMD[type, simd_width]): The third vector of inputs.\n\nReturns:\n\nElementwise fma of a, b and c.\n\nreciprocal\n\nreciprocal[type: DType, simd_width: Int](x: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nTakes the elementwise reciprocal of a SIMD vector.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, simd_width]): The SIMD vector to perform elementwise reciprocal on.\n\nReturns:\n\nA SIMD vector the elementwise reciprocal of x.\n\nidentity\n\nidentity[type: DType, simd_width: Int](x: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nGets the identity of a SIMD vector.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, simd_width]): The SIMD vector to take identity of.\n\nReturns:\n\nIdentity of x, which is x.\n\ngreater\n\ngreater[type: DType, simd_width: Int](x: SIMD[type, simd_width], y: SIMD[type, simd_width]) -> SIMD[bool, simd_width]\n\nPerforms elementwise check of whether values in x are greater than values in y.\n\nAn element of the result SIMD vector will be True if the corresponding element in x is greater than the corresponding element in y, and False otherwise.\n\nParameters:\n\n​type (DType): The dtype of the input SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, simd_width]): First SIMD vector to compare.\n​y (SIMD[type, simd_width]): Second SIMD vector to compare.\n\nReturns:\n\nA SIMD vector containing True if the corresponding element in x is greater than the corresponding element in y, otherwise False.\n\ngreater_equal\n\ngreater_equal[type: DType, simd_width: Int](x: SIMD[type, simd_width], y: SIMD[type, simd_width]) -> SIMD[bool, simd_width]\n\nPerforms elementwise check of whether values in x are greater than or equal to values in y.\n\nAn element of the result SIMD vector will be True if the corresponding element in x is greater than or equal to the corresponding element in y, and False otherwise.\n\nParameters:\n\n​type (DType): The dtype of the input SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, simd_width]): First SIMD vector to compare.\n​y (SIMD[type, simd_width]): Second SIMD vector to compare.\n\nReturns:\n\nA SIMD vector containing True if the corresponding element in x is greater than or equal to the corresponding element in y, otherwise False.\n\nless\n\nless[type: DType, simd_width: Int](x: SIMD[type, simd_width], y: SIMD[type, simd_width]) -> SIMD[bool, simd_width]\n\nPerforms elementwise check of whether values in x are less than values in y.\n\nAn element of the result SIMD vector will be True if the corresponding element in x is less than the corresponding element in y, and False otherwise.\n\nParameters:\n\n​type (DType): The dtype of the input SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, simd_width]): First SIMD vector to compare.\n​y (SIMD[type, simd_width]): Second SIMD vector to compare.\n\nReturns:\n\nA SIMD vector containing True if the corresponding element in x is less than the corresponding element in y, otherwise False.\n\nless_equal\n\nless_equal[type: DType, simd_width: Int](x: SIMD[type, simd_width], y: SIMD[type, simd_width]) -> SIMD[bool, simd_width]\n\nPerforms elementwise check of whether values in x are less than or equal to values in y.\n\nAn element of the result SIMD vector will be True if the corresponding element in x is less than or equal to the corresponding element in y, and False otherwise.\n\nParameters:\n\n​type (DType): The dtype of the input SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, simd_width]): First SIMD vector to compare.\n​y (SIMD[type, simd_width]): Second SIMD vector to compare.\n\nReturns:\n\nA SIMD vector containing True if the corresponding element in x is less than or equal to the corresponding element in y, otherwise False.\n\nequal\n\nequal[type: DType, simd_width: Int](x: SIMD[type, simd_width], y: SIMD[type, simd_width]) -> SIMD[bool, simd_width]\n\nPerforms elementwise check of whether values in x are equal to values in y.\n\nAn element of the result SIMD vector will be True if the corresponding element in x is equal to the corresponding element in y, and False otherwise.\n\nParameters:\n\n​type (DType): The dtype of the input SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, simd_width]): First SIMD vector to compare.\n​y (SIMD[type, simd_width]): Second SIMD vector to compare.\n\nReturns:\n\nA SIMD vector containing True if the corresponding element in x is equal to the corresponding element in y, otherwise False.\n\nlogical_and\n\nlogical_and[simd_width: Int](x: SIMD[bool, simd_width], y: SIMD[bool, simd_width]) -> SIMD[bool, simd_width]\n\nPerforms elementwise logical And operation.\n\nAn element of the result SIMD vector will be True if the corresponding elements in x and y are both True, and False otherwise.\n\nParameters:\n\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[bool, simd_width]): First SIMD vector to perform the And operation.\n​y (SIMD[bool, simd_width]): Second SIMD vector to perform the And operation.\n\nReturns:\n\nA SIMD vector containing True if the corresponding elements in x and y are both True, otherwise False.\n\nlogical_not\n\nlogical_not[simd_width: Int](x: SIMD[bool, simd_width]) -> SIMD[bool, simd_width]\n\nPerforms elementwise logical Not operation.\n\nAn element of the result SIMD vector will be True if the corresponding element in x is True, and False otherwise.\n\nParameters:\n\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[bool, simd_width]): SIMD vector to perform the Not operation.\n\nReturns:\n\nA SIMD vector containing True if the corresponding element in x is True, otherwise False.\n\nlogical_xor\n\nlogical_xor[simd_width: Int](x: SIMD[bool, simd_width], y: SIMD[bool, simd_width]) -> SIMD[bool, simd_width]\n\nPerforms elementwise logical Xor operation.\n\nAn element of the result SIMD vector will be True if only one of the corresponding elements in x and y is True, and False otherwise.\n\nParameters:\n\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[bool, simd_width]): First SIMD vector to perform the Xor operation.\n​y (SIMD[bool, simd_width]): Second SIMD vector to perform the Xor operation.\n\nReturns:\n\nA SIMD vector containing True if only one of the corresponding elements in x and y is True, otherwise False.\n\nnot_equal\n\nnot_equal[type: DType, simd_width: Int](x: SIMD[type, simd_width], y: SIMD[type, simd_width]) -> SIMD[bool, simd_width]\n\nPerforms elementwise check of whether values in x are not equal to values in y.\n\nAn element of the result SIMD vector will be True if the corresponding element in x is not equal to the corresponding element in y, and False otherwise.\n\nParameters:\n\n​type (DType): The dtype of the input SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, simd_width]): First SIMD vector to compare.\n​y (SIMD[type, simd_width]): Second SIMD vector to compare.\n\nReturns:\n\nA SIMD vector containing True if the corresponding element in x is not equal to the corresponding element in y, otherwise False.\n\nselect\n\nselect[type: DType, simd_width: Int](cond: SIMD[bool, simd_width], true_case: SIMD[type, simd_width], false_case: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nSelects the values of the true_case or the false_case based on the input boolean values of the given SIMD vector.\n\nParameters:\n\n​type (DType): The element type of the input and output SIMD vectors.\n​simd_width (Int): Width of the SIMD vectors we are comparing.\n\nArgs:\n\n​cond (SIMD[bool, simd_width]): The vector of bools to check.\n​true_case (SIMD[type, simd_width]): The values selected if the positional value is True.\n​false_case (SIMD[type, simd_width]): The values selected if the positional value is False.\n\nReturns:\n\nA new vector of the form [true_case[i] if cond[i] else false_case[i] in enumerate(self)].\n\nmax\n\nmax(x: Int, y: Int) -> Int\n\nGets the maximum of two integers.\n\nArgs:\n\n​x (Int): Integer input to max.\n​y (Int): Integer input to max.\n\nReturns:\n\nMaximum of x and y.\n\nmax[type: DType, simd_width: Int](x: SIMD[type, simd_width], y: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nPerforms elementwise maximum of x and y.\n\nAn element of the result SIMD vector will be the maximum of the corresponding elements in x and y.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, simd_width]): First SIMD vector.\n​y (SIMD[type, simd_width]): Second SIMD vector.\n\nReturns:\n\nA SIMD vector containing the elementwise maximum of x and y.\n\nmin\n\nmin(x: Int, y: Int) -> Int\n\nGets the minimum of two integers.\n\nArgs:\n\n​x (Int): Integer input to max.\n​y (Int): Integer input to max.\n\nReturns:\n\nMinimum of x and y.\n\nmin[type: DType, simd_width: Int](x: SIMD[type, simd_width], y: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nGets the elementwise minimum of x and y.\n\nAn element of the result SIMD vector will be the minimum of the corresponding elements in x and y.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​x (SIMD[type, simd_width]): First SIMD vector.\n​y (SIMD[type, simd_width]): Second SIMD vector.\n\nReturns:\n\nA SIMD vector containing the elementwise minimum of x and y.\n\npow\n\npow[type: DType, simd_width: Int](lhs: SIMD[type, simd_width], rhs: Int) -> SIMD[type, simd_width]\n\nComputes the pow of the inputs.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​lhs (SIMD[type, simd_width]): The first input argument.\n​rhs (Int): The second input argument.\n\nReturns:\n\nThe pow of the inputs.\n\npow[lhs_type: DType, rhs_type: DType, simd_width: Int](lhs: SIMD[lhs_type, simd_width], rhs: SIMD[rhs_type, simd_width]) -> SIMD[lhs_type, simd_width]\n\nComputes elementwise power of a floating point type raised to another floating point type.\n\nAn element of the result SIMD vector will be the result of raising the corresponding element of lhs to the corresponding element of rhs.\n\nConstraints:\n\nrhs_type and lhs_type must be the same, and must be floating point types.\n\nParameters:\n\n​lhs_type (DType): The dtype of the lhs SIMD vector.\n​rhs_type (DType): The dtype of the rhs SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vectors.\n\nArgs:\n\n​lhs (SIMD[lhs_type, simd_width]): Base of the power operation.\n​rhs (SIMD[rhs_type, simd_width]): Exponent of the power operation.\n\nReturns:\n\nA SIMD vector containing elementwise lhs raised to the power of rhs.\n\npow[n: Int, type: DType, simd_width: Int](x: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the elementwise power where the exponent is an integer known at compile time.\n\nConstraints:\n\nn must be a signed si32 type.\n\nParameters:\n\n​n (Int): Exponent of the power operation.\n​type (DType): The dtype of the x SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vectors.\n\nArgs:\n\n​x (SIMD[type, simd_width]): Base of the power operation.\n\nReturns:\n\nA SIMD vector containing elementwise x raised to the power of n.\n\ndiv_ceil\n\ndiv_ceil(numerator: Int, denominator: Int) -> Int\n\nDivides an integer by another integer, and round up to the nearest integer.\n\nConstraints:\n\nWill raise an exception if denominator is zero.\n\nArgs:\n\n​numerator (Int): The numerator.\n​denominator (Int): The denominator.\n\nReturns:\n\nThe ceiling of numerator divided by denominator.\n\nalign_down\n\nalign_down(value: Int, alignment: Int) -> Int\n\nReturns the closest multiple of alignment that is less than or equal to value.\n\nConstraints:\n\nWill raise an exception if the alignment is zero.\n\nArgs:\n\n​value (Int): The value to align.\n​alignment (Int): Value to align to.\n\nReturns:\n\nClosest multiple of the alignment that is less than or equal to the input value. In other words, floor(value / alignment) * alignment.\n\nalign_down_residual\n\nalign_down_residual(value: Int, alignment: Int) -> Int\n\nReturns the remainder after aligning down value to alignment.\n\nConstraints:\n\nWill raise an exception if the alignment is zero.\n\nArgs:\n\n​value (Int): The value to align.\n​alignment (Int): Value to align to.\n\nReturns:\n\nThe remainder after aligning down value to the closest multiple of alignment. In other words, value - align_down(value, alignment).\n\nalign_up\n\nalign_up(value: Int, alignment: Int) -> Int\n\nReturns the closest multiple of alignment that is greater than or equal to value.\n\nConstraints:\n\nWill raise an exception if the alignment is zero.\n\nArgs:\n\n​value (Int): The value to align.\n​alignment (Int): Value to align to.\n\nReturns:\n\nClosest multiple of the alignment that is greater than or equal to the input value. In other words, ceiling(value / alignment) * alignment.\n\nacos\n\nacos[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the acos of the inputs.\n\nConstraints:\n\nThe input must be a floating point type.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​arg (SIMD[type, simd_width]): The input argument.\n\nReturns:\n\nThe acos of the input.\n\nasin\n\nasin[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the asin of the inputs.\n\nConstraints:\n\nThe input must be of floating point type.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​arg (SIMD[type, simd_width]): The input argument.\n\nReturns:\n\nThe asin of the input.\n\natan\n\natan[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the atan of the inputs.\n\nConstraints:\n\nThe input must be of floating point type.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​arg (SIMD[type, simd_width]): The input argument.\n\nReturns:\n\nThe atan of the input.\n\natan2\n\natan2[type: DType, simd_width: Int](arg0: SIMD[type, simd_width], arg1: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the atan2 of the inputs.\n\nConstraints:\n\nThe inputs must be of floating point type.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​arg0 (SIMD[type, simd_width]): The first input argument.\n​arg1 (SIMD[type, simd_width]): The second input argument.\n\nReturns:\n\nThe atan2 of the inputs.\n\ncos\n\ncos[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the cos of the inputs.\n\nConstraints:\n\nThe input must be of floating point type.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​arg (SIMD[type, simd_width]): The input argument.\n\nReturns:\n\nThe cos of the input.\n\nsin\n\nsin[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the sin of the inputs.\n\nConstraints:\n\nThe input must be of floating point type.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​arg (SIMD[type, simd_width]): The input argument.\n\nReturns:\n\nThe sin of the input.\n\ntan\n\ntan[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the tan of the inputs.\n\nConstraints:\n\nThe input must be of floating point type.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​arg (SIMD[type, simd_width]): The input argument.\n\nReturns:\n\nThe tan of the input.\n\nacosh\n\nacosh[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the acosh of the inputs.\n\nConstraints:\n\nThe input must be of floating point type.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​arg (SIMD[type, simd_width]): The input argument.\n\nReturns:\n\nThe acosh of the input.\n\nasinh\n\nasinh[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the asinh of the inputs.\n\nConstraints:\n\nThe input must be of floating point type.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​arg (SIMD[type, simd_width]): The input argument.\n\nReturns:\n\nThe asinh of the input.\n\natanh\n\natanh[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the atanh of the inputs.\n\nConstraints:\n\nThe input must be of floating point type.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​arg (SIMD[type, simd_width]): The input argument.\n\nReturns:\n\nThe atanh of the input.\n\ncosh\n\ncosh[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the cosh of the inputs.\n\nConstraints:\n\nThe input must be of floating point type.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​arg (SIMD[type, simd_width]): The input argument.\n\nReturns:\n\nThe cosh of the input.\n\nsinh\n\nsinh[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the sinh of the inputs.\n\nConstraints:\n\nThe input must be of floating point type.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​arg (SIMD[type, simd_width]): The input argument.\n\nReturns:\n\nThe sinh of the input.\n\nexpm1\n\nexpm1[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the expm1 of the inputs.\n\nConstraints:\n\nThe input must be of floating point type.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​arg (SIMD[type, simd_width]): The input argument.\n\nReturns:\n\nThe expm1 of the input.\n\nlog10\n\nlog10[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the log10 of the inputs.\n\nConstraints:\n\nThe input must be of floating point type.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​arg (SIMD[type, simd_width]): The input argument.\n\nReturns:\n\nThe log10 of the input.\n\nlog1p\n\nlog1p[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the log1p of the inputs.\n\nConstraints:\n\nThe input must be of floating point type.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​arg (SIMD[type, simd_width]): The input argument.\n\nReturns:\n\nThe log1p of the input.\n\nlogb\n\nlogb[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the logb of the inputs.\n\nConstraints:\n\nThe input must be of floating point type.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​arg (SIMD[type, simd_width]): The input argument.\n\nReturns:\n\nThe logb of the input.\n\ncbrt\n\ncbrt[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the cbrt of the inputs.\n\nConstraints:\n\nThe input must be of floating point type.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​arg (SIMD[type, simd_width]): The input argument.\n\nReturns:\n\nThe cbrt of the input.\n\nhypot\n\nhypot[type: DType, simd_width: Int](arg0: SIMD[type, simd_width], arg1: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the hypot of the inputs.\n\nConstraints:\n\nThe inputs must be of floating point type.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​arg0 (SIMD[type, simd_width]): The first input argument.\n​arg1 (SIMD[type, simd_width]): The second input argument.\n\nReturns:\n\nThe hypot of the inputs.\n\nerfc\n\nerfc[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the erfc of the inputs.\n\nConstraints:\n\nThe input must be of floating point type.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​arg (SIMD[type, simd_width]): The input argument.\n\nReturns:\n\nThe erfc of the input.\n\nlgamma\n\nlgamma[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the lgamma of the inputs.\n\nConstraints:\n\nThe input must be of floating point type.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​arg (SIMD[type, simd_width]): The input argument.\n\nReturns:\n\nThe lgamma of the input.\n\ntgamma\n\ntgamma[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the tgamma of the inputs.\n\nConstraints:\n\nThe input must be of floating point type.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​arg (SIMD[type, simd_width]): The input argument.\n\nReturns:\n\nThe tgamma of the input.\n\nnearbyint\n\nnearbyint[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the nearbyint of the inputs.\n\nConstraints:\n\nThe input must be of floating point type.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​arg (SIMD[type, simd_width]): The input argument.\n\nReturns:\n\nThe nearbyint of the input.\n\nrint\n\nrint[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the rint of the inputs.\n\nConstraints:\n\nThe input must be of floating point type.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​arg (SIMD[type, simd_width]): The input argument.\n\nReturns:\n\nThe rint of the input.\n\nremainder\n\nremainder[type: DType, simd_width: Int](arg0: SIMD[type, simd_width], arg1: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the remainder of the inputs.\n\nConstraints:\n\nThe inputs must be of floating point type.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​arg0 (SIMD[type, simd_width]): The first input argument.\n​arg1 (SIMD[type, simd_width]): The second input argument.\n\nReturns:\n\nThe remainder of the inputs.\n\nnextafter\n\nnextafter[type: DType, simd_width: Int](arg0: SIMD[type, simd_width], arg1: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the nextafter of the inputs.\n\nConstraints:\n\nThe inputs must be of floating point type.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​arg0 (SIMD[type, simd_width]): The first input argument.\n​arg1 (SIMD[type, simd_width]): The second input argument.\n\nReturns:\n\nThe nextafter of the inputs.\n\nj0\n\nj0[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the j0 of the inputs.\n\nConstraints:\n\nThe input must be of floating point type.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​arg (SIMD[type, simd_width]): The input argument.\n\nReturns:\n\nThe j0 of the input.\n\nj1\n\nj1[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the j1 of the inputs.\n\nConstraints:\n\nThe input must be of floating point type.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​arg (SIMD[type, simd_width]): The input argument.\n\nReturns:\n\nThe j1 of the input.\n\ny0\n\ny0[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the y0 of the inputs.\n\nConstraints:\n\nThe input must be of floating point type.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​arg (SIMD[type, simd_width]): The input argument.\n\nReturns:\n\nThe y0 of the input.\n\ny1\n\ny1[type: DType, simd_width: Int](arg: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the y1 of the inputs.\n\nConstraints:\n\nThe input must be of floating point type.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​arg (SIMD[type, simd_width]): The input argument.\n\nReturns:\n\nThe y1 of the input.\n\nscalb\n\nscalb[type: DType, simd_width: Int](arg0: SIMD[type, simd_width], arg1: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the scalb of the inputs.\n\nConstraints:\n\nThe inputs must be of floating point type.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​arg0 (SIMD[type, simd_width]): The first input argument.\n​arg1 (SIMD[type, simd_width]): The second input argument.\n\nReturns:\n\nThe scalb of the inputs.\n\ngcd\n\ngcd(a: Int, b: Int) -> Int\n\nComputes the greatest common divisor of two integers.\n\nConstraints:\n\nThe inputs must be non-negative integers.\n\nArgs:\n\n​a (Int): The first input argument.\n​b (Int): The second input argument.\n\nReturns:\n\nThe gcd of the inputs.\n\nlcm\n\nlcm(a: Int, b: Int) -> Int\n\nComputes the least common divisor of two integers.\n\nConstraints:\n\nThe inputs must be non-negative integers.\n\nArgs:\n\n​a (Int): The first input argument.\n​b (Int): The second input argument.\n\nReturns:\n\nThe lcm of the inputs.\n\nfactorial\n\nfactorial(n: Int) -> Int\n\nComputes the factorial of the integer.\n\nArgs:\n\n​n (Int): The input value.\n\nReturns:\n\nThe factorial of the input.\n\nnan\n\nnan[type: DType]() -> SIMD[type, 1]\n\nGets a NaN value for the given dtype.\n\nConstraints:\n\nCan only be used for FP dtypes.\n\nParameters:\n\n​type (DType): The value dtype.\n\nReturns:\n\nThe NaN value of the given dtype.\n\nisnan\n\nisnan[type: DType, simd_width: Int](val: SIMD[type, simd_width]) -> SIMD[bool, simd_width]\n\nChecks if the value is Not a Number (NaN).\n\nParameters:\n\n​type (DType): The value dtype.\n​simd_width (Int): The width of the SIMD vector.\n\nArgs:\n\n​val (SIMD[type, simd_width]): The value to check.\n\nReturns:\n\nTrue if val is NaN and False otherwise.\n\ndivmod\n\ndivmod(lhs: Int, rhs: Int) -> StaticIntTuple[2]\n\nComputes both the quotient and remainder using integer division.\n\nArgs:\n\n​lhs (Int): The value of the left hand side.\n​rhs (Int): The value of the right hand side.\n\nReturns:\n\nThe quotient and remainder as a tuple (lhs // rhs, lhs % rhs).\n\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - memory",
    "url": "https://docs.modular.com/mojo/stdlib/memory/memory.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nmemory\nbuffer\nmemory\nunsafe\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nmemcmp\nmemcpy\nmemset\nmemset_zero\nstack_allocation\nmemory\n\nModule\n\nDefines functions for memory manipulations.\n\nYou can import these APIs from the memory package. For example:\n\nfrom memory import memcmp\nmemcmp\n\nmemcmp[type: DType, address_space: AddressSpace](s1: DTypePointer[type, address_space], s2: DTypePointer[type, address_space], count: Int) -> Int\n\nCompares two buffers. Both strings are assumed to be of the same length.\n\nParameters:\n\n​type (DType): The element dtype.\n​address_space (AddressSpace): The address space of the pointer.\n\nArgs:\n\n​s1 (DTypePointer[type, address_space]): The first buffer address.\n​s2 (DTypePointer[type, address_space]): The second buffer address.\n​count (Int): The number of elements in the buffers.\n\nReturns:\n\nReturns 0 if the bytes buffers are identical, 1 if s1 > s2, and -1 if s1 < s2. The comparison is performed by the first different byte in the buffer.\n\nmemcmp[type: AnyRegType, address_space: AddressSpace](s1: Pointer[*\"type\", address_space], s2: Pointer[*\"type\", address_space], count: Int) -> Int\n\nCompares two buffers. Both strings are assumed to be of the same length.\n\nParameters:\n\n​type (AnyRegType): The element type.\n​address_space (AddressSpace): The address space of the pointer.\n\nArgs:\n\n​s1 (Pointer[*\"type\", address_space]): The first buffer address.\n​s2 (Pointer[*\"type\", address_space]): The second buffer address.\n​count (Int): The number of elements in the buffers.\n\nReturns:\n\nReturns 0 if the bytes strings are identical, 1 if s1 > s2, and -1 if s1 < s2. The comparison is performed by the first different byte in the byte strings.\n\nmemcpy\n\nmemcpy[type: AnyRegType, address_space: AddressSpace](dest: Pointer[*\"type\", address_space], src: Pointer[*\"type\", address_space], count: Int)\n\nCopies a memory area.\n\nParameters:\n\n​type (AnyRegType): The element type.\n​address_space (AddressSpace): The address space of the pointer.\n\nArgs:\n\n​dest (Pointer[*\"type\", address_space]): The destination pointer.\n​src (Pointer[*\"type\", address_space]): The source pointer.\n​count (Int): The number of elements to copy.\n\nmemcpy[type: DType, address_space: AddressSpace](dest: DTypePointer[type, address_space], src: DTypePointer[type, address_space], count: Int)\n\nCopies a memory area.\n\nParameters:\n\n​type (DType): The element dtype.\n​address_space (AddressSpace): The address space of the pointer.\n\nArgs:\n\n​dest (DTypePointer[type, address_space]): The destination pointer.\n​src (DTypePointer[type, address_space]): The source pointer.\n​count (Int): The number of elements to copy (not bytes!).\n\nmemcpy[type: DType, size: Dim, address_space: AddressSpace](dest: Buffer[size, type, address_space], src: Buffer[size, type, address_space])\n\nCopies a memory buffer from src to dest.\n\nParameters:\n\n​type (DType): The element dtype.\n​size (Dim): Number of elements in the buffer.\n​address_space (AddressSpace): The address space of the pointer.\n\nArgs:\n\n​dest (Buffer[size, type, address_space]): The destination buffer.\n​src (Buffer[size, type, address_space]): The source buffer.\nmemset\n\nmemset[type: DType, address_space: AddressSpace](ptr: DTypePointer[type, address_space], value: SIMD[ui8, 1], count: Int)\n\nFills memory with the given value.\n\nParameters:\n\n​type (DType): The element dtype.\n​address_space (AddressSpace): The address space of the pointer.\n\nArgs:\n\n​ptr (DTypePointer[type, address_space]): Pointer to the beginning of the memory block to fill.\n​value (SIMD[ui8, 1]): The value to fill with.\n​count (Int): Number of elements to fill (in elements, not bytes).\n\nmemset[type: AnyRegType, address_space: AddressSpace](ptr: Pointer[*\"type\", address_space], value: SIMD[ui8, 1], count: Int)\n\nFills memory with the given value.\n\nParameters:\n\n​type (AnyRegType): The element dtype.\n​address_space (AddressSpace): The address space of the pointer.\n\nArgs:\n\n​ptr (Pointer[*\"type\", address_space]): Pointer to the beginning of the memory block to fill.\n​value (SIMD[ui8, 1]): The value to fill with.\n​count (Int): Number of elements to fill (in elements, not bytes).\nmemset_zero\n\nmemset_zero[type: DType, address_space: AddressSpace](ptr: DTypePointer[type, address_space], count: Int)\n\nFills memory with zeros.\n\nParameters:\n\n​type (DType): The element dtype.\n​address_space (AddressSpace): The address space of the pointer.\n\nArgs:\n\n​ptr (DTypePointer[type, address_space]): Pointer to the beginning of the memory block to fill.\n​count (Int): Number of elements to set (in elements, not bytes).\n\nmemset_zero[type: AnyRegType, address_space: AddressSpace](ptr: Pointer[*\"type\", address_space], count: Int)\n\nFills memory with zeros.\n\nParameters:\n\n​type (AnyRegType): The element type.\n​address_space (AddressSpace): The address space of the pointer.\n\nArgs:\n\n​ptr (Pointer[*\"type\", address_space]): Pointer to the beginning of the memory block to fill.\n​count (Int): Number of elements to fill (in elements, not bytes).\nstack_allocation\n\nstack_allocation[count: Int, type: DType, alignment: Int, address_space: AddressSpace]() -> DTypePointer[type, address_space]\n\nAllocates data buffer space on the stack given a data type and number of elements.\n\nParameters:\n\n​count (Int): Number of elements to allocate memory for.\n​type (DType): The data type of each element.\n​alignment (Int): Address alignment of the allocated data.\n​address_space (AddressSpace): The address space of the pointer.\n\nReturns:\n\nA data pointer of the given type pointing to the allocated space.\n\nstack_allocation[count: Int, type: AnyRegType, alignment: Int, address_space: AddressSpace]() -> Pointer[*\"type\", address_space]\n\nAllocates data buffer space on the stack given a data type and number of elements.\n\nParameters:\n\n​count (Int): Number of elements to allocate memory for.\n​type (AnyRegType): The data type of each element.\n​alignment (Int): Address alignment of the allocated data.\n​address_space (AddressSpace): The address space of the pointer.\n\nReturns:\n\nA data pointer of the given type pointing to the allocated space.\n\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - buffer",
    "url": "https://docs.modular.com/mojo/stdlib/memory/buffer.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nmemory\nbuffer\nmemory\nunsafe\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nBuffer\n__init__\n__getitem__\n__setitem__\n__len__\nsimd_load\naligned_simd_load\nsimd_store\naligned_simd_store\nsimd_nt_store\nprefetch\nbytecount\nzero\nsimd_fill\nfill\ntofile\naligned_stack_allocation\nstack_allocation\nNDBuffer\nDynamicRankBuffer\npartial_simd_load\npartial_simd_store\nprod_dims\nbuffer\n\nModule\n\nImplements the Buffer class.\n\nYou can import these APIs from the memory package. For example:\n\nfrom memory.buffer import Buffer\nBuffer\n\nDefines a Buffer which can be parametrized on a static size and Dtype.\n\nThe Buffer does not own its underlying pointer.\n\nParameters:\n\n​size (Dim): The static size (if known) of the Buffer.\n​type (DType): The element type of the Buffer.\n​address_space (AddressSpace): The address space of the Buffer.\n\nFields:\n\n​data (DTypePointer[type, address_space]): The underlying data pointer of the data.\n​dynamic_size (Int): The dynamic size of the buffer.\n​dtype (DType): The dynamic data type of the buffer.\n\nFunctions:\n\n__init__\n\n__init__() -> Self\n\nDefault initializer for Buffer. By default the fields are all initialized to 0.\n\nReturns:\n\nThe NDBuffer object.\n\n__init__(ptr: Pointer[SIMD[type, 1], address_space]) -> Self\n\nConstructs a Buffer with statically known size and type.\n\nConstraints:\n\nThe size is known.\n\nArgs:\n\n​ptr (Pointer[SIMD[type, 1], address_space]): Pointer to the data.\n\nReturns:\n\nThe buffer object.\n\n__init__(ptr: DTypePointer[type, address_space]) -> Self\n\nConstructs a Buffer with statically known size and type.\n\nConstraints:\n\nThe size is known.\n\nArgs:\n\n​ptr (DTypePointer[type, address_space]): Pointer to the data.\n\nReturns:\n\nThe buffer object.\n\n__init__(ptr: Pointer[SIMD[type, 1], address_space], in_size: Int) -> Self\n\nConstructs a Buffer with statically known type.\n\nConstraints:\n\nThe size is unknown.\n\nArgs:\n\n​ptr (Pointer[SIMD[type, 1], address_space]): Pointer to the data.\n​in_size (Int): Dynamic size of the buffer.\n\nReturns:\n\nThe buffer object.\n\n__init__(ptr: DTypePointer[type, address_space], in_size: Int) -> Self\n\nConstructs a Buffer with statically known type.\n\nConstraints:\n\nThe size is unknown.\n\nArgs:\n\n​ptr (DTypePointer[type, address_space]): Pointer to the data.\n​in_size (Int): Dynamic size of the buffer.\n\nReturns:\n\nThe buffer object.\n\n__getitem__\n\n__getitem__(self: Self, idx: Int) -> SIMD[type, 1]\n\nLoads a single element (SIMD of size 1) from the buffer at the specified index.\n\nArgs:\n\n​idx (Int): The index into the Buffer.\n\nReturns:\n\nThe value at the idx position.\n\n__setitem__\n\n__setitem__(self: Self, idx: Int, val: scalar<#lit.struct.extract<:!kgen.declref<_\"$builtin\"::_\"$dtype\"::_DType, !lit.metatype<_\"$builtin\"::_\"$dtype\"::_DType>> type, \"value\">>)\n\nStores a single value into the buffer at the specified index.\n\nArgs:\n\n​idx (Int): The index into the Buffer.\n​val (scalar<#lit.struct.extract<:!kgen.declref<_\"$builtin\"::_\"$dtype\"::_DType, !lit.metatype<_\"$builtin\"::_\"$dtype\"::_DType>> type, \"value\">>): The value to store.\n\n__setitem__(self: Self, idx: Int, val: SIMD[type, 1])\n\nStores a single value into the buffer at the specified index.\n\nArgs:\n\n​idx (Int): The index into the Buffer.\n​val (SIMD[type, 1]): The value to store.\n__len__\n\n__len__(self: Self) -> Int\n\nGets the size if it is a known constant, otherwise it gets the dynamic_size.\n\nThis method is used by Buffer.__len__ to get the size of the buffer. If the Buffer size is a known constant, then the size is returned. Otherwise, the dynamic_size is returned.\n\nReturns:\n\nThe size if static otherwise dynamic_size.\n\nsimd_load\n\nsimd_load[width: Int](self: Self, idx: Int) -> SIMD[type, width]\n\nLoads a simd value from the buffer at the specified index.\n\nParameters:\n\n​width (Int): The simd_width of the load.\n\nArgs:\n\n​idx (Int): The index into the Buffer.\n\nReturns:\n\nThe simd value starting at the idx position and ending at idx+width.\n\naligned_simd_load\n\naligned_simd_load[width: Int, alignment: Int](self: Self, idx: Int) -> SIMD[type, width]\n\nLoads a simd value from the buffer at the specified index.\n\nParameters:\n\n​width (Int): The simd_width of the load.\n​alignment (Int): The alignment value.\n\nArgs:\n\n​idx (Int): The index into the Buffer.\n\nReturns:\n\nThe simd value starting at the idx position and ending at idx+width.\n\nsimd_store\n\nsimd_store[width: Int](self: Self, idx: Int, val: SIMD[type, width])\n\nStores a simd value into the buffer at the specified index.\n\nParameters:\n\n​width (Int): The width of the simd vector.\n\nArgs:\n\n​idx (Int): The index into the Buffer.\n​val (SIMD[type, width]): The value to store.\naligned_simd_store\n\naligned_simd_store[width: Int, alignment: Int](self: Self, idx: Int, val: SIMD[type, width])\n\nStores a simd value into the buffer at the specified index.\n\nParameters:\n\n​width (Int): The width of the simd vector.\n​alignment (Int): The alignment value.\n\nArgs:\n\n​idx (Int): The index into the Buffer.\n​val (SIMD[type, width]): The value to store.\nsimd_nt_store\n\nsimd_nt_store[width: Int](self: Self, idx: Int, val: SIMD[type, width])\n\nStores a simd value using non-temporal store.\n\nConstraints:\n\nThe address must be properly aligned, 64B for avx512, 32B for avx2, and 16B for avx.\n\nParameters:\n\n​width (Int): The width of the simd vector.\n\nArgs:\n\n​idx (Int): The index into the Buffer.\n​val (SIMD[type, width]): The value to store.\nprefetch\n\nprefetch[params: PrefetchOptions](self: Self, idx: Int)\n\nPrefetches the data at the given index.\n\nParameters:\n\n​params (PrefetchOptions): The prefetch configuration.\n\nArgs:\n\n​idx (Int): The index of the prefetched location.\nbytecount\n\nbytecount(self: Self) -> Int\n\nReturns the size of the Buffer in bytes.\n\nReturns:\n\nThe size of the Buffer in bytes.\n\nzero\n\nzero(self: Self)\n\nSets all bytes of the Buffer to 0.\n\nsimd_fill\n\nsimd_fill[simd_width: Int](self: Self, val: SIMD[type, 1])\n\nAssigns val to all elements in chunks of size simd_width.\n\nParameters:\n\n​simd_width (Int): The simd_width of the fill.\n\nArgs:\n\n​val (SIMD[type, 1]): The value to store.\nfill\n\nfill(self: Self, val: SIMD[type, 1])\n\nAssigns val to all elements in the Buffer.\n\nThe fill is performed in chunks of size N, where N is the native SIMD width of type on the system.\n\nArgs:\n\n​val (SIMD[type, 1]): The value to store.\ntofile\n\ntofile(self: Self, path: Path)\n\nWrite values to a file.\n\nArgs:\n\n​path (Path): Path to the output file.\naligned_stack_allocation\n\nstatic aligned_stack_allocation[alignment: Int]() -> Self\n\nConstructs a buffer instance backed by stack allocated memory space.\n\nParameters:\n\n​alignment (Int): Address alignment requirement for the allocation.\n\nReturns:\n\nConstructed buffer with the allocated space.\n\nstack_allocation\n\nstatic stack_allocation() -> Self\n\nConstructs a buffer instance backed by stack allocated memory space.\n\nReturns:\n\nConstructed buffer with the allocated space.\n\nImplemented Traits:\n\n​Destructable\n​Sized\nNDBuffer\n\nAn N-dimensional Buffer.\n\nNDBuffer can be parametrized on rank, static dimensions and Dtype. It does not own its underlying pointer.\n\nParameters:\n\n​rank (Int): The rank of the buffer.\n​shape (DimList): The static size (if known) of the buffer.\n​type (DType): The element type of the buffer.\n​address_space (AddressSpace): The address space of the buffer.\n\nFields:\n\n​data (DTypePointer[type, address_space]): The underlying data for the buffer. The pointer is not owned by the NDBuffer.\n​dynamic_shape (StaticIntTuple[rank]): The dynamic value of the shape.\n​dynamic_stride (StaticIntTuple[rank]): The dynamic stride of the buffer.\n​is_contiguous (Bool): True if the contents of the buffer are contiguous in memory.\n\nFunctions:\n\n__init__\n\n__init__() -> Self\n\nDefault initializer for NDBuffer. By default the fields are all initialized to 0.\n\nReturns:\n\nThe NDBuffer object.\n\n__init__(ptr: Pointer[SIMD[type, 1], address_space]) -> Self\n\nConstructs an NDBuffer with statically known rank, shapes and type.\n\nConstraints:\n\nThe rank, shapes, and type are known.\n\nArgs:\n\n​ptr (Pointer[SIMD[type, 1], address_space]): Pointer to the data.\n\nReturns:\n\nThe NDBuffer object.\n\n__init__(ptr: DTypePointer[type, address_space]) -> Self\n\nConstructs an NDBuffer with statically known rank, shapes and type.\n\nConstraints:\n\nThe rank, shapes, and type are known.\n\nArgs:\n\n​ptr (DTypePointer[type, address_space]): Pointer to the data.\n\nReturns:\n\nThe NDBuffer object.\n\n__init__(ptr: Pointer[scalar<#lit.struct.extract<:!kgen.declref<_\"$builtin\"::_\"$dtype\"::_DType, !lit.metatype<_\"$builtin\"::_\"$dtype\"::_DType>> type, \"value\">>, address_space], dynamic_shape: StaticIntTuple[rank]) -> Self\n\nConstructs an NDBuffer with statically known rank, but dynamic shapes and type.\n\nConstraints:\n\nThe rank is known.\n\nArgs:\n\n​ptr (Pointer[scalar<#lit.struct.extract<:!kgen.declref<_\"$builtin\"::_\"$dtype\"::_DType, !lit.metatype<_\"$builtin\"::_\"$dtype\"::_DType>> type, \"value\">>, address_space]): Pointer to the data.\n​dynamic_shape (StaticIntTuple[rank]): A static tuple of size ‘rank’ representing shapes.\n\nReturns:\n\nThe NDBuffer object.\n\n__init__(ptr: DTypePointer[type, address_space], dynamic_shape: StaticIntTuple[rank]) -> Self\n\nConstructs an NDBuffer with statically known rank, but dynamic shapes and type.\n\nConstraints:\n\nThe rank is known.\n\nArgs:\n\n​ptr (DTypePointer[type, address_space]): Pointer to the data.\n​dynamic_shape (StaticIntTuple[rank]): A static tuple of size ‘rank’ representing shapes.\n\nReturns:\n\nThe NDBuffer object.\n\n__init__(ptr: Pointer[SIMD[type, 1], address_space], dynamic_shape: StaticIntTuple[rank], dynamic_stride: StaticIntTuple[rank]) -> Self\n\nConstructs a strided NDBuffer with statically known rank, but dynamic shapes and type.\n\nConstraints:\n\nThe rank is known.\n\nArgs:\n\n​ptr (Pointer[SIMD[type, 1], address_space]): Pointer to the data.\n​dynamic_shape (StaticIntTuple[rank]): A static tuple of size ‘rank’ representing shapes.\n​dynamic_stride (StaticIntTuple[rank]): A static tuple of size ‘rank’ representing strides.\n\nReturns:\n\nThe NDBuffer object.\n\n__init__(ptr: DTypePointer[type, address_space], dynamic_shape: StaticIntTuple[rank], dynamic_stride: StaticIntTuple[rank]) -> Self\n\nConstructs a strided NDBuffer with statically known rank, but dynamic shapes and type.\n\nConstraints:\n\nThe rank is known.\n\nArgs:\n\n​ptr (DTypePointer[type, address_space]): Pointer to the data.\n​dynamic_shape (StaticIntTuple[rank]): A static tuple of size ‘rank’ representing shapes.\n​dynamic_stride (StaticIntTuple[rank]): A static tuple of size ‘rank’ representing strides.\n\nReturns:\n\nThe NDBuffer object.\n\n__getitem__\n\n__getitem__(self: Self, *idx: Int) -> SIMD[type, 1]\n\nGets an element from the buffer from the specified index.\n\nArgs:\n\n​idx (*Int): Index of the element to retrieve.\n\nReturns:\n\nThe value of the element.\n\n__getitem__(self: Self, idx: StaticIntTuple[rank]) -> SIMD[type, 1]\n\nGets an element from the buffer from the specified index.\n\nArgs:\n\n​idx (StaticIntTuple[rank]): Index of the element to retrieve.\n\nReturns:\n\nThe value of the element.\n\n__setitem__\n\n__setitem__(self: Self, idx: StaticIntTuple[rank], val: SIMD[type, 1])\n\nStores a single value into the buffer at the specified index.\n\nArgs:\n\n​idx (StaticIntTuple[rank]): The index into the Buffer.\n​val (SIMD[type, 1]): The value to store.\nget_rank\n\nget_rank(self: Self) -> Int\n\nReturns the rank of the buffer.\n\nReturns:\n\nThe rank of NDBuffer.\n\nget_shape\n\nget_shape(self: Self) -> StaticIntTuple[rank]\n\nReturns the shapes of the buffer.\n\nReturns:\n\nA static tuple of size ‘rank’ representing shapes of the NDBuffer.\n\nget_nd_index\n\nget_nd_index(self: Self, idx: Int) -> StaticIntTuple[rank]\n\nComputes the NDBuffer’s ND-index based on the flat index.\n\nArgs:\n\n​idx (Int): The flat index.\n\nReturns:\n\nThe index positions.\n\n__len__\n\n__len__(self: Self) -> Int\n\nComputes the NDBuffer’s number of elements.\n\nReturns:\n\nThe total number of elements in the NDBuffer.\n\nnum_elements\n\nnum_elements(self: Self) -> Int\n\nComputes the NDBuffer’s number of elements.\n\nReturns:\n\nThe total number of elements in the NDBuffer.\n\nsize\n\nsize(self: Self) -> Int\n\nComputes the NDBuffer’s number of elements.\n\nReturns:\n\nThe total number of elements in the NDBuffer.\n\n__str__\n\n__str__(self: Self) -> String\n\nGets the buffer as a string.\n\nReturns:\n\nA compact string of the buffer.\n\n__repr__\n\n__repr__(self: Self) -> String\n\nGets the buffer as a string.\n\nReturns:\n\nA compact string representation of the buffer.\n\nsimd_load\n\nsimd_load[width: Int](self: Self, *idx: Int) -> SIMD[type, width]\n\nLoads a simd value from the buffer at the specified index.\n\nConstraints:\n\nThe buffer must be contiguous or width must be 1.\n\nParameters:\n\n​width (Int): The simd_width of the load.\n\nArgs:\n\n​idx (*Int): The index into the NDBuffer.\n\nReturns:\n\nThe simd value starting at the idx position and ending at idx+width.\n\nsimd_load[width: Int](self: Self, idx: VariadicList[Int]) -> SIMD[type, width]\n\nLoads a simd value from the buffer at the specified index.\n\nConstraints:\n\nThe buffer must be contiguous or width must be 1.\n\nParameters:\n\n​width (Int): The simd_width of the load.\n\nArgs:\n\n​idx (VariadicList[Int]): The index into the NDBuffer.\n\nReturns:\n\nThe simd value starting at the idx position and ending at idx+width.\n\nsimd_load[width: Int](self: Self, idx: StaticIntTuple[rank]) -> SIMD[type, width]\n\nLoads a simd value from the buffer at the specified index.\n\nConstraints:\n\nThe buffer must be contiguous or width must be 1.\n\nParameters:\n\n​width (Int): The simd_width of the load.\n\nArgs:\n\n​idx (StaticIntTuple[rank]): The index into the NDBuffer.\n\nReturns:\n\nThe simd value starting at the idx position and ending at idx+width.\n\nsimd_load[width: Int](self: Self, idx: StaticTuple[rank, Int]) -> SIMD[type, width]\n\nLoads a simd value from the buffer at the specified index.\n\nConstraints:\n\nThe buffer must be contiguous or width must be 1.\n\nParameters:\n\n​width (Int): The simd_width of the load.\n\nArgs:\n\n​idx (StaticTuple[rank, Int]): The index into the NDBuffer.\n\nReturns:\n\nThe simd value starting at the idx position and ending at idx+width.\n\naligned_simd_load\n\naligned_simd_load[width: Int, alignment: Int](self: Self, *idx: Int) -> SIMD[type, width]\n\nLoads a simd value from the buffer at the specified index.\n\nConstraints:\n\nThe buffer must be contiguous or width must be 1.\n\nParameters:\n\n​width (Int): The simd_width of the load.\n​alignment (Int): The alignment value.\n\nArgs:\n\n​idx (*Int): The index into the NDBuffer.\n\nReturns:\n\nThe simd value starting at the idx position and ending at idx+width.\n\naligned_simd_load[width: Int, alignment: Int](self: Self, idx: VariadicList[Int]) -> SIMD[type, width]\n\nLoads a simd value from the buffer at the specified index.\n\nConstraints:\n\nThe buffer must be contiguous or width must be 1.\n\nParameters:\n\n​width (Int): The simd_width of the load.\n​alignment (Int): The alignment value.\n\nArgs:\n\n​idx (VariadicList[Int]): The index into the NDBuffer.\n\nReturns:\n\nThe simd value starting at the idx position and ending at idx+width.\n\naligned_simd_load[width: Int, alignment: Int](self: Self, idx: StaticIntTuple[rank]) -> SIMD[type, width]\n\nLoads a simd value from the buffer at the specified index.\n\nConstraints:\n\nThe buffer must be contiguous or width must be 1.\n\nParameters:\n\n​width (Int): The simd_width of the load.\n​alignment (Int): The alignment value.\n\nArgs:\n\n​idx (StaticIntTuple[rank]): The index into the NDBuffer.\n\nReturns:\n\nThe simd value starting at the idx position and ending at idx+width.\n\naligned_simd_load[width: Int, alignment: Int](self: Self, idx: StaticTuple[rank, Int]) -> SIMD[type, width]\n\nLoads a simd value from the buffer at the specified index.\n\nConstraints:\n\nThe buffer must be contiguous or width must be 1.\n\nParameters:\n\n​width (Int): The simd_width of the load.\n​alignment (Int): The alignment value.\n\nArgs:\n\n​idx (StaticTuple[rank, Int]): The index into the NDBuffer.\n\nReturns:\n\nThe simd value starting at the idx position and ending at idx+width.\n\nsimd_store\n\nsimd_store[width: Int](self: Self, idx: StaticIntTuple[rank], val: SIMD[type, width])\n\nStores a simd value into the buffer at the specified index.\n\nConstraints:\n\nThe buffer must be contiguous or width must be 1.\n\nParameters:\n\n​width (Int): The width of the simd vector.\n\nArgs:\n\n​idx (StaticIntTuple[rank]): The index into the Buffer.\n​val (SIMD[type, width]): The value to store.\n\nsimd_store[width: Int](self: Self, idx: StaticTuple[rank, Int], val: SIMD[type, width])\n\nStores a simd value into the buffer at the specified index.\n\nConstraints:\n\nThe buffer must be contiguous or width must be 1.\n\nParameters:\n\n​width (Int): The width of the simd vector.\n\nArgs:\n\n​idx (StaticTuple[rank, Int]): The index into the Buffer.\n​val (SIMD[type, width]): The value to store.\naligned_simd_store\n\naligned_simd_store[width: Int, alignment: Int](self: Self, idx: StaticIntTuple[rank], val: SIMD[type, width])\n\nStores a simd value into the buffer at the specified index.\n\nConstraints:\n\nThe buffer must be contiguous or width must be 1.\n\nParameters:\n\n​width (Int): The width of the simd vector.\n​alignment (Int): The alignment value.\n\nArgs:\n\n​idx (StaticIntTuple[rank]): The index into the Buffer.\n​val (SIMD[type, width]): The value to store.\n\naligned_simd_store[width: Int, alignment: Int](self: Self, idx: StaticTuple[rank, Int], val: SIMD[type, width])\n\nStores a simd value into the buffer at the specified index.\n\nConstraints:\n\nThe buffer must be contiguous or width must be 1.\n\nParameters:\n\n​width (Int): The width of the simd vector.\n​alignment (Int): The alignment value.\n\nArgs:\n\n​idx (StaticTuple[rank, Int]): The index into the Buffer.\n​val (SIMD[type, width]): The value to store.\nsimd_nt_store\n\nsimd_nt_store[width: Int](self: Self, idx: StaticIntTuple[rank], val: SIMD[type, width])\n\nStores a simd value using non-temporal store.\n\nConstraints:\n\nThe buffer must be contiguous. The address must be properly aligned, 64B for avx512, 32B for avx2, and 16B for avx.\n\nParameters:\n\n​width (Int): The width of the simd vector.\n\nArgs:\n\n​idx (StaticIntTuple[rank]): The index into the Buffer.\n​val (SIMD[type, width]): The value to store.\n\nsimd_nt_store[width: Int](self: Self, idx: StaticTuple[rank, Int], val: SIMD[type, width])\n\nStores a simd value using non-temporal store.\n\nConstraints:\n\nThe buffer must be contiguous. The address must be properly aligned, 64B for avx512, 32B for avx2, and 16B for avx.\n\nParameters:\n\n​width (Int): The width of the simd vector.\n\nArgs:\n\n​idx (StaticTuple[rank, Int]): The index into the Buffer.\n​val (SIMD[type, width]): The value to store.\ndim\n\ndim[index: Int](self: Self) -> Int\n\nGets the buffer dimension at the given index.\n\nParameters:\n\n​index (Int): The number of dimension to get.\n\nReturns:\n\nThe buffer size at the given dimension.\n\ndim(self: Self, index: Int) -> Int\n\nGets the buffer dimension at the given index.\n\nArgs:\n\n​index (Int): The number of dimension to get.\n\nReturns:\n\nThe buffer size at the given dimension.\n\nstride\n\nstride(self: Self, index: Int) -> Int\n\nGets the buffer stride at the given index.\n\nArgs:\n\n​index (Int): The number of dimension to get the stride for.\n\nReturns:\n\nThe stride at the given dimension.\n\nflatten\n\nflatten(self: Self) -> Buffer[Dim(), type, address_space]\n\nConstructs a flattened Buffer counterpart for this NDBuffer.\n\nConstraints:\n\nThe buffer must be contiguous.\n\nReturns:\n\nConstructed Buffer object.\n\nmake_dims_unknown\n\nmake_dims_unknown(self: Self) -> NDBuffer[rank, create_unknown[$builtin::$int::Int][rank](), type, address_space]\n\nRebinds the NDBuffer to one with unknown shape.\n\nReturns:\n\nThe rebound NDBuffer with unknown shape.\n\nbytecount\n\nbytecount(self: Self) -> Int\n\nReturns the size of the NDBuffer in bytes.\n\nReturns:\n\nThe size of the NDBuffer in bytes.\n\nzero\n\nzero(self: Self)\n\nSets all bytes of the NDBuffer to 0.\n\nConstraints:\n\nThe buffer must be contiguous.\n\nsimd_fill\n\nsimd_fill[simd_width: Int](self: Self, val: SIMD[type, 1])\n\nAssigns val to all elements in chunks of size simd_width.\n\nParameters:\n\n​simd_width (Int): The simd_width of the fill.\n\nArgs:\n\n​val (SIMD[type, 1]): The value to store.\ntofile\n\ntofile(self: Self, path: Path)\n\nWrite values to a file.\n\nArgs:\n\n​path (Path): Path to the output file.\nfill\n\nfill(self: Self, val: SIMD[type, 1])\n\nAssigns val to all elements in the Buffer.\n\nThe fill is performed in chunks of size N, where N is the native SIMD width of type on the system.\n\nArgs:\n\n​val (SIMD[type, 1]): The value to store.\naligned_stack_allocation\n\nstatic aligned_stack_allocation[alignment: Int]() -> Self\n\nConstructs an NDBuffer instance backed by stack allocated memory space.\n\nParameters:\n\n​alignment (Int): Address alignment requirement for the allocation.\n\nReturns:\n\nConstructed NDBuffer with the allocated space.\n\nstack_allocation\n\nstatic stack_allocation() -> Self\n\nConstructs an NDBuffer instance backed by stack allocated memory space.\n\nReturns:\n\nConstructed NDBuffer with the allocated space.\n\nprefetch\n\nprefetch[params: PrefetchOptions](self: Self, *idx: Int)\n\nPrefetches the data at the given index.\n\nParameters:\n\n​params (PrefetchOptions): The prefetch configuration.\n\nArgs:\n\n​idx (*Int): The N-D index of the prefetched location.\n\nprefetch[params: PrefetchOptions](self: Self, indices: StaticIntTuple[rank])\n\nPrefetches the data at the given index.\n\nParameters:\n\n​params (PrefetchOptions): The prefetch configuration.\n\nArgs:\n\n​indices (StaticIntTuple[rank]): The N-D index of the prefetched location.\n\nImplemented Traits:\n\n​Destructable\n​Sized\n​Stringable\nDynamicRankBuffer\n\nDynamicRankBuffer represents a buffer with unknown rank, shapes and dtype.\n\nIt is not as efficient as the statically ranked buffer, but is useful when interacting with external functions. In particular the shape is represented as a fixed (ie _MAX_RANK) array of dimensions to simplify the ABI.\n\nFields:\n\n​data (DTypePointer[invalid, 0]): The pointer to the buffer.\n​rank (Int): The buffer rank. Has a max value of _MAX_RANK.\n​shape (StaticIntTuple[8]): The dynamic shape of the buffer.\n​type (DType): The dynamic dtype of the buffer.\n\nFunctions:\n\n__init__\n\n__init__(data: DTypePointer[invalid, 0], rank: Int, shape: StaticIntTuple[8], type: DType) -> Self\n\nConstruct DynamicRankBuffer.\n\nArgs:\n\n​data (DTypePointer[invalid, 0]): Pointer to the underlying data.\n​rank (Int): Rank of the buffer.\n​shape (StaticIntTuple[8]): Shapes of the buffer.\n​type (DType): dtype of the buffer.\n\nReturns:\n\nConstructed DynamicRankBuffer.\n\nto_buffer\n\nto_buffer[type: DType](self: Self) -> Buffer[Dim(), type, 0]\n\nCasts DynamicRankBuffer to Buffer.\n\nParameters:\n\n​type (DType): dtype of the buffer.\n\nReturns:\n\nConstructed Buffer.\n\nto_ndbuffer\n\nto_ndbuffer[rank: Int, type: DType](self: Self) -> NDBuffer[rank, create_unknown[$builtin::$int::Int][rank](), type, 0]\n\nCasts the buffer to NDBuffer.\n\nConstraints:\n\nRank of DynamicRankBuffer must equal rank of NDBuffer.\n\nParameters:\n\n​rank (Int): Rank of the buffer.\n​type (DType): dtype of the buffer.\n\nReturns:\n\nConstructed NDBuffer.\n\nto_ndbuffer[rank: Int, type: DType](self: Self, stride: StaticIntTuple[rank]) -> NDBuffer[rank, create_unknown[$builtin::$int::Int][rank](), type, 0]\n\nCasts the buffer to NDBuffer.\n\nConstraints:\n\nRank of DynamicRankBuffer must equal rank of NDBuffer.\n\nParameters:\n\n​rank (Int): Rank of the buffer.\n​type (DType): dtype of the buffer.\n\nArgs:\n\n​stride (StaticIntTuple[rank]): Strides of the buffer.\n\nReturns:\n\nConstructed NDBuffer.\n\nrank_dispatch\n\nrank_dispatch[func: fn[Int]() capturing -> None](self: Self)\n\nDispatches the function call based on buffer rank.\n\nConstraints:\n\nRank must be positive and less or equal to 8.\n\nParameters:\n\n​func (fn[Int]() capturing -> None): Function to dispatch. The function should be parametrized on an index parameter, which will be used for rank when the function will be called.\n\nrank_dispatch[func: fn[Int]() capturing -> None](self: Self, out_chain: OutputChainPtr)\n\nDispatches the function call based on buffer rank.\n\nConstraints:\n\nRank must be positive and less or equal to 8.\n\nParameters:\n\n​func (fn[Int]() capturing -> None): Function to dispatch. The function should be parametrized on an index parameter, which will be used for rank when the function will be called.\n\nArgs:\n\n​out_chain (OutputChainPtr): The output chain.\nnum_elements\n\nnum_elements(self: Self) -> Int\n\nGets number of elements in the buffer.\n\nReturns:\n\nThe number of elements in the buffer.\n\nget_shape\n\nget_shape[rank: Int](self: Self) -> StaticIntTuple[rank]\n\nGets a static tuple representing the buffer shape.\n\nParameters:\n\n​rank (Int): Rank of the buffer.\n\nReturns:\n\nA static tuple of size ‘Rank’ filled with buffer shapes.\n\ndim\n\ndim(self: Self, idx: Int) -> Int\n\nGets given dimension.\n\nArgs:\n\n​idx (Int): The dimension index.\n\nReturns:\n\nThe buffer size on the given dimension.\n\npartial_simd_load\n\npartial_simd_load[type: DType, width: Int](storage: DTypePointer[type, 0], lbound: Int, rbound: Int, pad_value: SIMD[type, 1]) -> SIMD[type, width]\n\nLoads a vector with dynamic bound.\n\nOut of bound data will be filled with pad value. Data is valid if lbound <= idx < rbound for idx from 0 to (simd_width-1). For example:\n\naddr 0  1  2  3\ndata x 42 43  x\n\npartial_simd_load[4](addr0,1,3) #gives [0 42 43 0]\n\nParameters:\n\n​type (DType): The underlying dtype of computation.\n​width (Int): The system simd vector size.\n\nArgs:\n\n​storage (DTypePointer[type, 0]): Pointer to the address to perform load.\n​lbound (Int): Lower bound of valid index within simd (inclusive).\n​rbound (Int): Upper bound of valid index within simd (non-inclusive).\n​pad_value (SIMD[type, 1]): Value to fill for out of bound indices.\n\nReturns:\n\nThe SIMD vector loaded and zero-filled.\n\npartial_simd_store\n\npartial_simd_store[type: DType, width: Int](storage: DTypePointer[type, 0], lbound: Int, rbound: Int, data: SIMD[type, width])\n\nStores a vector with dynamic bound.\n\nOut of bound data will ignored. Data is valid if lbound <= idx < rbound for idx from 0 to (simd_width-1).\n\ne.g. addr 0 1 2 3 data 0 0 0 0\n\npartial_simd_load[4](addr0,1,3, [-1, 42,43, -1]) #gives [0 42 43 0]\n\nParameters:\n\n​type (DType): The underlying dtype of computation.\n​width (Int): The system simd vector size.\n\nArgs:\n\n​storage (DTypePointer[type, 0]): Pointer to the address to perform load.\n​lbound (Int): Lower bound of valid index within simd (inclusive).\n​rbound (Int): Upper bound of valid index within simd (non-inclusive).\n​data (SIMD[type, width]): The vector value to store.\nprod_dims\n\nprod_dims[start_dim: Int, end_dim: Int, rank: Int, shape: DimList, type: DType](x: NDBuffer[rank, shape, type, 0]) -> Int\n\nComputes the product of a slice of the given buffer’s dimensions.\n\nParameters:\n\n​start_dim (Int): The index at which to begin computing the product.\n​end_dim (Int): The index at which to stop computing the product.\n​rank (Int): The rank of the NDBuffer.\n​shape (DimList): The shape of the NDBuffer.\n​type (DType): The element-type of the NDBuffer.\n\nArgs:\n\n​x (NDBuffer[rank, shape, type, 0]): The NDBuffer whose dimensions will be multiplied.\n\nReturns:\n\nThe product of the specified slice of the buffer’s dimensions.\n\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - polynomial",
    "url": "https://docs.modular.com/mojo/stdlib/math/polynomial.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nbit\nlimit\nmath\npolynomial\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\npolynomial_evaluate\npolynomial\n\nModule\n\nProvides two implementations for evaluating polynomials.\n\nYou can import these APIs from the math package. For example:\n\nfrom math.polynomial import polynomial_evaluate\npolynomial_evaluate\n\npolynomial_evaluate[simd_width: Int, dtype: DType, coefficients: VariadicList[SIMD[dtype, simd_width]]](x: SIMD[dtype, simd_width]) -> SIMD[dtype, simd_width]\n\nEvaluates the 1st degree polynomial using the passed in value and the specified coefficients.\n\nThese methods evaluate the polynomial using either the Estrin scheme or the Horner scheme. The Estrin scheme is only implemented for polynomials of degrees between 4 and 10. The Horner scheme is implemented for polynomials for any polynomial degree.\n\nParameters:\n\n​simd_width (Int): The simd_width of the computed value.\n​dtype (DType): The dtype of the value.\n​coefficients (VariadicList[SIMD[dtype, simd_width]]): The coefficients.\n\nArgs:\n\n​x (SIMD[dtype, simd_width]): The value to compute the polynomial with.\n\nReturns:\n\nThe polynomial evaluation results using the specified value and the constant coefficients.\n\npolynomial_evaluate[simd_width: Int, dtype: DType, coefficients: VariadicList[SIMD[dtype, simd_width]]](x: SIMD[dtype, simd_width]) -> SIMD[dtype, simd_width]\n\nEvaluates the polynomial using the Horner scheme.\n\nThe Horner scheme evaluates the polynomial as horner(val, coeffs), where val is a scalar and coeffs is a list of coefficients [c0, c1, c2, ..., cn], by performing the following computation:\n\nhorner(val, coeffs) = c0 + val * (c1 + val * (c2 + val * (... + val * cn)))\n            = fma(val, horner(val, coeffs[1:]), c0)\n\nParameters:\n\n​simd_width (Int): The simd_width of the computed value.\n​dtype (DType): The dtype of the value.\n​coefficients (VariadicList[SIMD[dtype, simd_width]]): The coefficients.\n\nArgs:\n\n​x (SIMD[dtype, simd_width]): The value to compute the polynomial with.\n\nReturns:\n\nThe polynomial evaluation results using the specified value and the constant coefficients.\n\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - limit",
    "url": "https://docs.modular.com/mojo/stdlib/math/limit.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nbit\nlimit\nmath\npolynomial\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\ninf\nneginf\nisinf\nisfinite\nmax_finite\nmax_or_inf\nmin_finite\nmin_or_neginf\nlimit\n\nModule\n\nProvides interfaces to query numeric various numeric properties of types.\n\nYou can import these APIs from the math package. For example:\n\nfrom math.limit import inf\ninf\n\ninf[type: DType]() -> SIMD[type, 1]\n\nGets a +inf value for the given dtype.\n\nConstraints:\n\nCan only be used for FP dtypes.\n\nParameters:\n\n​type (DType): The value dtype.\n\nReturns:\n\nThe +inf value of the given dtype.\n\nneginf\n\nneginf[type: DType]() -> SIMD[type, 1]\n\nGets a -inf value for the given dtype.\n\nConstraints:\n\nCan only be used for FP dtypes.\n\nParameters:\n\n​type (DType): The value dtype.\n\nReturns:\n\nThe -inf value of the given dtype.\n\nisinf\n\nisinf[type: DType, simd_width: Int](val: SIMD[type, simd_width]) -> SIMD[bool, simd_width]\n\nChecks if the value is infinite.\n\nThis is always False for non-FP data types.\n\nParameters:\n\n​type (DType): The value dtype.\n​simd_width (Int): The width of the SIMD vector.\n\nArgs:\n\n​val (SIMD[type, simd_width]): The value to check.\n\nReturns:\n\nTrue if val is infinite and False otherwise.\n\nisfinite\n\nisfinite[type: DType, simd_width: Int](val: SIMD[type, simd_width]) -> SIMD[bool, simd_width]\n\nChecks if the value is not infinite.\n\nThis is always True for non-FP data types.\n\nParameters:\n\n​type (DType): The value dtype.\n​simd_width (Int): The width of the SIMD vector.\n\nArgs:\n\n​val (SIMD[type, simd_width]): The value to check.\n\nReturns:\n\nTrue if val is finite and False otherwise.\n\nmax_finite\n\nmax_finite[type: DType]() -> SIMD[type, 1]\n\nReturns the maximum finite value of type.\n\nParameters:\n\n​type (DType): The value dtype.\n\nReturns:\n\nThe maximum representable value of the type. Does not include infinity for floating-point types.\n\nmax_or_inf\n\nmax_or_inf[type: DType]() -> SIMD[type, 1]\n\nReturns the maximum value of type.\n\nParameters:\n\n​type (DType): The value dtype.\n\nReturns:\n\nThe maximum value of the type or infinity for floating-point types.\n\nmin_finite\n\nmin_finite[type: DType]() -> SIMD[type, 1]\n\nReturns the minimum (lowest) finite value of type.\n\nParameters:\n\n​type (DType): The value dtype.\n\nReturns:\n\nThe minimum representable value of the type. Does not include negative infinity for floating-point types.\n\nmin_or_neginf\n\nmin_or_neginf[type: DType]() -> SIMD[type, 1]\n\nReturns the minimum value of type.\n\nParameters:\n\n​type (DType): The value dtype.\n\nReturns:\n\nThe minimum value of the type or infinity for floating-point types.\n\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - bit",
    "url": "https://docs.modular.com/mojo/stdlib/math/bit.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nbit\nlimit\nmath\npolynomial\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nctlz\ncttz\nselect\nbitreverse\nbswap\nctpop\nbit_not\nbit_and\nbit_length\nbit\n\nModule\n\nProvides functions for bit manipulation.\n\nYou can import these APIs from the math package. For example:\n\nfrom math.bit import ctlz\nctlz\n\nctlz(val: Int) -> Int\n\nCounts the number of leading zeros of an integer.\n\nArgs:\n\n​val (Int): The input value.\n\nReturns:\n\nThe number of leading zeros of the input.\n\nctlz[type: DType, simd_width: Int](val: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nCounts the per-element number of leading zeros in a SIMD vector.\n\nConstraints:\n\nDType must be integral.\n\nParameters:\n\n​type (DType): dtype used for the computation.\n​simd_width (Int): SIMD width used for the computation.\n\nArgs:\n\n​val (SIMD[type, simd_width]): The input value.\n\nReturns:\n\nA SIMD value where the element at position i contains the number of leading zeros at position i of the input value.\n\ncttz\n\ncttz(val: Int) -> Int\n\nCounts the number of trailing zeros for an integer.\n\nArgs:\n\n​val (Int): The input value.\n\nReturns:\n\nThe number of trailing zeros of the input.\n\ncttz[type: DType, simd_width: Int](val: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nCounts the number of trailing zero for a SIMD vector.\n\nConstraints:\n\nDType must be integral.\n\nParameters:\n\n​type (DType): dtype used for the computation.\n​simd_width (Int): SIMD width used for the computation.\n\nArgs:\n\n​val (SIMD[type, simd_width]): The input value.\n\nReturns:\n\nA SIMD value where the element at position i contains the number of trailing zeros at position i of the input value.\n\nselect\n\nselect[type: DType, simd_width: Int](cond: SIMD[bool, simd_width], true_case: SIMD[type, simd_width], false_case: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nPerforms an elementwise select based on the input condition value.\n\nParameters:\n\n​type (DType): dtype used for the computation.\n​simd_width (Int): SIMD width used for the computation.\n\nArgs:\n\n​cond (SIMD[bool, simd_width]): The condition.\n​true_case (SIMD[type, simd_width]): The value to pick if the condition is True.\n​false_case (SIMD[type, simd_width]): The value to pick if the condition is False.\n\nReturns:\n\nA SIMD value where the element at position i contains true_case[i] if cond[i] is True and false_case[i] otherwise.\n\nbitreverse\n\nbitreverse[type: DType, simd_width: Int](val: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nReverses the bitpattern of an integral value.\n\nConstraints:\n\nDType must be integral.\n\nParameters:\n\n​type (DType): dtype used for the computation.\n​simd_width (Int): SIMD width used for the computation.\n\nArgs:\n\n​val (SIMD[type, simd_width]): The input value.\n\nReturns:\n\nA SIMD value where the element at position i has a reversed bitpattern of an integer value of the element at position i of the input value.\n\nbswap\n\nbswap[type: DType, simd_width: Int](val: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nByte-swaps a value.\n\nByte swap an integer value or vector of integer values with an even number of bytes (positive multiple of 16 bits). This is equivalent to llvm.bswap intrinsic that has the following semantics:\n\nThe llvm.bswap.i16 intrinsic returns an i16 value that has the high and low byte of the input i16 swapped. Similarly, the llvm.bswap.i32 intrinsic returns an i32 value that has the four bytes of the input i32 swapped, so that if the input bytes are numbered 0, 1, 2, 3 then the returned i32 will have its bytes in 3, 2, 1, 0 order. The llvm.bswap.i48, llvm.bswap.i64 and other intrinsics extend this concept to additional even-byte lengths (6 bytes, 8 bytes and more, respectively).\n\nConstraints:\n\nNumber of bytes must be even (Bitwidth % 16 == 0). DType must be integral.\n\nParameters:\n\n​type (DType): dtype used for the computation.\n​simd_width (Int): SIMD width used for the computation.\n\nArgs:\n\n​val (SIMD[type, simd_width]): The input value.\n\nReturns:\n\nA SIMD value where the element at position i is the value of the element at position i of the input value with its bytes swapped.\n\nctpop\n\nctpop[type: DType, simd_width: Int](val: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nCounts the number of bits set in a value.\n\nConstraints:\n\nDType must be integral.\n\nParameters:\n\n​type (DType): dtype used for the computation.\n​simd_width (Int): SIMD width used for the computation.\n\nArgs:\n\n​val (SIMD[type, simd_width]): The input value.\n\nReturns:\n\nA SIMD value where the element at position i contains the number of bits set in the element at position i of the input value.\n\nbit_not\n\nbit_not[type: DType, simd_width: Int](val: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nPerforms a bitwise NOT operation on an integral.\n\nConstraints:\n\nDType must be integral.\n\nParameters:\n\n​type (DType): dtype used for the computation.\n​simd_width (Int): SIMD width used for the computation.\n\nArgs:\n\n​val (SIMD[type, simd_width]): The input value.\n\nReturns:\n\nA SIMD value where the element at position i is computed as a bitwise NOT of the integer value at position i of the input value.\n\nbit_and\n\nbit_and[type: DType, simd_width: Int](a: SIMD[type, simd_width], b: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nPerforms a bitwise AND operation.\n\nConstraints:\n\nDType must be integral.\n\nParameters:\n\n​type (DType): dtype used for the computation.\n​simd_width (Int): SIMD width used for the computation.\n\nArgs:\n\n​a (SIMD[type, simd_width]): The first input value.\n​b (SIMD[type, simd_width]): The second input value.\n\nReturns:\n\nA SIMD value where the element at position i is computed as a bitwise AND of the elements at position i of the input values.\n\nbit_length\n\nbit_length[type: DType, simd_width: Int](val: SIMD[type, simd_width]) -> SIMD[type, simd_width]\n\nComputes the number of digits required to represent the integer.\n\nConstraints:\n\nDType must be integral. The function asserts on non-integral dtypes in debug builds and returns 0 in release builds.\n\nParameters:\n\n​type (DType): dtype used for the computation.\n​simd_width (Int): SIMD width used for the computation.\n\nArgs:\n\n​val (SIMD[type, simd_width]): The input value.\n\nReturns:\n\nA SIMD value where the element at position i equals to the number of digits required to represent the integer at position i of the input value.\n\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - complex",
    "url": "https://docs.modular.com/mojo/stdlib/complex/complex.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nComplexSIMD\n__neg__\n__add__\n__mul__\n__str__\nnorm\nsquared_norm\nfma\nsquared_add\ncomplex\n\nModule\n\nImplements the Complex type.\n\nYou can import these APIs from the complex package. For example:\n\nfrom complex import ComplexSIMD\n\nAliases:\n\n​ComplexFloat32 = ComplexSIMD[f32, 1]\n​ComplexFloat64 = ComplexSIMD[f64, 1]\nComplexSIMD\n\nRepresents a complex SIMD value.\n\nThe class provides basic methods for manipulating complex values.\n\nParameters:\n\n​type (DType): DType of the value.\n​size (Int): SIMD width of the value.\n\nFields:\n\n​re (SIMD[type, size]): The real part of the complex SIMD value.\n​im (SIMD[type, size]): The imaginary part of the complex SIMD value.\n\nFunctions:\n\n__neg__\n\n__neg__(self: Self) -> Self\n\nNegates the complex value.\n\nReturns:\n\nThe negative of the complex value.\n\n__add__\n\n__add__(self: Self, rhs: Self) -> Self\n\nAdds two complex values.\n\nArgs:\n\n​rhs (Self): Complex value to add.\n\nReturns:\n\nA sum of this and RHS complex values.\n\n__mul__\n\n__mul__(self: Self, rhs: Self) -> Self\n\nMultiplies two complex values.\n\nArgs:\n\n​rhs (Self): Complex value to multiply with.\n\nReturns:\n\nA product of this and RHS complex values.\n\n__str__\n\n__str__(self: Self) -> String\n\nGet the complex as a string.\n\nReturns:\n\nA string representation.\n\nnorm\n\nnorm(self: Self) -> SIMD[type, size]\n\nReturns the magnitude of the complex value.\n\nReturns:\n\nValue of sqrt(re*re + im*im).\n\nsquared_norm\n\nsquared_norm(self: Self) -> SIMD[type, size]\n\nReturns the squared magnitude of the complex value.\n\nReturns:\n\nValue of re*re + im*im.\n\nfma\n\nfma(self: Self, b: Self, c: Self) -> Self\n\nComputes FMA operation.\n\nCompute fused multiple-add with two other complex values: result = self * b + c\n\nArgs:\n\n​b (Self): Multiplier complex value.\n​c (Self): Complex value to add.\n\nReturns:\n\nComputed Self * B + C complex value.\n\nsquared_add\n\nsquared_add(self: Self, c: Self) -> Self\n\nComputes Square-Add operation.\n\nCompute Self * Self + C.\n\nArgs:\n\n​c (Self): Complex value to add.\n\nReturns:\n\nComputed Self * Self + C complex value.\n\nImplemented Traits:\n\n​Destructable\n​Stringable\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - value",
    "url": "https://docs.modular.com/mojo/stdlib/builtin/value.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\nbool\nbuiltin_list\nbuiltin_slice\nconstrained\ncoroutine\ndebug_assert\ndestructable\ndtype\nerror\nfile\nfloat_literal\nint\nint_literal\nio\nlen\nobject\nrange\nrebind\nsimd\nstr\nstring\nstring_literal\nstringref\ntuple\ntype_aliases\nvalue\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nMovable\n__moveinit__\n__del__\nCopyable\nvalue\n\nModule\n\nDefines core value traits.\n\nThese are Mojo built-ins, so you don’t need to import them.\n\nMovable\n\nThe Movable trait denotes a type whose value can be moved.\n\nExamples\n\nImplement the Movable trait on Foo which requires the __moveinit__ method:\n\nstruct Foo(Movable):\n    fn __init__(inout self):\n        pass\n\n    fn __moveinit__(inout self, owned existing: Self):\n        print(\"moving\")\n\nYou can now use the ^ suffix to move the object instead of copying it inside generic functions:\n\nfn return_foo[T: Movable](owned foo: T) -> T:\n    return foo^\n\nlet foo = Foo()\nlet res = return_foo(foo^)\nmoving\n\nFunctions:\n\n__moveinit__\n\n__moveinit__(inout self: T, owned existing: T, /)\n\nCreate a new instance of the value by moving the value of another.\n\nArgs:\n\n​existing (T): The value to move.\n__del__\n\n__del__(owned self: T, /)\n\nDestroy the contained value.\n\nThe destructor receives an owned value and is expected to perform any actions needed to end the lifetime of the object. In the simplest case, this is nothing, and the language treats the object as being dead at the end of this function.\n\nImplemented Traits:\n\n​Destructable\nCopyable\n\nThe Copyable trait denotes a type whose value can be copied.\n\nExample implementing the Copyable trait on Foo which requires the __copyinit__ method:\n\nstruct Foo(Copyable):\n    var s: String\n\n    fn __init__(inout self, s: String):\n        self.s = s\n\n    fn __copyinit__(inout self, other: Self):\n        print(\"copying value\")\n        self.s = other.s\n\nYou can now copy objects inside a generic function:\n\nfn copy_return[T: Copyable](foo: T) -> T:\n    let copy = foo\n    return copy\n\nlet foo = Foo(\"test\")\nlet res = copy_return(foo)\ncopying value\n\nFunctions:\n\n__copyinit__\n\n__copyinit__(inout self: T, existing: T, /)\n\nCreate a new instance of the value by copying an existing one.\n\nArgs:\n\n​existing (T): The value to copy.\n__del__\n\n__del__(owned self: T, /)\n\nDestroy the contained value.\n\nThe destructor receives an owned value and is expected to perform any actions needed to end the lifetime of the object. In the simplest case, this is nothing, and the language treats the object as being dead at the end of this function.\n\nImplemented Traits:\n\n​Destructable\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - type_aliases",
    "url": "https://docs.modular.com/mojo/stdlib/builtin/type_aliases.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\nbool\nbuiltin_list\nbuiltin_slice\nconstrained\ncoroutine\ndebug_assert\ndestructable\ndtype\nerror\nfile\nfloat_literal\nint\nint_literal\nio\nlen\nobject\nrange\nrebind\nsimd\nstr\nstring\nstring_literal\nstringref\ntuple\ntype_aliases\nvalue\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\ntype_aliases\n\nModule\n\nDefines some type aliases.\n\nThese are Mojo built-ins, so you don’t need to import them.\n\nAliases:\n\n​AnyType = AnyTypeType: Represents any Mojo data type.\n​AnyRegType = AnyRegType: Represents any register passable Mojo data type.\n​NoneType = None: Represents the absence of a value.\n​Lifetime = lifetime: Value lifetime specifier.\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - tuple",
    "url": "https://docs.modular.com/mojo/stdlib/builtin/tuple.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\nbool\nbuiltin_list\nbuiltin_slice\nconstrained\ncoroutine\ndebug_assert\ndestructable\ndtype\nerror\nfile\nfloat_literal\nint\nint_literal\nio\nlen\nobject\nrange\nrebind\nsimd\nstr\nstring\nstring_literal\nstringref\ntuple\ntype_aliases\nvalue\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nTuple\n__init__\n__copyinit__\n__len__\nget\ntuple\n\nModule\n\nImplements the Tuple type.\n\nThese are Mojo built-ins, so you don’t need to import them.\n\nTuple\n\nThe type of a literal tuple expression.\n\nA tuple consists of zero or more values, separated by commas.\n\nParameters:\n\n​Ts (*AnyRegType): The elements type.\n\nFields:\n\n​storage (!kgen.pack<Ts>): The underlying storage for the tuple.\n\nFunctions:\n\n__init__\n\n__init__(args: !kgen.pack<Ts>) -> Self\n\nConstruct the tuple.\n\nArgs:\n\n​args (!kgen.pack<Ts>): Initial values.\n\nReturns:\n\nConstructed tuple.\n\n__copyinit__\n\n__copyinit__(existing: Self) -> Self\n\nCopy construct the tuple.\n\nReturns:\n\nConstructed tuple.\n\n__len__\n\n__len__(self: Self) -> Int\n\nGet the number of elements in the tuple.\n\nReturns:\n\nThe tuple length.\n\nget\n\nget[i: Int, T: AnyRegType](self: Self) -> T\n\nGet a tuple element.\n\nParameters:\n\n​i (Int): The element index.\n​T (AnyRegType): The element type.\n\nReturns:\n\nThe tuple element at the requested index.\n\nImplemented Traits:\n\n​CollectionElement\n​Copyable\n​Destructable\n​Movable\n​Sized\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - stringref",
    "url": "https://docs.modular.com/mojo/stdlib/builtin/stringref.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\nbool\nbuiltin_list\nbuiltin_slice\nconstrained\ncoroutine\ndebug_assert\ndestructable\ndtype\nerror\nfile\nfloat_literal\nint\nint_literal\nio\nlen\nobject\nrange\nrebind\nsimd\nstr\nstring\nstring_literal\nstringref\ntuple\ntype_aliases\nvalue\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nStringRef\n__init__\n__bool__\n__getitem__\n__eq__\n__ne__\n__str__\n__len__\nstringref\n\nModule\n\nImplements the StringRef class.\n\nThese are Mojo built-ins, so you don’t need to import them.\n\nStringRef\n\nRepresent a constant reference to a string, i.e. a sequence of characters and a length, which need not be null terminated.\n\nFields:\n\n​data (DTypePointer[si8, 0]): A pointer to the beginning of the string data being referenced.\n​length (Int): The length of the string being referenced.\n\nFunctions:\n\n__init__\n\n__init__(str: StringLiteral) -> Self\n\nConstruct a StringRef value given a constant string.\n\nArgs:\n\n​str (StringLiteral): The input constant string.\n\nReturns:\n\nConstructed StringRef object.\n\n__init__(ptr: Pointer[SIMD[si8, 1], 0], len: Int) -> Self\n\nConstruct a StringRef value given a (potentially non-0 terminated string).\n\nThe constructor takes a raw pointer and a length.\n\nArgs:\n\n​ptr (Pointer[SIMD[si8, 1], 0]): Pointer to the string.\n​len (Int): The length of the string.\n\nReturns:\n\nConstructed StringRef object.\n\n__init__(ptr: DTypePointer[si8, 0], len: Int) -> Self\n\nConstruct a StringRef value given a (potentially non-0 terminated string).\n\nThe constructor takes a raw pointer and a length.\n\nArgs:\n\n​ptr (DTypePointer[si8, 0]): Pointer to the string.\n​len (Int): The length of the string.\n\nReturns:\n\nConstructed StringRef object.\n\n__init__(ptr: Pointer[SIMD[si8, 1], 0]) -> Self\n\nConstruct a StringRef value given a null-terminated string.\n\nArgs:\n\n​ptr (Pointer[SIMD[si8, 1], 0]): Pointer to the string.\n\nReturns:\n\nConstructed StringRef object.\n\n__init__(ptr: DTypePointer[si8, 0]) -> Self\n\nConstruct a StringRef value given a null-terminated string.\n\nArgs:\n\n​ptr (DTypePointer[si8, 0]): Pointer to the string.\n\nReturns:\n\nConstructed StringRef object.\n\n__bool__\n\n__bool__(self: Self) -> Bool\n\nChecks if the string is empty or not.\n\nReturns:\n\nReturns True if the string is not empty and False otherwise.\n\n__getitem__\n\n__getitem__(self: Self, idx: Int) -> Self\n\nGet the string value at the specified position.\n\nArgs:\n\n​idx (Int): The index position.\n\nReturns:\n\nThe character at the specified position.\n\n__eq__\n\n__eq__(self: Self, rhs: Self) -> Bool\n\nCompares two strings are equal.\n\nArgs:\n\n​rhs (Self): The other string.\n\nReturns:\n\nTrue if the strings match and False otherwise.\n\n__ne__\n\n__ne__(self: Self, rhs: Self) -> Bool\n\nCompares two strings are not equal.\n\nArgs:\n\n​rhs (Self): The other string.\n\nReturns:\n\nTrue if the strings do not match and False otherwise.\n\n__str__\n\n__str__(self: Self) -> String\n\nConvert the string reference to a string.\n\nReturns:\n\nA new string.\n\n__len__\n\n__len__(self: Self) -> Int\n\nReturns the length of the string.\n\nReturns:\n\nThe length of the string.\n\nImplemented Traits:\n\n​CollectionElement\n​Copyable\n​Destructable\n​Movable\n​Sized\n​Stringable\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - string_literal",
    "url": "https://docs.modular.com/mojo/stdlib/builtin/string_literal.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\nbool\nbuiltin_list\nbuiltin_slice\nconstrained\ncoroutine\ndebug_assert\ndestructable\ndtype\nerror\nfile\nfloat_literal\nint\nint_literal\nio\nlen\nobject\nrange\nrebind\nsimd\nstr\nstring\nstring_literal\nstringref\ntuple\ntype_aliases\nvalue\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nStringLiteral\n__init__\n__bool__\n__eq__\n__ne__\n__add__\n__len__\ndata\n__str__\nstring_literal\n\nModule\n\nImplements the StringLiteral class.\n\nThese are Mojo built-ins, so you don’t need to import them.\n\nStringLiteral\n\nThis type represents a string literal.\n\nString literals are all null-terminated for compatibility with C APIs, but this is subject to change. String literals store their length as an integer, and this does not include the null terminator.\n\nAliases:\n\n​type = string\n\nFields:\n\n​value (string): The underlying storage for the string literal.\n\nFunctions:\n\n__init__\n\n__init__(value: string) -> Self\n\nCreate a string literal from a builtin string type.\n\nArgs:\n\n​value (string): The string value.\n\nReturns:\n\nA string literal object.\n\n__bool__\n\n__bool__(self: Self) -> Bool\n\nConvert the string to a bool value.\n\nReturns:\n\nTrue if the string is not empty.\n\n__eq__\n\n__eq__(self: Self, rhs: Self) -> Bool\n\nCompare two string literals for equality.\n\nArgs:\n\n​rhs (Self): The string to compare.\n\nReturns:\n\nTrue if they are equal.\n\n__ne__\n\n__ne__(self: Self, rhs: Self) -> Bool\n\nCompare two string literals for inequality.\n\nArgs:\n\n​rhs (Self): The string to compare.\n\nReturns:\n\nTrue if they are not equal.\n\n__add__\n\n__add__(self: Self, rhs: Self) -> Self\n\nConcatenate two string literals.\n\nArgs:\n\n​rhs (Self): The string to concat.\n\nReturns:\n\nThe concatenated string.\n\n__len__\n\n__len__(self: Self) -> Int\n\nGet the string length.\n\nReturns:\n\nThe length of this StringLiteral.\n\ndata\n\ndata(self: Self) -> DTypePointer[si8, 0]\n\nGet raw pointer to the underlying data.\n\nReturns:\n\nThe raw pointer to the data.\n\n__str__\n\n__str__(self: Self) -> String\n\nConvert the string literal to a string.\n\nReturns:\n\nA new string.\n\nImplemented Traits:\n\n​Destructable\n​Sized\n​Stringable\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - string",
    "url": "https://docs.modular.com/mojo/stdlib/builtin/string.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\nbool\nbuiltin_list\nbuiltin_slice\nconstrained\ncoroutine\ndebug_assert\ndestructable\ndtype\nerror\nfile\nfloat_literal\nint\nint_literal\nio\nlen\nobject\nrange\nrebind\nsimd\nstr\nstring\nstring_literal\nstringref\ntuple\ntype_aliases\nvalue\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nString\n__init__\n__copyinit__\n__moveinit__\n__bool__\n__getitem__\n__eq__\n__ne__\n__add__\n__radd__\n__iadd__\n__str__\n__len__\njoin\ncount\nfind\nsplit\nrfind\nreplace\nord\nchr\natol\nisdigit\nstring\n\nModule\n\nImplements basic object methods for working with strings.\n\nThese are Mojo built-ins, so you don’t need to import them.\n\nString\n\nRepresents a mutable string.\n\nFunctions:\n\n__init__\n\n__init__(inout self: Self, owned impl: DynamicVector[SIMD[si8, 1]])\n\nConstruct a string from its underlying buffer.\n\nArgs:\n\n​impl (DynamicVector[SIMD[si8, 1]]): The buffer.\n\n__init__(inout self: Self)\n\nConstruct an empty string.\n\n__init__(inout self: Self, str: StringRef)\n\nConstruct a string from a StringRef object.\n\nArgs:\n\n​str (StringRef): The StringRef from which to construct this string object.\n\n__init__(inout self: Self, str: StringLiteral)\n\nConstructs a String value given a constant string.\n\nArgs:\n\n​str (StringLiteral): The input constant string.\n\n__init__(inout self: Self, str: Self)\n\nConstructs a String value given a constant string.\n\nArgs:\n\n​str (Self): The input string.\n\n__init__(inout self: Self, val: Bool)\n\nConstructs a string representing an bool value.\n\nArgs:\n\n​val (Bool): The boolean value.\n\n__init__(inout self: Self, num: Int)\n\nConstructs a string representing an integer value.\n\nArgs:\n\n​num (Int): The integer value.\n\n__init__(inout self: Self, num: FloatLiteral)\n\nConstructs a string representing a float value.\n\nArgs:\n\n​num (FloatLiteral): The float value.\n\n__init__[type: DType, simd_width: Int](inout self: Self, vec: SIMD[type, simd_width])\n\nConstructs a string for a given SIMD value.\n\nParameters:\n\n​type (DType): The dtype of the SIMD value.\n​simd_width (Int): The width of the SIMD value.\n\nArgs:\n\n​vec (SIMD[type, simd_width]): The SIMD value.\n\n__init__[type: DType, simd_width: Int](inout self: Self, vec: ComplexSIMD[type, simd_width])\n\nConstructs a string for a given complex value.\n\nParameters:\n\n​type (DType): The dtype of the SIMD value.\n​simd_width (Int): The width of the SIMD value.\n\nArgs:\n\n​vec (ComplexSIMD[type, simd_width]): The complex value.\n\n__init__[size: Int](inout self: Self, tuple: StaticIntTuple[size])\n\nConstructs a string from a given StaticIntTuple.\n\nParameters:\n\n​size (Int): The size of the tuple.\n\nArgs:\n\n​tuple (StaticIntTuple[size]): The input tuple.\n\n__init__(inout self: Self, ptr: Pointer[SIMD[si8, 1], 0], len: Int)\n\nCreates a string from the buffer. Note that the string now owns the buffer.\n\nArgs:\n\n​ptr (Pointer[SIMD[si8, 1], 0]): The pointer to the buffer.\n​len (Int): The length of the buffer.\n\n__init__(inout self: Self, ptr: DTypePointer[si8, 0], len: Int)\n\nCreates a string from the buffer. Note that the string now owns the buffer.\n\nArgs:\n\n​ptr (DTypePointer[si8, 0]): The pointer to the buffer.\n​len (Int): The length of the buffer.\n__copyinit__\n\n__copyinit__(inout self: Self, existing: Self)\n\nCreates a deep copy of an existing string.\n\nArgs:\n\n​existing (Self): The string to copy.\n__moveinit__\n\n__moveinit__(inout self: Self, owned existing: Self)\n\nMove the value of a string.\n\nArgs:\n\n​existing (Self): The string to move.\n__bool__\n\n__bool__(self: Self) -> Bool\n\nChecks if the string is empty.\n\nReturns:\n\nTrue if the string is empty and False otherwise.\n\n__getitem__\n\n__getitem__(self: Self, idx: Int) -> Self\n\nGets the character at the specified position.\n\nArgs:\n\n​idx (Int): The index value.\n\nReturns:\n\nA new string containing the character at the specified position.\n\n__getitem__(self: Self, span: slice) -> Self\n\nGets the sequence of characters at the specified positions.\n\nArgs:\n\n​span (slice): A slice that specifies positions of the new substring.\n\nReturns:\n\nA new string containing the string at the specified positions.\n\n__eq__\n\n__eq__(self: Self, other: Self) -> Bool\n\nCompares two Strings if they have the same values.\n\nArgs:\n\n​other (Self): The rhs of the operation.\n\nReturns:\n\nTrue if the Strings are equal and False otherwise.\n\n__ne__\n\n__ne__(self: Self, other: Self) -> Bool\n\nCompares two Strings if they do not have the same values.\n\nArgs:\n\n​other (Self): The rhs of the operation.\n\nReturns:\n\nTrue if the Strings are not equal and False otherwise.\n\n__add__\n\n__add__(self: Self, other: Self) -> Self\n\nCreates a string by appending another string at the end.\n\nArgs:\n\n​other (Self): The string to append.\n\nReturns:\n\nThe new constructed string.\n\n__radd__\n\n__radd__(self: Self, other: Self) -> Self\n\nCreates a string by prepending another string to the start.\n\nArgs:\n\n​other (Self): The string to prepend.\n\nReturns:\n\nThe new constructed string.\n\n__radd__(self: Self, other: StringLiteral) -> Self\n\nCreates a string by prepending another string to the start.\n\nArgs:\n\n​other (StringLiteral): The string to prepend.\n\nReturns:\n\nThe new constructed string.\n\n__iadd__\n\n__iadd__(inout self: Self, other: Self)\n\nAppends another string to this string.\n\nArgs:\n\n​other (Self): The string to append.\n__str__\n\n__str__(self: Self) -> Self\n\n__len__\n\n__len__(self: Self) -> Int\n\nReturns the string length.\n\nReturns:\n\nThe string length.\n\njoin\n\njoin[rank: Int](self: Self, elems: StaticIntTuple[rank]) -> Self\n\nJoins the elements from the tuple using the current string as a delimiter.\n\nParameters:\n\n​rank (Int): The size of the tuple.\n\nArgs:\n\n​elems (StaticIntTuple[rank]): The input tuple.\n\nReturns:\n\nThe joined string.\n\njoin(self: Self, *elems: Int) -> Self\n\nJoins integer elements using the current string as a delimiter.\n\nArgs:\n\n​elems (*Int): The input values.\n\nReturns:\n\nThe joined string.\n\njoin(self: Self, *strs: Self) -> Self\n\nJoins string elements using the current string as a delimiter.\n\nArgs:\n\n​strs (*Self): The input values.\n\nReturns:\n\nThe joined string.\n\ncount\n\ncount(self: Self, substr: Self) -> Int\n\nReturn the number of non-overlapping occurrences of substring substr in the string.\n\nIf sub is empty, returns the number of empty strings between characters which is the length of the string plus one.\n\nArgs:\n\n​substr (Self): The substring to count.\n\nReturns:\n\nThe number of occurrences of substr.\n\nfind\n\nfind(self: Self, substr: Self, start: Int) -> Int\n\nFinds the offset of the first occurrence of substr starting at start. If not found, returns -1.\n\nArgs:\n\n​substr (Self): The substring to find.\n​start (Int): The offset from which to find.\n\nReturns:\n\nThe offset of substr.\n\nsplit\n\nsplit(self: Self, delimiter: Self) -> DynamicVector[String]\n\nSplit the string by a single character delimiter.\n\nRaises: Error if an empty delimiter is specified.\n\nArgs:\n\n​delimiter (Self): The string to split on.\n\nReturns:\n\nA DynamicVector of Strings containing the input split by the delimiter.\n\nrfind\n\nrfind(self: Self, substr: Self, start: Int) -> Int\n\nFinds the offset of the last occurrence of substr starting at start. If not found, returns -1.\n\nArgs:\n\n​substr (Self): The substring to find.\n​start (Int): The offset from which to find.\n\nReturns:\n\nThe offset of substr.\n\nreplace\n\nreplace(self: Self, old: Self, new: Self) -> Self\n\nReturn a copy of the string with all occurrences of substring old if replaced by new.\n\nArgs:\n\n​old (Self): The substring to replace.\n​new (Self): The substring to replace with.\n\nReturns:\n\nThe string where all occurences of old are replaced with new.\n\nImplemented Traits:\n\n​CollectionElement\n​Copyable\n​Destructable\n​Movable\n​Sized\n​Stringable\nord\n\nord(s: String) -> Int\n\nReturns an integer that represents the given one-character string.\n\nGiven a string representing one ASCII character, return an integer representing the code point of that character. For example, ord(\"a\") returns the integer 97. This is the inverse of the chr() function.\n\nArgs:\n\n​s (String): The input string, which must contain only a single character.\n\nReturns:\n\nAn integer representing the code point of the given character.\n\nchr\n\nchr(c: Int) -> String\n\nReturns a string based on the given Unicode code point.\n\nReturns the string representing a character whose code point (which must be a positive integer between 0 and 255) is the integer i. For example, chr(97) returns the string \"a\". This is the inverse of the ord() function.\n\nArgs:\n\n​c (Int): An integer between 0 and 255 that represents a code point.\n\nReturns:\n\nA string containing a single character based on the given code point.\n\natol\n\natol(str: String) -> Int\n\nParses the given string as a base-10 integer and returns that value.\n\nFor example, atol(\"19\") returns 19. If the given string cannot be parsed as an integer value, an error is raised. For example, atol(\"hi\") raises an error.\n\nArgs:\n\n​str (String): A string to be parsed as a base-10 integer.\n\nReturns:\n\nAn integer value that represents the string, or otherwise raises.\n\nisdigit\n\nisdigit(c: SIMD[si8, 1]) -> Bool\n\nDetermines whether the given character is a digit [0-9].\n\nArgs:\n\n​c (SIMD[si8, 1]): The character to check.\n\nReturns:\n\nTrue if the character is a digit.\n\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - str",
    "url": "https://docs.modular.com/mojo/stdlib/builtin/str.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\nbool\nbuiltin_list\nbuiltin_slice\nconstrained\ncoroutine\ndebug_assert\ndestructable\ndtype\nerror\nfile\nfloat_literal\nint\nint_literal\nio\nlen\nobject\nrange\nrebind\nsimd\nstr\nstring\nstring_literal\nstringref\ntuple\ntype_aliases\nvalue\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nStringable\n__del__\n__str__\nStringableRaising\nstr\nstr\n\nModule\n\nProvides the str function.\n\nThese are Mojo built-ins, so you don’t need to import them.\n\nStringable\n\nThe Stringable trait describes a type that can be converted to a String.\n\nAny type that conforms to Stringable or StringableRaising works with the built-in print() and str() functions.\n\nThe Stringable trait requires the type to define the __str__() method. For example:\n\n@value\nstruct Foo(Stringable):\n    var s: String\n\n    fn __str__(self) -> String:\n        return self.s\n\nNow you can pass an instance of Foo to the str() function to get back a String:\n\nlet foo = Foo(\"test\")\nprint(str(foo) == \"test\")\nTrue\n\nNote: If the __str__() method might raise an error, use the StringableRaising trait, instead.\n\nFunctions:\n\n__del__\n\n__del__(owned self: T, /)\n\nDestroy the contained value.\n\nThe destructor receives an owned value and is expected to perform any actions needed to end the lifetime of the object. In the simplest case, this is nothing, and the language treats the object as being dead at the end of this function.\n\n__str__\n\n__str__(self: T) -> String\n\nGet the string representation of the type.\n\nReturns:\n\nThe string representation of the type.\n\nImplemented Traits:\n\n​Destructable\nStringableRaising\n\nThe StringableRaising trait describes a type that can be converted to a String.\n\nAny type that conforms to Stringable or StringableRaising works with the built-in print() and str() functions.\n\nThe StringableRaising trait requires the type to define the __str__() method, which can raise an error. For example:\n\n@value\nstruct Foo(StringableRaising):\n    var s: String\n\n    fn __str__(self) raises -> String:\n        if self.s == \"\":\n            raise Error(\"Empty String\")\n        return self.s\n\nNow you can pass an instance of Foo to the str() function to get back a String:\n\nfn main() raises:\n    let foo = Foo(\"test\")\n    print(str(foo) == \"test\")\nTrue\n\nFunctions:\n\n__del__\n\n__del__(owned self: T, /)\n\nDestroy the contained value.\n\nThe destructor receives an owned value and is expected to perform any actions needed to end the lifetime of the object. In the simplest case, this is nothing, and the language treats the object as being dead at the end of this function.\n\n__str__\n\n__str__(self: T) -> String\n\nGet the string representation of the type.\n\nRaises: If there is an error when computing the string representation of the type.\n\nReturns:\n\nThe string representation of the type.\n\nImplemented Traits:\n\n​Destructable\nstr\n\nstr[T: Stringable](value: T) -> String\n\nGet the string representation of a value.\n\nParameters:\n\n​T (Stringable): The type conforming to Stringable.\n\nArgs:\n\n​value (T): The object to get the string representation of.\n\nReturns:\n\nThe string representation of the object.\n\nstr[T: StringableRaising](value: T) -> String\n\nGet the string representation of a value.\n\nRaises: If there is an error when computing the string representation of the type.\n\nParameters:\n\n​T (StringableRaising): The type conforming to Stringable.\n\nArgs:\n\n​value (T): The object to get the string representation of.\n\nReturns:\n\nThe string representation of the object.\n\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - simd",
    "url": "https://docs.modular.com/mojo/stdlib/builtin/simd.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\nbool\nbuiltin_list\nbuiltin_slice\nconstrained\ncoroutine\ndebug_assert\ndestructable\ndtype\nerror\nfile\nfloat_literal\nint\nint_literal\nio\nlen\nobject\nrange\nrebind\nsimd\nstr\nstring\nstring_literal\nstringref\ntuple\ntype_aliases\nvalue\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nSIMD\n__init__\n__bool__\n__getitem__\n__setitem__\n__neg__\n__pos__\n__invert__\n__lt__\n__le__\n__eq__\n__ne__\n__gt__\n__ge__\n__add__\n__sub__\n__mul__\n__truediv__\n__floordiv__\n__mod__\n__pow__\n__lshift__\n__rshift__\n__and__\n__or__\n__xor__\n__radd__\n__rsub__\n__rmul__\n__rtruediv__\n__rfloordiv__\n__rmod__\n__rlshift__\n__rrshift__\n__rand__\n__ror__\n__rxor__\n__iadd__\n__isub__\n__imul__\n__itruediv__\n__ifloordiv__\n__imod__\n__ipow__\n__ilshift__\n__irshift__\n__iand__\n__ixor__\n__ior__\n__len__\nsplat\ncast\n__int__\n__str__\nto_int\nfma\nshuffle\nslice\njoin\nmin\nmax\nreduce\nreduce_max\nreduce_min\nreduce_add\nreduce_mul\nreduce_and\nreduce_or\nselect\nrotate_left\nrotate_right\nshift_left\nshift_right\nsimd\n\nModule\n\nImplements SIMD struct.\n\nThese are Mojo built-ins, so you don’t need to import them.\n\nAliases:\n\n​Scalar = SIMD[?, 1]: Represents a scalar dtype.\n​Int8 = SIMD[si8, 1]: Represents an 8-bit signed scalar integer.\n​UInt8 = SIMD[ui8, 1]: Represents an 8-bit unsigned scalar integer.\n​Int16 = SIMD[si16, 1]: Represents a 16-bit signed scalar integer.\n​UInt16 = SIMD[ui16, 1]: Represents a 16-bit unsigned scalar integer.\n​Int32 = SIMD[si32, 1]: Represents a 32-bit signed scalar integer.\n​UInt32 = SIMD[ui32, 1]: Represents a 32-bit unsigned scalar integer.\n​Int64 = SIMD[si64, 1]: Represents a 64-bit signed scalar integer.\n​UInt64 = SIMD[ui64, 1]: Represents a 64-bit unsigned scalar integer.\n​Float16 = SIMD[f16, 1]: Represents a 16-bit floating point value.\n​Float32 = SIMD[f32, 1]: Represents a 32-bit floating point value.\n​Float64 = SIMD[f64, 1]: Represents a 64-bit floating point value.\nSIMD\n\nRepresents a small vector that is backed by a hardware vector element.\n\nSIMD allows a single instruction to be executed across the multiple data elements of the vector.\n\nConstraints:\n\nThe size of the SIMD vector to be positive and a power of 2.\n\nParameters:\n\n​type (DType): The data type of SIMD vector elements.\n​size (Int): The size of the SIMD vector.\n\nAliases:\n\n​element_type = _68x13_type\n\nFields:\n\n​value (simd<#lit.struct.extract<:!kgen.declref<@\"$builtin\"::@\"$int\"::@Int, !lit.metatype<@\"$builtin\"::@\"$int\"::@Int>> size, \"value\">, #lit.struct.extract<:!kgen.declref<@\"$builtin\"::@\"$dtype\"::@DType, !lit.metatype<@\"$builtin\"::@\"$dtype\"::@DType>> type, \"value\">>): The underlying storage for the vector.\n\nFunctions:\n\n__init__\n\n__init__() -> Self\n\nDefault initializer of the SIMD vector.\n\nBy default the SIMD vectors are initialized to all zeros.\n\nReturns:\n\nSIMD vector whose elements are 0.\n\n__init__(value: Int) -> Self\n\nInitializes the SIMD vector with an integer.\n\nThe integer value is splatted across all the elements of the SIMD vector.\n\nArgs:\n\n​value (Int): The input value.\n\nReturns:\n\nSIMD vector whose elements have the specified value.\n\n__init__(value: IntLiteral) -> Self\n\nInitializes the SIMD vector with an integer.\n\nThe integer value is splatted across all the elements of the SIMD vector.\n\nArgs:\n\n​value (IntLiteral): The input value.\n\nReturns:\n\nSIMD vector whose elements have the specified value.\n\n__init__(value: Bool) -> Self\n\nInitializes the SIMD vector with a bool value.\n\nThe bool value is splatted across all elements of the SIMD vector.\n\nArgs:\n\n​value (Bool): The bool value.\n\nReturns:\n\nSIMD vector whose elements have the specified value.\n\n__init__(value: simd<#lit.struct.extract<:!kgen.declref<_\"$builtin\"::_\"$int\"::_Int, !lit.metatype<_\"$builtin\"::_\"$int\"::_Int>> size, \"value\">, #lit.struct.extract<:!kgen.declref<_\"$builtin\"::_\"$dtype\"::_DType, !lit.metatype<_\"$builtin\"::_\"$dtype\"::_DType>> type, \"value\">>) -> Self\n\nInitializes the SIMD vector with the underlying mlir value.\n\nArgs:\n\n​value (simd<#lit.struct.extract<:!kgen.declref<_\"$builtin\"::_\"$int\"::_Int, !lit.metatype<_\"$builtin\"::_\"$int\"::_Int>> size, \"value\">, #lit.struct.extract<:!kgen.declref<_\"$builtin\"::_\"$dtype\"::_DType, !lit.metatype<_\"$builtin\"::_\"$dtype\"::_DType>> type, \"value\">>): The input value.\n\nReturns:\n\nSIMD vector using the specified value.\n\n__init__(*elems: SIMD[type, 1]) -> Self\n\nConstructs a SIMD vector via a variadic list of elements.\n\nIf there is just one input value, then it is splatted to all elements of the SIMD vector. Otherwise, the input values are assigned to the corresponding elements of the SIMD vector.\n\nConstraints:\n\nThe number of input values is 1 or equal to size of the SIMD vector.\n\nArgs:\n\n​elems (*SIMD[type, 1]): The variadic list of elements from which the SIMD vector is constructed.\n\nReturns:\n\nThe constructed SIMD vector.\n\n__init__(value: FloatLiteral) -> Self\n\nInitializes the SIMD vector with a FP64 value.\n\nThe input value is splatted (broadcast) across all the elements of the SIMD vector.\n\nArgs:\n\n​value (FloatLiteral): The input value.\n\nReturns:\n\nA SIMD vector whose elements have the specified value.\n\n__bool__\n\n__bool__(self: Self) -> Bool\n\nConverts the SIMD vector into a boolean scalar value.\n\nReturns:\n\nTrue if all the elements in the SIMD vector are non-zero and False otherwise.\n\n__getitem__\n\n__getitem__(self: Self, idx: Int) -> SIMD[type, 1]\n\nGets an element from the vector.\n\nArgs:\n\n​idx (Int): The element index.\n\nReturns:\n\nThe value at position idx.\n\n__setitem__\n\n__setitem__(inout self: Self, idx: Int, val: SIMD[type, 1])\n\nSets an element in the vector.\n\nArgs:\n\n​idx (Int): The index to set.\n​val (SIMD[type, 1]): The value to set.\n\n__setitem__(inout self: Self, idx: Int, val: scalar<#lit.struct.extract<:!kgen.declref<_\"$builtin\"::_\"$dtype\"::_DType, !lit.metatype<_\"$builtin\"::_\"$dtype\"::_DType>> type, \"value\">>)\n\nSets an element in the vector.\n\nArgs:\n\n​idx (Int): The index to set.\n​val (scalar<#lit.struct.extract<:!kgen.declref<_\"$builtin\"::_\"$dtype\"::_DType, !lit.metatype<_\"$builtin\"::_\"$dtype\"::_DType>> type, \"value\">>): The value to set.\n__neg__\n\n__neg__(self: Self) -> Self\n\nDefines the unary - operation.\n\nReturns:\n\nThe negation of this SIMD vector.\n\n__pos__\n\n__pos__(self: Self) -> Self\n\nDefines the unary + operation.\n\nReturns:\n\nThis SIMD vector.\n\n__invert__\n\n__invert__(self: Self) -> Self\n\nReturns ~self.\n\nConstraints:\n\nThe element type of the SIMD vector must be boolean or integral.\n\nReturns:\n\nThe ~self value.\n\n__lt__\n\n__lt__(self: Self, rhs: Self) -> SIMD[bool, size]\n\nCompares two SIMD vectors using less-than comparison.\n\nArgs:\n\n​rhs (Self): The rhs of the operation.\n\nReturns:\n\nA new bool SIMD vector of the same size whose element at position i is True or False depending on the expression self[i] < rhs[i].\n\n__le__\n\n__le__(self: Self, rhs: Self) -> SIMD[bool, size]\n\nCompares two SIMD vectors using less-than-or-equal comparison.\n\nArgs:\n\n​rhs (Self): The rhs of the operation.\n\nReturns:\n\nA new bool SIMD vector of the same size whose element at position i is True or False depending on the expression self[i] <= rhs[i].\n\n__eq__\n\n__eq__(self: Self, rhs: Self) -> SIMD[bool, size]\n\nCompares two SIMD vectors using equal-to comparison.\n\nArgs:\n\n​rhs (Self): The rhs of the operation.\n\nReturns:\n\nA new bool SIMD vector of the same size whose element at position i is True or False depending on the expression self[i] == rhs[i].\n\n__ne__\n\n__ne__(self: Self, rhs: Self) -> SIMD[bool, size]\n\nCompares two SIMD vectors using not-equal comparison.\n\nArgs:\n\n​rhs (Self): The rhs of the operation.\n\nReturns:\n\nA new bool SIMD vector of the same size whose element at position i is True or False depending on the expression self[i] != rhs[i].\n\n__gt__\n\n__gt__(self: Self, rhs: Self) -> SIMD[bool, size]\n\nCompares two SIMD vectors using greater-than comparison.\n\nArgs:\n\n​rhs (Self): The rhs of the operation.\n\nReturns:\n\nA new bool SIMD vector of the same size whose element at position i is True or False depending on the expression self[i] > rhs[i].\n\n__ge__\n\n__ge__(self: Self, rhs: Self) -> SIMD[bool, size]\n\nCompares two SIMD vectors using greater-than-or-equal comparison.\n\nArgs:\n\n​rhs (Self): The rhs of the operation.\n\nReturns:\n\nA new bool SIMD vector of the same size whose element at position i is True or False depending on the expression self[i] >= rhs[i].\n\n__add__\n\n__add__(self: Self, rhs: Self) -> Self\n\nComputes self + rhs.\n\nArgs:\n\n​rhs (Self): The rhs value.\n\nReturns:\n\nA new vector whose element at position i is computed as self[i] + rhs[i].\n\n__sub__\n\n__sub__(self: Self, rhs: Self) -> Self\n\nComputes self - rhs.\n\nArgs:\n\n​rhs (Self): The rhs value.\n\nReturns:\n\nA new vector whose element at position i is computed as self[i] - rhs[i].\n\n__mul__\n\n__mul__(self: Self, rhs: Self) -> Self\n\nComputes self * rhs.\n\nArgs:\n\n​rhs (Self): The rhs value.\n\nReturns:\n\nA new vector whose element at position i is computed as self[i] * rhs[i].\n\n__truediv__\n\n__truediv__(self: Self, rhs: Self) -> Self\n\nComputes self / rhs.\n\nArgs:\n\n​rhs (Self): The rhs value.\n\nReturns:\n\nA new vector whose element at position i is computed as self[i] / rhs[i].\n\n__floordiv__\n\n__floordiv__(self: Self, rhs: Self) -> Self\n\nReturns the division of self and rhs rounded down to the nearest integer.\n\nConstraints:\n\nThe element type of the SIMD vector must be integral.\n\nArgs:\n\n​rhs (Self): The value to divide on.\n\nReturns:\n\nfloor(self / rhs) value.\n\n__mod__\n\n__mod__(self: Self, rhs: Self) -> Self\n\nReturns the remainder of self divided by rhs.\n\nArgs:\n\n​rhs (Self): The value to divide on.\n\nReturns:\n\nThe remainder of dividing self by rhs.\n\n__pow__\n\n__pow__(self: Self, rhs: Int) -> Self\n\nComputes the vector raised to the power of the input integer value.\n\nArgs:\n\n​rhs (Int): The exponential value.\n\nReturns:\n\nA SIMD vector where each element is raised to the power of the specified exponential value.\n\n__pow__(self: Self, rhs: Self) -> Self\n\nComputes the vector raised elementwise to the right hand side power.\n\nArgs:\n\n​rhs (Self): The exponential value.\n\nReturns:\n\nA SIMD vector where each element is raised to the power of the specified exponential value.\n\n__pow__[rhs_type: DType](self: Self, rhs: SIMD[rhs_type, size]) -> Self\n\nComputes the vector raised elementwise to the right hand side power.\n\nParameters:\n\n​rhs_type (DType): The dtype of the rhs SIMD vector.\n\nArgs:\n\n​rhs (SIMD[rhs_type, size]): The exponential value.\n\nReturns:\n\nA SIMD vector where each element is raised to the power of the specified exponential value.\n\n__lshift__\n\n__lshift__(self: Self, rhs: Self) -> Self\n\nReturns self << rhs.\n\nConstraints:\n\nThe element type of the SIMD vector must be integral.\n\nArgs:\n\n​rhs (Self): The RHS value.\n\nReturns:\n\nself << rhs.\n\n__rshift__\n\n__rshift__(self: Self, rhs: Self) -> Self\n\nReturns self >> rhs.\n\nConstraints:\n\nThe element type of the SIMD vector must be integral.\n\nArgs:\n\n​rhs (Self): The RHS value.\n\nReturns:\n\nself >> rhs.\n\n__and__\n\n__and__(self: Self, rhs: Self) -> Self\n\nReturns self & rhs.\n\nConstraints:\n\nThe element type of the SIMD vector must be bool or integral.\n\nArgs:\n\n​rhs (Self): The RHS value.\n\nReturns:\n\nself & rhs.\n\n__or__\n\n__or__(self: Self, rhs: Self) -> Self\n\nReturns self | rhs.\n\nConstraints:\n\nThe element type of the SIMD vector must be bool or integral.\n\nArgs:\n\n​rhs (Self): The RHS value.\n\nReturns:\n\nself | rhs.\n\n__xor__\n\n__xor__(self: Self, rhs: Self) -> Self\n\nReturns self ^ rhs.\n\nConstraints:\n\nThe element type of the SIMD vector must be bool or integral.\n\nArgs:\n\n​rhs (Self): The RHS value.\n\nReturns:\n\nself ^ rhs.\n\n__radd__\n\n__radd__(self: Self, value: Self) -> Self\n\nReturns value + self.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue + self.\n\n__rsub__\n\n__rsub__(self: Self, value: Self) -> Self\n\nReturns value - self.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue - self.\n\n__rmul__\n\n__rmul__(self: Self, value: Self) -> Self\n\nReturns value * self.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue * self.\n\n__rtruediv__\n\n__rtruediv__(self: Self, value: Self) -> Self\n\nReturns value / self.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue / self.\n\n__rfloordiv__\n\n__rfloordiv__(self: Self, value: Int) -> Int\n\nReturns value // self.\n\nArgs:\n\n​value (Int): The other value.\n\nReturns:\n\nvalue // self.\n\n__rmod__\n\n__rmod__(self: Self, value: Int) -> Int\n\nReturns value % self.\n\nArgs:\n\n​value (Int): The other value.\n\nReturns:\n\nvalue % self.\n\n__rlshift__\n\n__rlshift__(self: Self, value: Self) -> Self\n\nReturns value << self.\n\nConstraints:\n\nThe element type of the SIMD vector must be integral.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue << self.\n\n__rrshift__\n\n__rrshift__(self: Self, value: Self) -> Self\n\nReturns value >> self.\n\nConstraints:\n\nThe element type of the SIMD vector must be integral.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue >> self.\n\n__rand__\n\n__rand__(self: Self, value: Self) -> Self\n\nReturns value & self.\n\nConstraints:\n\nThe element type of the SIMD vector must be bool or integral.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue & self.\n\n__ror__\n\n__ror__(self: Self, value: Self) -> Self\n\nReturns value | self.\n\nConstraints:\n\nThe element type of the SIMD vector must be bool or integral.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue | self.\n\n__rxor__\n\n__rxor__(self: Self, value: Self) -> Self\n\nReturns value ^ self.\n\nConstraints:\n\nThe element type of the SIMD vector must be bool or integral.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue ^ self.\n\n__iadd__\n\n__iadd__(inout self: Self, rhs: Self)\n\nPerforms in-place addition.\n\nThe vector is mutated where each element at position i is computed as self[i] + rhs[i].\n\nArgs:\n\n​rhs (Self): The rhs of the addition operation.\n__isub__\n\n__isub__(inout self: Self, rhs: Self)\n\nPerforms in-place subtraction.\n\nThe vector is mutated where each element at position i is computed as self[i] - rhs[i].\n\nArgs:\n\n​rhs (Self): The rhs of the operation.\n__imul__\n\n__imul__(inout self: Self, rhs: Self)\n\nPerforms in-place multiplication.\n\nThe vector is mutated where each element at position i is computed as self[i] * rhs[i].\n\nArgs:\n\n​rhs (Self): The rhs of the operation.\n__itruediv__\n\n__itruediv__(inout self: Self, rhs: Self)\n\nIn-place true divide operator.\n\nThe vector is mutated where each element at position i is computed as self[i] / rhs[i].\n\nArgs:\n\n​rhs (Self): The rhs of the operation.\n__ifloordiv__\n\n__ifloordiv__(inout self: Self, rhs: Self)\n\nIn-place flood div operator.\n\nThe vector is mutated where each element at position i is computed as self[i] // rhs[i].\n\nArgs:\n\n​rhs (Self): The rhs of the operation.\n__imod__\n\n__imod__(inout self: Self, rhs: Self)\n\nIn-place mod operator.\n\nThe vector is mutated where each element at position i is computed as self[i] % rhs[i].\n\nArgs:\n\n​rhs (Self): The rhs of the operation.\n__ipow__\n\n__ipow__(inout self: Self, rhs: Int)\n\nIn-place pow operator.\n\nThe vector is mutated where each element at position i is computed as pow(self[i], rhs).\n\nArgs:\n\n​rhs (Int): The rhs of the operation.\n__ilshift__\n\n__ilshift__(inout self: Self, rhs: Self)\n\nComputes self << rhs and save the result in self.\n\nConstraints:\n\nThe element type of the SIMD vector must be integral.\n\nArgs:\n\n​rhs (Self): The RHS value.\n__irshift__\n\n__irshift__(inout self: Self, rhs: Self)\n\nComputes self >> rhs and save the result in self.\n\nConstraints:\n\nThe element type of the SIMD vector must be integral.\n\nArgs:\n\n​rhs (Self): The RHS value.\n__iand__\n\n__iand__(inout self: Self, rhs: Self)\n\nComputes self & rhs and save the result in self.\n\nConstraints:\n\nThe element type of the SIMD vector must be bool or integral.\n\nArgs:\n\n​rhs (Self): The RHS value.\n__ixor__\n\n__ixor__(inout self: Self, rhs: Self)\n\nComputes self ^ rhs and save the result in self.\n\nConstraints:\n\nThe element type of the SIMD vector must be bool or integral.\n\nArgs:\n\n​rhs (Self): The RHS value.\n__ior__\n\n__ior__(inout self: Self, rhs: Self)\n\nComputes self | rhs and save the result in self.\n\nConstraints:\n\nThe element type of the SIMD vector must be bool or integral.\n\nArgs:\n\n​rhs (Self): The RHS value.\n__len__\n\n__len__(self: Self) -> Int\n\nGets the length of the SIMD vector.\n\nReturns:\n\nThe length of the SIMD vector.\n\nsplat\n\nstatic splat(x: Bool) -> Self\n\nSplats (broadcasts) the element onto the vector.\n\nArgs:\n\n​x (Bool): The input value.\n\nReturns:\n\nA new SIMD vector whose elements are the same as the input value.\n\nstatic splat(x: SIMD[type, 1]) -> Self\n\nSplats (broadcasts) the element onto the vector.\n\nArgs:\n\n​x (SIMD[type, 1]): The input scalar value.\n\nReturns:\n\nA new SIMD vector whose elements are the same as the input value.\n\ncast\n\ncast[target: DType](self: Self) -> SIMD[target, size]\n\nCasts the elements of the SIMD vector to the target element type.\n\nParameters:\n\n​target (DType): The target DType.\n\nReturns:\n\nA new SIMD vector whose elements have been casted to the target element type.\n\n__int__\n\n__int__(self: Self) -> Int\n\nCasts to the value to an Int. If there is a fractional component, then the value is truncated towards zero.\n\nConstraints:\n\nThe size of the SIMD vector must be 1.\n\nReturns:\n\nThe value as an integer.\n\n__str__\n\n__str__(self: Self) -> String\n\nGet the SIMD as a string.\n\nReturns:\n\nA string representation.\n\nto_int\n\nto_int(self: Self) -> Int\n\nCasts to the value to an Int. If there is a fractional component, then the value is truncated towards zero.\n\nConstraints:\n\nThe size of the SIMD vector must be 1.\n\nReturns:\n\nThe value of the single integer element in the SIMD vector.\n\nfma\n\nfma(self: Self, multiplier: Self, accumulator: Self) -> Self\n\nPerforms a fused multiply-add operation, i.e. self*multiplier + accumulator.\n\nArgs:\n\n​multiplier (Self): The value to multiply.\n​accumulator (Self): The value to accumulate.\n\nReturns:\n\nA new vector whose element at position i is computed as self[i]*multiplier[i] + accumulator[i].\n\nshuffle\n\nshuffle[*mask: Int](self: Self) -> Self\n\nShuffles (also called blend) the values of the current vector with the other value using the specified mask (permutation).\n\nParameters:\n\n​mask (*Int): The permutation to use in the shuffle.\n\nReturns:\n\nA new vector of length len where the value at position i is (self)[permutation[i]].\n\nshuffle[*mask: Int](self: Self, other: Self) -> Self\n\nShuffles (also called blend) the values of the current vector with the other value using the specified mask (permutation).\n\nParameters:\n\n​mask (*Int): The permutation to use in the shuffle.\n\nArgs:\n\n​other (Self): The other vector to shuffle with.\n\nReturns:\n\nA new vector of length len where the value at position i is (self+other)[permutation[i]].\n\nslice\n\nslice[output_width: Int](self: Self, offset: Int) -> SIMD[type, output_width]\n\nReturns a slice of the vector of the specified width with the given offset.\n\nConstraints:\n\noutput_width + offset must not exceed the size of this SIMD vector.\n\nParameters:\n\n​output_width (Int): The output SIMD vector size.\n\nArgs:\n\n​offset (Int): The given offset for the slice.\n\nReturns:\n\nA new vector whose elements map to self[offset:offset+output_width].\n\njoin\n\njoin(self: Self, other: Self) -> SIMD[type, __mul__(2, size)]\n\nConcatenates the two vectors together.\n\nArgs:\n\n​other (Self): The other SIMD vector.\n\nReturns:\n\nA new vector self_0, self_1, ..., self_n, other_0, ..., other_n.\n\nmin\n\nmin(self: Self, other: Self) -> Self\n\nComputes the elementwise minimum between the two vectors.\n\nArgs:\n\n​other (Self): The other SIMD vector.\n\nReturns:\n\nA new SIMD vector where each element at position i is min(self[i], other[i]).\n\nmax\n\nmax(self: Self, other: Self) -> Self\n\nComputes the elementwise maximum between the two vectors.\n\nArgs:\n\n​other (Self): The other SIMD vector.\n\nReturns:\n\nA new SIMD vector where each element at position i is max(self[i], other[i]).\n\nreduce\n\nreduce[func: fn[DType, Int](SIMD[*(0,0), *(0,1)], SIMD[*(0,0), *(0,1)], /) capturing -> SIMD[*(0,0), *(0,1)], size_out: Int](self: Self) -> SIMD[type, size_out]\n\nReduces the vector using a provided reduce operator.\n\nParameters:\n\n​func (fn[DType, Int](SIMD[*(0,0), *(0,1)], SIMD[*(0,0), *(0,1)], /) capturing -> SIMD[*(0,0), *(0,1)]): The reduce function to apply to elements in this SIMD.\n​size_out (Int): The width of the reduction.\n\nReturns:\n\nA new scalar which is the reduction of all vector elements.\n\nreduce_max\n\nreduce_max[size_out: Int](self: Self) -> SIMD[type, size_out]\n\nReduces the vector using the max operator.\n\nConstraints:\n\nThe element type of the vector must be integer or FP.\n\nParameters:\n\n​size_out (Int): The width of the reduction.\n\nReturns:\n\nThe maximum element of the vector.\n\nreduce_min\n\nreduce_min[size_out: Int](self: Self) -> SIMD[type, size_out]\n\nReduces the vector using the min operator.\n\nConstraints:\n\nThe element type of the vector must be integer or FP.\n\nParameters:\n\n​size_out (Int): The width of the reduction.\n\nReturns:\n\nThe minimum element of the vector.\n\nreduce_add\n\nreduce_add[size_out: Int](self: Self) -> SIMD[type, size_out]\n\nReduces the vector using the add operator.\n\nParameters:\n\n​size_out (Int): The width of the reduction.\n\nReturns:\n\nThe sum of all vector elements.\n\nreduce_mul\n\nreduce_mul[size_out: Int](self: Self) -> SIMD[type, size_out]\n\nReduces the vector using the mul operator.\n\nConstraints:\n\nThe element type of the vector must be integer or FP.\n\nParameters:\n\n​size_out (Int): The width of the reduction.\n\nReturns:\n\nThe product of all vector elements.\n\nreduce_and\n\nreduce_and(self: Self) -> Bool\n\nReduces the boolean vector using the and operator.\n\nConstraints:\n\nThe element type of the vector must be boolean.\n\nReturns:\n\nTrue if all element in the vector is True and False otherwise.\n\nreduce_or\n\nreduce_or(self: Self) -> Bool\n\nReduces the boolean vector using the or operator.\n\nConstraints:\n\nThe element type of the vector must be boolean.\n\nReturns:\n\nTrue if any element in the vector is True and False otherwise.\n\nselect\n\nselect[result_type: DType](self: Self, true_case: SIMD[result_type, size], false_case: SIMD[result_type, size]) -> SIMD[result_type, size]\n\nSelects the values of the true_case or the false_case based on the current boolean values of the SIMD vector.\n\nParameters:\n\n​result_type (DType): The element type of the input and output SIMD vectors.\n\nArgs:\n\n​true_case (SIMD[result_type, size]): The values selected if the positional value is True.\n​false_case (SIMD[result_type, size]): The values selected if the positional value is False.\n\nReturns:\n\nA new vector of the form [true_case[i] if elem else false_case[i] for i, elem in enumerate(self)].\n\nrotate_left\n\nrotate_left[shift: Int](self: Self) -> Self\n\nShifts the elements of a SIMD vector to the left by shift elements (with wrap-around).\n\nConstraints:\n\n-size <= shift < size\n\nParameters:\n\n​shift (Int): The number of positions by which to rotate the elements of SIMD vector to the left (with wrap-around).\n\nReturns:\n\nThe SIMD vector rotated to the left by shift elements (with wrap-around).\n\nrotate_right\n\nrotate_right[shift: Int](self: Self) -> Self\n\nShifts the elements of a SIMD vector to the right by shift elements (with wrap-around).\n\nConstraints:\n\n-size < shift <= size\n\nParameters:\n\n​shift (Int): The number of positions by which to rotate the elements of SIMD vector to the right (with wrap-around).\n\nReturns:\n\nThe SIMD vector rotated to the right by shift elements (with wrap-around).\n\nshift_left\n\nshift_left[shift: Int](self: Self) -> Self\n\nShifts the elements of a SIMD vector to the left by shift elements (no wrap-around, fill with zero).\n\nConstraints:\n\n0 <= shift <= size\n\nParameters:\n\n​shift (Int): The number of positions by which to rotate the elements of SIMD vector to the left (no wrap-around, fill with zero).\n\nReturns:\n\nThe SIMD vector rotated to the left by shift elements (no wrap-around, fill with zero).\n\nshift_right\n\nshift_right[shift: Int](self: Self) -> Self\n\nShifts the elements of a SIMD vector to the right by shift elements (no wrap-around, fill with zero).\n\nConstraints:\n\n0 <= shift <= size\n\nParameters:\n\n​shift (Int): The number of positions by which to rotate the elements of SIMD vector to the right (no wrap-around, fill with zero).\n\nReturns:\n\nThe SIMD vector rotated to the right by shift elements (no wrap-around, fill with zero).\n\nImplemented Traits:\n\n​CollectionElement\n​Copyable\n​Destructable\n​Intable\n​Movable\n​Sized\n​Stringable\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - rebind",
    "url": "https://docs.modular.com/mojo/stdlib/builtin/rebind.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\nbool\nbuiltin_list\nbuiltin_slice\nconstrained\ncoroutine\ndebug_assert\ndestructable\ndtype\nerror\nfile\nfloat_literal\nint\nint_literal\nio\nlen\nobject\nrange\nrebind\nsimd\nstr\nstring\nstring_literal\nstringref\ntuple\ntype_aliases\nvalue\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nrebind\nrebind\n\nModule\n\nImplements type rebind.\n\nThese are Mojo built-ins, so you don’t need to import them.\n\nrebind\n\nrebind[dest_type: AnyRegType, src_type: AnyRegType](val: src_type) -> dest_type\n\nStatically assert that a parameter input type src_type resolves to the same type as a parameter result type dest_type after function instantiation and “rebind” the input to the result type.\n\nThis function is meant to be used in uncommon cases where a parametric type depends on the value of a constrained parameter in order to manually refine the type with the constrained parameter value.\n\nParameters:\n\n​dest_type (AnyRegType): The type to rebind to.\n​src_type (AnyRegType): The original type.\n\nArgs:\n\n​val (src_type): The value to rebind.\n\nReturns:\n\nThe rebound value of dest_type.\n\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - range",
    "url": "https://docs.modular.com/mojo/stdlib/builtin/range.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\nbool\nbuiltin_list\nbuiltin_slice\nconstrained\ncoroutine\ndebug_assert\ndestructable\ndtype\nerror\nfile\nfloat_literal\nint\nint_literal\nio\nlen\nobject\nrange\nrebind\nsimd\nstr\nstring\nstring_literal\nstringref\ntuple\ntype_aliases\nvalue\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nrange\nrange\n\nModule\n\nImplements a ‘range’ call.\n\nThese are Mojo built-ins, so you don’t need to import them.\n\nrange\n\nrange(end: Int) -> _ZeroStartingRange\n\nConstructs a [0; end) Range.\n\nArgs:\n\n​end (Int): The end of the range.\n\nReturns:\n\nThe constructed range.\n\nrange(end: PythonObject) -> _ZeroStartingRange\n\nConstructs a [0; end) Range.\n\nArgs:\n\n​end (PythonObject): The end of the range.\n\nReturns:\n\nThe constructed range.\n\nrange(length: object) -> _ZeroStartingRange\n\nConstructs a [0; length) Range.\n\nArgs:\n\n​length (object): The end of the range.\n\nReturns:\n\nThe constructed range.\n\nrange(start: Int, end: Int) -> _SequentialRange\n\nConstructs a [start; end) Range.\n\nArgs:\n\n​start (Int): The start of the range.\n​end (Int): The end of the range.\n\nReturns:\n\nThe constructed range.\n\nrange(start: object, end: object) -> _SequentialRange\n\nConstructs a [start; end) Range.\n\nArgs:\n\n​start (object): The start of the range.\n​end (object): The end of the range.\n\nReturns:\n\nThe constructed range.\n\nrange(start: PythonObject, end: PythonObject) -> _SequentialRange\n\nConstructs a [start; end) Range.\n\nArgs:\n\n​start (PythonObject): The start of the range.\n​end (PythonObject): The end of the range.\n\nReturns:\n\nThe constructed range.\n\nrange(start: Int, end: Int, step: Int) -> _StridedRange\n\nConstructs a [start; end) Range with a given step.\n\nArgs:\n\n​start (Int): The start of the range.\n​end (Int): The end of the range.\n​step (Int): The step for the range.\n\nReturns:\n\nThe constructed range.\n\nrange(start: object, end: object, step: object) -> _StridedRange\n\nConstructs a [start; end) Range with a given step.\n\nArgs:\n\n​start (object): The start of the range.\n​end (object): The end of the range.\n​step (object): The step for the range.\n\nReturns:\n\nThe constructed range.\n\nrange(start: PythonObject, end: PythonObject, step: PythonObject) -> _StridedRange\n\nConstructs a [start; end) Range with a given step.\n\nArgs:\n\n​start (PythonObject): The start of the range.\n​end (PythonObject): The end of the range.\n​step (PythonObject): The step for the range.\n\nReturns:\n\nThe constructed range.\n\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - object",
    "url": "https://docs.modular.com/mojo/stdlib/builtin/object.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\nbool\nbuiltin_list\nbuiltin_slice\nconstrained\ncoroutine\ndebug_assert\ndestructable\ndtype\nerror\nfile\nfloat_literal\nint\nint_literal\nio\nlen\nobject\nrange\nrebind\nsimd\nstr\nstring\nstring_literal\nstringref\ntuple\ntype_aliases\nvalue\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nAttr\n__init__\nobject\nobject\n\nModule\n\nDefines the object type, which is used to represent untyped values.\n\nThese are Mojo built-ins, so you don’t need to import them.\n\nAttr\n\nA generic object’s attributes are set on construction, after which the attributes can be read and modified, but no attributes may be removed or added.\n\nFields:\n\n​key (StringLiteral): The name of the attribute.\n​value (object): The value of the attribute.\n\nFunctions:\n\n__init__\n\n__init__(inout self: Self, key: StringLiteral, owned value: object)\n\nInitializes the attribute with a key and value.\n\nArgs:\n\n​key (StringLiteral): The string literal key.\n​value (object): The object value of the attribute.\nobject\n\nRepresents an object without a concrete type.\n\nThis is the type of arguments in def functions that do not have a type annotation, such as the type of x in def f(x): pass. A value of any type can be passed in as the x argument in this case, and so that value is used to construct this object type.\n\nAliases:\n\n​nullary_function = fn() raises -> object: Nullary function type.\n​unary_function = fn(object, /) raises -> object: Unary function type.\n​binary_function = fn(object, object, /) raises -> object: Binary function type.\n​ternary_function = fn(object, object, object, /) raises -> object: Ternary function type.\n\nFunctions:\n\n__init__\n\n__init__(inout self: Self)\n\nInitializes the object with a None value.\n\n__init__(inout self: Self, impl: _ObjectImpl)\n\nInitializes the object with an implementation value. This is meant for internal use only.\n\nArgs:\n\n​impl (_ObjectImpl): The object implementation.\n\n__init__(inout self: Self, none: None)\n\nInitializes a none value object from a None literal.\n\nArgs:\n\n​none (None): None.\n\n__init__(inout self: Self, value: Int)\n\nInitializes the object with an integer value.\n\nArgs:\n\n​value (Int): The integer value.\n\n__init__(inout self: Self, value: FloatLiteral)\n\nInitializes the object with an floating-point value.\n\nArgs:\n\n​value (FloatLiteral): The float value.\n\n__init__[dt: DType](inout self: Self, value: SIMD[dt, 1])\n\nInitializes the object with a generic scalar value. If the scalar value type is bool, it is converted to a boolean. Otherwise, it is converted to the appropriate integer or floating point type.\n\nParameters:\n\n​dt (DType): The scalar value type.\n\nArgs:\n\n​value (SIMD[dt, 1]): The scalar value.\n\n__init__(inout self: Self, value: Bool)\n\nInitializes the object from a bool.\n\nArgs:\n\n​value (Bool): The boolean value.\n\n__init__(inout self: Self, value: StringLiteral)\n\nInitializes the object from a string literal.\n\nArgs:\n\n​value (StringLiteral): The string value.\n\n__init__(inout self: Self, value: StringRef)\n\nInitializes the object from a string reference.\n\nArgs:\n\n​value (StringRef): The string value.\n\n__init__[*Ts: AnyRegType](inout self: Self, value: ListLiteral[Ts])\n\nInitializes the object from a list literal.\n\nParameters:\n\n​Ts (*AnyRegType): The list element types.\n\nArgs:\n\n​value (ListLiteral[Ts]): The list value.\n\n__init__(inout self: Self, func: fn() raises -> object)\n\nInitializes an object from a function that takes no arguments.\n\nArgs:\n\n​func (fn() raises -> object): The function.\n\n__init__(inout self: Self, func: fn(object, /) raises -> object)\n\nInitializes an object from a function that takes one argument.\n\nArgs:\n\n​func (fn(object, /) raises -> object): The function.\n\n__init__(inout self: Self, func: fn(object, object, /) raises -> object)\n\nInitializes an object from a function that takes two arguments.\n\nArgs:\n\n​func (fn(object, object, /) raises -> object): The function.\n\n__init__(inout self: Self, func: fn(object, object, object, /) raises -> object)\n\nInitializes an object from a function that takes three arguments.\n\nArgs:\n\n​func (fn(object, object, object, /) raises -> object): The function.\n\n__init__(inout self: Self, *attrs: Attr)\n\nInitializes the object with a sequence of zero or more attributes.\n\nArgs:\n\n​attrs (*Attr): Zero or more attributes.\n__copyinit__\n\n__copyinit__(inout self: Self, existing: Self)\n\nCopies the object. This clones the underlying string value and increases the refcount of lists or dictionaries.\n\nArgs:\n\n​existing (Self): The object to copy.\n__moveinit__\n\n__moveinit__(inout self: Self, owned existing: Self)\n\nMove the value of an object.\n\nArgs:\n\n​existing (Self): The object to move.\n__del__\n\n__del__(owned self: Self)\n\nDelete the object and release any owned memory.\n\n__bool__\n\n__bool__(self: Self) -> Bool\n\nPerforms conversion to bool according to Python semantics. Integers and floats are true if they are non-zero, and strings and lists are true if they are non-empty.\n\nReturns:\n\nWhether the object is considered true.\n\n__getitem__\n\n__getitem__(self: Self, i: Self) -> Self\n\nGets the i-th item from the object. This is only valid for strings, lists, and dictionaries.\n\nArgs:\n\n​i (Self): The string or list index, or dictionary key.\n\nReturns:\n\nThe value at the index or key.\n\n__getitem__(self: Self, *index: Self) -> Self\n\nGets the i-th item from the object, where i is a tuple of indices.\n\nArgs:\n\n​index (*Self): A compound index.\n\nReturns:\n\nThe value at the index.\n\n__setitem__\n\n__setitem__(self: Self, i: Self, value: Self)\n\nSets the i-th item in the object. This is only valid for strings, lists, and dictionaries.\n\nArgs:\n\n​i (Self): The string or list index, or dictionary key.\n​value (Self): The value to set.\n\n__setitem__(self: Self, i: Self, j: Self, value: Self)\n\nSets the (i, j)-th element in the object.\n\nFIXME: We need this because obj[i, j] = value will attempt to invoke this method with 3 arguments, and we can only have variadics as the last argument.\n\nArgs:\n\n​i (Self): The first index.\n​j (Self): The second index.\n​value (Self): The value to set.\n__neg__\n\n__neg__(self: Self) -> Self\n\nNegation operator. Only valid for bool, int, and float types. Negation on any bool value converts it to an integer.\n\nReturns:\n\nThe negative of the current value.\n\n__invert__\n\n__invert__(self: Self) -> Self\n\nInvert value operator. This is only valid for bool and int values.\n\nReturns:\n\nThe inverted value.\n\n__lt__\n\n__lt__(self: Self, rhs: Self) -> Self\n\nLess-than comparator. This lexicographically compares strings and lists.\n\nArgs:\n\n​rhs (Self): Right hand value.\n\nReturns:\n\nTrue if the object is less than the right hard argument.\n\n__le__\n\n__le__(self: Self, rhs: Self) -> Self\n\nLess-than-or-equal to comparator. This lexicographically compares strings and lists.\n\nArgs:\n\n​rhs (Self): Right hand value.\n\nReturns:\n\nTrue if the object is less than or equal to the right hard argument.\n\n__eq__\n\n__eq__(self: Self, rhs: Self) -> Self\n\nEquality comparator. This compares the elements of strings and lists.\n\nArgs:\n\n​rhs (Self): Right hand value.\n\nReturns:\n\nTrue if the objects are equal.\n\n__ne__\n\n__ne__(self: Self, rhs: Self) -> Self\n\nInequality comparator. This compares the elements of strings and lists.\n\nArgs:\n\n​rhs (Self): Right hand value.\n\nReturns:\n\nTrue if the objects are not equal.\n\n__gt__\n\n__gt__(self: Self, rhs: Self) -> Self\n\nGreater-than comparator. This lexicographically compares the elements of strings and lists.\n\nArgs:\n\n​rhs (Self): Right hand value.\n\nReturns:\n\nTrue if the left hand value is greater.\n\n__ge__\n\n__ge__(self: Self, rhs: Self) -> Self\n\nGreater-than-or-equal-to comparator. This lexicographically compares the elements of strings and lists.\n\nArgs:\n\n​rhs (Self): Right hand value.\n\nReturns:\n\nTrue if the left hand value is greater than or equal to the right hand value.\n\n__add__\n\n__add__(self: Self, rhs: Self) -> Self\n\nAddition and concatenation operator. For arithmetic types, this function will compute the sum of the left and right hand values. For strings and lists, this function will concat the objects.\n\nArgs:\n\n​rhs (Self): Right hand value.\n\nReturns:\n\nThe sum or concatenated values.\n\n__sub__\n\n__sub__(self: Self, rhs: Self) -> Self\n\nSubtraction operator. Valid only for arithmetic types.\n\nArgs:\n\n​rhs (Self): Right hand value.\n\nReturns:\n\nThe difference.\n\n__mul__\n\n__mul__(self: Self, rhs: Self) -> Self\n\nMultiplication operator. Valid only for arithmetic types.\n\nArgs:\n\n​rhs (Self): Right hand value.\n\nReturns:\n\nThe product.\n\n__pow__\n\n__pow__(self: Self, rhs: Self) -> Self\n\nExponentiation operator. Valid only for arithmetic types.\n\nArgs:\n\n​rhs (Self): Right hand value.\n\nReturns:\n\nThe left hand value raised to the power of the right hand value.\n\n__and__\n\n__and__(self: Self, rhs: Self) -> Self\n\nBool AND operator. If the left hand value is False, return the left-hand value.\n\nArgs:\n\n​rhs (Self): Right hand value.\n\nReturns:\n\nThe current value if it is False.\n\n__or__\n\n__or__(self: Self, rhs: Self) -> Self\n\nBool OR operator. If the left hand value is True, return the left-hand value.\n\nArgs:\n\n​rhs (Self): Right hand value.\n\nReturns:\n\nThe current value if it is True.\n\n__radd__\n\n__radd__(self: Self, lhs: Self) -> Self\n\nReverse addition or concatenation operator.\n\nArgs:\n\n​lhs (Self): Left hand value.\n\nReturns:\n\nThe sum or concatenated value.\n\n__rsub__\n\n__rsub__(self: Self, lhs: Self) -> Self\n\nReverse subtraction operator.\n\nArgs:\n\n​lhs (Self): Left hand value.\n\nReturns:\n\nThe result of subtracting this from the left-hand-side value.\n\n__rmul__\n\n__rmul__(self: Self, lhs: Self) -> Self\n\nReverse multiplication operator.\n\nArgs:\n\n​lhs (Self): Left hand value.\n\nReturns:\n\nThe product.\n\n__rpow__\n\n__rpow__(self: Self, lhs: Self) -> Self\n\nReverse exponentiation operator.\n\nArgs:\n\n​lhs (Self): Left hand value.\n\nReturns:\n\nThe left hand value raised to the power of the right hand value.\n\n__rand__\n\n__rand__(self: Self, lhs: Self) -> Self\n\nReverse AND operator.\n\nArgs:\n\n​lhs (Self): Left hand value.\n\nReturns:\n\nThe bitwise AND of the left-hand-side value and this.\n\n__ror__\n\n__ror__(self: Self, lhs: Self) -> Self\n\nReverse OR operator.\n\nArgs:\n\n​lhs (Self): Left hand value.\n\nReturns:\n\nThe bitwise OR of the left-hand-side value and this.\n\n__iadd__\n\n__iadd__(inout self: Self, rhs: Self)\n\nIn-place addition or concatenation operator.\n\nArgs:\n\n​rhs (Self): Right hand value.\n__isub__\n\n__isub__(inout self: Self, rhs: Self)\n\nIn-place subtraction operator.\n\nArgs:\n\n​rhs (Self): Right hand value.\n__imul__\n\n__imul__(inout self: Self, rhs: Self)\n\nIn-place multiplication operator.\n\nArgs:\n\n​rhs (Self): Right hand value.\n__ipow__\n\n__ipow__(inout self: Self, rhs: Self)\n\nIn-place exponentiation operator.\n\nArgs:\n\n​rhs (Self): Right hand value.\n__iand__\n\n__iand__(inout self: Self, rhs: Self)\n\nIn-place AND operator.\n\nArgs:\n\n​rhs (Self): Right hand value.\n__ior__\n\n__ior__(inout self: Self, rhs: Self)\n\nIn-place OR operator.\n\nArgs:\n\n​rhs (Self): Right hand value.\n__int__\n\n__int__(self: Self) -> Int\n\nPerforms conversion to integer conversion according to Python semantics.\n\nReturns:\n\nThe Int representation of the object.\n\nappend\n\nappend(self: Self, value: Self)\n\nAppends a value to the list.\n\nArgs:\n\n​value (Self): The value to append.\n__len__\n\n__len__(self: Self) -> Int\n\nReturns the “length” of the object. Only strings, lists, and dictionaries have lengths.\n\nReturns:\n\nThe length of the string value or the number of elements in the list or dictionary value.\n\n__getattr__\n\n__getattr__(self: Self, key: StringLiteral) -> Self\n\n__setattr__\n\n__setattr__(inout self: Self, key: StringLiteral, value: Self)\n\n__call__\n\n__call__(self: Self) -> Self\n\n__call__(self: Self, arg0: Self) -> Self\n\n__call__(self: Self, arg0: Self, arg1: Self) -> Self\n\n__call__(self: Self, arg0: Self, arg1: Self, arg2: Self) -> Self\n\nprint\n\nprint(self: Self)\n\nPrints the value of the object.\n\nImplemented Traits:\n\n​Destructable\n​IntableRaising\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - len",
    "url": "https://docs.modular.com/mojo/stdlib/builtin/len.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\nbool\nbuiltin_list\nbuiltin_slice\nconstrained\ncoroutine\ndebug_assert\ndestructable\ndtype\nerror\nfile\nfloat_literal\nint\nint_literal\nio\nlen\nobject\nrange\nrebind\nsimd\nstr\nstring\nstring_literal\nstringref\ntuple\ntype_aliases\nvalue\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nSized\n__del__\n__len__\nSizedRaising\nlen\nlen\n\nModule\n\nProvides the len() function and its associated traits.\n\nThese are Mojo built-ins, so you don’t need to import them.\n\nSized\n\nThe Sized trait describes a type that has an integer length (such as a string or array).\n\nAny type that conforms to Sized or SizedRaising works with the built-in len() function.\n\nThe Sized trait requires a type to implement the __len__() method. For example:\n\n@value\nstruct Foo(Sized):\n    var length: Int\n\n    fn __len__(self) -> Int:\n        return self.length\n\nYou can pass an instance of Foo to the len() function to get its length:\n\nlet foo = Foo(42)\nprint(len(foo) == 42)\nTrue\n\nNote: If the __len__() method can raise an error, use the SizedRaising trait instead.\n\nFunctions:\n\n__del__\n\n__del__(owned self: T, /)\n\nDestroy the contained value.\n\nThe destructor receives an owned value and is expected to perform any actions needed to end the lifetime of the object. In the simplest case, this is nothing, and the language treats the object as being dead at the end of this function.\n\n__len__\n\n__len__(self: T) -> Int\n\nGet the length of the type.\n\nReturns:\n\nThe length of the type.\n\nImplemented Traits:\n\n​Destructable\nSizedRaising\n\nThe SizedRaising trait describes a type that has an integer length, which might raise an error if the length can’t be determined.\n\nAny type that conforms to Sized or SizedRaising works with the built-in len() function.\n\nThe SizedRaising trait requires a type to implement the __len__() method, which can raise an error. For example:\n\n@value\nstruct Foo(SizedRaising):\n    var length: Int\n\n    fn __len__(self) raises -> Int:\n        if self.length < 0:\n            raise Error(\"Length is negative\")\n        return self.length\n\nYou can pass an instance of Foo to the len() function to get its length:\n\nfn main() raises:\n    let foo = Foo(42)\n    print(len(foo) == 42)\nTrue\n\nFunctions:\n\n__del__\n\n__del__(owned self: T, /)\n\nDestroy the contained value.\n\nThe destructor receives an owned value and is expected to perform any actions needed to end the lifetime of the object. In the simplest case, this is nothing, and the language treats the object as being dead at the end of this function.\n\n__len__\n\n__len__(self: T) -> Int\n\nGet the length of the type.\n\nRaises: If the length cannot be computed.\n\nReturns:\n\nThe length of the type.\n\nImplemented Traits:\n\n​Destructable\nlen\n\nlen[T: Sized](value: T) -> Int\n\nGet the length of a value.\n\nParameters:\n\n​T (Sized): The Sized type.\n\nArgs:\n\n​value (T): The object to get the length of.\n\nReturns:\n\nThe length of the object.\n\nlen[T: SizedRaising](value: T) -> Int\n\nGet the length of a value.\n\nRaises: If the length cannot be computed.\n\nParameters:\n\n​T (SizedRaising): The Sized type.\n\nArgs:\n\n​value (T): The object to get the length of.\n\nReturns:\n\nThe length of the object.\n\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - io",
    "url": "https://docs.modular.com/mojo/stdlib/builtin/io.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\nbool\nbuiltin_list\nbuiltin_slice\nconstrained\ncoroutine\ndebug_assert\ndestructable\ndtype\nerror\nfile\nfloat_literal\nint\nint_literal\nio\nlen\nobject\nrange\nrebind\nsimd\nstr\nstring\nstring_literal\nstringref\ntuple\ntype_aliases\nvalue\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nput_new_line\nprint\nprint_no_newline\nio\n\nModule\n\nProvides utilities for working with input/output.\n\nThese are Mojo built-ins, so you don’t need to import them.\n\nput_new_line\n\nput_new_line()\n\nPrints a new line character.\n\nprint\n\nprint()\n\nPrints a newline.\n\nprint(t: DType)\n\nPrints a DType.\n\nArgs:\n\n​t (DType): The DType to print.\n\nprint(x: String)\n\nPrints a string.\n\nArgs:\n\n​x (String): The string to print.\n\nprint(x: StringRef)\n\nPrints a string.\n\nArgs:\n\n​x (StringRef): The string to print.\n\nprint(x: StringLiteral)\n\nPrints a string.\n\nArgs:\n\n​x (StringLiteral): The string to print.\n\nprint(x: Bool)\n\nPrints a boolean value.\n\nArgs:\n\n​x (Bool): The value to print.\n\nprint(x: FloatLiteral)\n\nPrints a float literal.\n\nArgs:\n\n​x (FloatLiteral): The value to print.\n\nprint(x: Int)\n\nPrints an integer value.\n\nArgs:\n\n​x (Int): The value to print.\n\nprint[simd_width: Int, type: DType](vec: SIMD[type, simd_width])\n\nPrints a SIMD value.\n\nParameters:\n\n​simd_width (Int): The SIMD vector width.\n​type (DType): The DType of the value.\n\nArgs:\n\n​vec (SIMD[type, simd_width]): The SIMD value to print.\n\nprint[simd_width: Int, type: DType](vec: ComplexSIMD[type, simd_width])\n\nPrints a SIMD value.\n\nParameters:\n\n​simd_width (Int): The SIMD vector width.\n​type (DType): The DType of the value.\n\nArgs:\n\n​vec (ComplexSIMD[type, simd_width]): The complex value to print.\n\nprint[type: DType](x: Atomic[type])\n\nPrints an atomic value.\n\nParameters:\n\n​type (DType): The DType of the atomic value.\n\nArgs:\n\n​x (Atomic[type]): The value to print.\n\nprint[length: Int](shape: DimList)\n\nPrints a DimList object.\n\nParameters:\n\n​length (Int): The length of the DimList.\n\nArgs:\n\n​shape (DimList): The DimList object to print.\n\nprint(obj: object)\n\nPrints an object type.\n\nArgs:\n\n​obj (object): The object to print.\n\nprint(err: Error)\n\nPrints an Error type.\n\nArgs:\n\n​err (Error): The Error to print.\n\nprint[T: Stringable, *Ts: Stringable](first: T, rest: !kgen.pack<:variadic<trait<_\"$builtin\"::_\"$str\"::_Stringable>> Ts>)\n\nPrints a sequence of elements, joined by spaces, followed by a newline.\n\nParameters:\n\n​T (Stringable): The first element type.\n​Ts (*Stringable): The remaining element types.\n\nArgs:\n\n​first (T): The first element.\n​rest (!kgen.pack<:variadic<trait<_\"$builtin\"::_\"$str\"::_Stringable>> Ts>): The remaining elements.\nprint_no_newline\n\nprint_no_newline[T: Stringable, *Ts: Stringable](first: T, rest: !kgen.pack<:variadic<trait<_\"$builtin\"::_\"$str\"::_Stringable>> Ts>)\n\nPrints a sequence of elements, joined by spaces.\n\nParameters:\n\n​T (Stringable): The first element type.\n​Ts (*Stringable): The remaining element types.\n\nArgs:\n\n​first (T): The first element.\n​rest (!kgen.pack<:variadic<trait<_\"$builtin\"::_\"$str\"::_Stringable>> Ts>): The remaining elements.\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - int_literal",
    "url": "https://docs.modular.com/mojo/stdlib/builtin/int_literal.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\nbool\nbuiltin_list\nbuiltin_slice\nconstrained\ncoroutine\ndebug_assert\ndestructable\ndtype\nerror\nfile\nfloat_literal\nint\nint_literal\nio\nlen\nobject\nrange\nrebind\nsimd\nstr\nstring\nstring_literal\nstringref\ntuple\ntype_aliases\nvalue\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nIntLiteral\n__init__\n__bool__\n__neg__\n__pos__\n__invert__\n__lt__\n__le__\n__eq__\n__ne__\n__gt__\n__ge__\n__add__\n__sub__\n__mul__\n__floordiv__\n__mod__\n__lshift__\n__rshift__\n__and__\n__or__\n__xor__\n__radd__\n__rsub__\n__rmul__\n__rfloordiv__\n__rlshift__\n__rrshift__\n__rand__\n__ror__\n__rxor__\n__iadd__\n__isub__\n__imul__\n__ifloordiv__\n__ilshift__\n__irshift__\n__iand__\n__ixor__\n__ior__\n__int__\n__str__\n__index__\nint_literal\n\nModule\n\nImplements the IntLiteral class.\n\nIntLiteral\n\nThis type represents a static integer literal value with infinite precision. They can’t be materialized at runtime and must be lowered to other integer types (like Int), but allow for compile-time operations that would overflow on Int and other fixed precision integer types.\n\nFields:\n\n​value (!kgen.int_literal): The underlying storage for the integer value.\n\nFunctions:\n\n__init__\n\n__init__() -> Self\n\nDefault constructor.\n\nReturns:\n\nThe constructed Self object.\n\n__init__(value: !kgen.int_literal) -> Self\n\nConstruct IntLiteral from the given mlir !kgen.int_literal value.\n\nArgs:\n\n​value (!kgen.int_literal): The init value.\n\nReturns:\n\nThe constructed IntLiteral object.\n\n__init__(value: Self) -> Self\n\nConstruct IntLiteral from another one.\n\nArgs:\n\n​value (Self): The init value.\n\nReturns:\n\nThe constructed IntLiteral object.\n\n__bool__\n\n__bool__(self: Self) -> Bool\n\nConvert this IntLiteral to Bool.\n\nReturns:\n\nFalse Bool value if the value is equal to 0 and True otherwise.\n\n__neg__\n\n__neg__(self: Self) -> Self\n\nReturn -self.\n\nReturns:\n\nThe -self value.\n\n__pos__\n\n__pos__(self: Self) -> Self\n\nReturn +self.\n\nReturns:\n\nThe +self value.\n\n__invert__\n\n__invert__(self: Self) -> Self\n\nReturn ~self.\n\nReturns:\n\nThe ~self value.\n\n__lt__\n\n__lt__(self: Self, rhs: Self) -> Bool\n\nCompare this IntLiteral to the RHS using LT comparison.\n\nArgs:\n\n​rhs (Self): The other IntLiteral to compare against.\n\nReturns:\n\nTrue if this IntLiteral is less-than the RHS IntLiteral and False otherwise.\n\n__le__\n\n__le__(self: Self, rhs: Self) -> Bool\n\nCompare this IntLiteral to the RHS using LE comparison.\n\nArgs:\n\n​rhs (Self): The other IntLiteral to compare against.\n\nReturns:\n\nTrue if this IntLiteral is less-or-equal than the RHS IntLiteral and False otherwise.\n\n__eq__\n\n__eq__(self: Self, rhs: Self) -> Bool\n\nCompare this IntLiteral to the RHS using EQ comparison.\n\nArgs:\n\n​rhs (Self): The other IntLiteral to compare against.\n\nReturns:\n\nTrue if this IntLiteral is equal to the RHS IntLiteral and False otherwise.\n\n__ne__\n\n__ne__(self: Self, rhs: Self) -> Bool\n\nCompare this IntLiteral to the RHS using NE comparison.\n\nArgs:\n\n​rhs (Self): The other IntLiteral to compare against.\n\nReturns:\n\nTrue if this IntLiteral is non-equal to the RHS IntLiteral and False otherwise.\n\n__gt__\n\n__gt__(self: Self, rhs: Self) -> Bool\n\nCompare this IntLiteral to the RHS using GT comparison.\n\nArgs:\n\n​rhs (Self): The other IntLiteral to compare against.\n\nReturns:\n\nTrue if this IntLiteral is greater-than the RHS IntLiteral and False otherwise.\n\n__ge__\n\n__ge__(self: Self, rhs: Self) -> Bool\n\nCompare this IntLiteral to the RHS using GE comparison.\n\nArgs:\n\n​rhs (Self): The other IntLiteral to compare against.\n\nReturns:\n\nTrue if this IntLiteral is greater-or-equal than the RHS IntLiteral and False otherwise.\n\n__add__\n\n__add__(self: Self, rhs: Self) -> Self\n\nReturn self + rhs.\n\nArgs:\n\n​rhs (Self): The value to add.\n\nReturns:\n\nself + rhs value.\n\n__sub__\n\n__sub__(self: Self, rhs: Self) -> Self\n\nReturn self - rhs.\n\nArgs:\n\n​rhs (Self): The value to subtract.\n\nReturns:\n\nself - rhs value.\n\n__mul__\n\n__mul__(self: Self, rhs: Self) -> Self\n\nReturn self * rhs.\n\nArgs:\n\n​rhs (Self): The value to multiply with.\n\nReturns:\n\nself * rhs value.\n\n__floordiv__\n\n__floordiv__(self: Self, rhs: Self) -> Self\n\nReturn self // rhs.\n\nArgs:\n\n​rhs (Self): The value to divide with.\n\nReturns:\n\nself // rhs value.\n\n__mod__\n\n__mod__(self: Self, rhs: Self) -> Self\n\nReturn the remainder of self divided by rhs.\n\nArgs:\n\n​rhs (Self): The value to divide on.\n\nReturns:\n\nThe remainder of dividing self by rhs.\n\n__lshift__\n\n__lshift__(self: Self, rhs: Self) -> Self\n\nReturn self << rhs.\n\nArgs:\n\n​rhs (Self): The value to shift with.\n\nReturns:\n\nself << rhs.\n\n__rshift__\n\n__rshift__(self: Self, rhs: Self) -> Self\n\nReturn self >> rhs.\n\nArgs:\n\n​rhs (Self): The value to shift with.\n\nReturns:\n\nself >> rhs.\n\n__and__\n\n__and__(self: Self, rhs: Self) -> Self\n\nReturn self & rhs.\n\nArgs:\n\n​rhs (Self): The RHS value.\n\nReturns:\n\nself & rhs.\n\n__or__\n\n__or__(self: Self, rhs: Self) -> Self\n\nReturn self | rhs.\n\nArgs:\n\n​rhs (Self): The RHS value.\n\nReturns:\n\nself | rhs.\n\n__xor__\n\n__xor__(self: Self, rhs: Self) -> Self\n\nReturn self ^ rhs.\n\nArgs:\n\n​rhs (Self): The RHS value.\n\nReturns:\n\nself ^ rhs.\n\n__radd__\n\n__radd__(self: Self, value: Self) -> Self\n\nReturn value + self.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue + self.\n\n__rsub__\n\n__rsub__(self: Self, value: Self) -> Self\n\nReturn value - self.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue - self.\n\n__rmul__\n\n__rmul__(self: Self, value: Self) -> Self\n\nReturn value * self.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue * self.\n\n__rfloordiv__\n\n__rfloordiv__(self: Self, value: Self) -> Self\n\nReturn value // self.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue // self.\n\n__rlshift__\n\n__rlshift__(self: Self, value: Self) -> Self\n\nReturn value << self.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue << self.\n\n__rrshift__\n\n__rrshift__(self: Self, value: Self) -> Self\n\nReturn value >> self.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue >> self.\n\n__rand__\n\n__rand__(self: Self, value: Self) -> Self\n\nReturn value & self.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue & self.\n\n__ror__\n\n__ror__(self: Self, value: Self) -> Self\n\nReturn value | self.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue | self.\n\n__rxor__\n\n__rxor__(self: Self, value: Self) -> Self\n\nReturn value ^ self.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue ^ self.\n\n__iadd__\n\n__iadd__(inout self: Self, rhs: Self)\n\nCompute self + rhs and save the result in self.\n\nArgs:\n\n​rhs (Self): The RHS value.\n__isub__\n\n__isub__(inout self: Self, rhs: Self)\n\nCompute self - rhs and save the result in self.\n\nArgs:\n\n​rhs (Self): The RHS value.\n__imul__\n\n__imul__(inout self: Self, rhs: Self)\n\nCompute self*rhs and save the result in self.\n\nArgs:\n\n​rhs (Self): The RHS value.\n__ifloordiv__\n\n__ifloordiv__(inout self: Self, rhs: Self)\n\nCompute self//rhs and save the result in self.\n\nArgs:\n\n​rhs (Self): The RHS value.\n__ilshift__\n\n__ilshift__(inout self: Self, rhs: Self)\n\nCompute self << rhs and save the result in self.\n\nArgs:\n\n​rhs (Self): The RHS value.\n__irshift__\n\n__irshift__(inout self: Self, rhs: Self)\n\nCompute self >> rhs and save the result in self.\n\nArgs:\n\n​rhs (Self): The RHS value.\n__iand__\n\n__iand__(inout self: Self, rhs: Self)\n\nCompute self & rhs and save the result in self.\n\nArgs:\n\n​rhs (Self): The RHS value.\n__ixor__\n\n__ixor__(inout self: Self, rhs: Self)\n\nCompute self ^ rhs and save the result in self.\n\nArgs:\n\n​rhs (Self): The RHS value.\n__ior__\n\n__ior__(inout self: Self, rhs: Self)\n\nCompute self|rhs and save the result in self.\n\nArgs:\n\n​rhs (Self): The RHS value.\n__int__\n\n__int__(self: Self) -> Int\n\nConvert from IntLiteral to Int.\n\nReturns:\n\nThe value as an integer.\n\n__str__\n\n__str__(self: Self) -> String\n\nConvert from IntLiteral to String.\n\nReturns:\n\nThe value as a string.\n\n__index__\n\n__index__(self: Self) -> Int\n\nReturn self converted to an integer, if self is suitable for use as an index into a list.\n\nReturns:\n\nThe corresponding Int value.\n\nImplemented Traits:\n\n​Destructable\n​Intable\n​Stringable\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - int",
    "url": "https://docs.modular.com/mojo/stdlib/builtin/int.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\nbool\nbuiltin_list\nbuiltin_slice\nconstrained\ncoroutine\ndebug_assert\ndestructable\ndtype\nerror\nfile\nfloat_literal\nint\nint_literal\nio\nlen\nobject\nrange\nrebind\nsimd\nstr\nstring\nstring_literal\nstringref\ntuple\ntype_aliases\nvalue\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nInt\n__init__\n__bool__\n__neg__\n__pos__\n__invert__\n__lt__\n__le__\n__eq__\n__ne__\n__gt__\n__ge__\n__add__\n__sub__\n__mul__\n__truediv__\n__floordiv__\n__mod__\n__pow__\n__lshift__\n__rshift__\n__and__\n__or__\n__xor__\n__radd__\n__rsub__\n__rmul__\n__rfloordiv__\n__rmod__\n__rpow__\n__rlshift__\n__rrshift__\n__rand__\n__ror__\n__rxor__\n__iadd__\n__isub__\n__imul__\n__itruediv__\n__ifloordiv__\n__imod__\n__ipow__\n__ilshift__\n__irshift__\n__iand__\n__ixor__\n__ior__\n__int__\n__str__\n__mlir_index__\n__index__\nIntable\nIntableRaising\nint\nint\n\nModule\n\nImplements the Int class.\n\nThese are Mojo built-ins, so you don’t need to import them.\n\nInt\n\nThis type represents an integer value.\n\nFields:\n\n​value (index): The underlying storage for the integer value.\n\nFunctions:\n\n__init__\n\n__init__() -> Self\n\nDefault constructor.\n\nReturns:\n\nThe constructed Int object.\n\n__init__(value: Self) -> Self\n\nConstruct Int from another Int value.\n\nArgs:\n\n​value (Self): The init value.\n\nReturns:\n\nThe constructed Int object.\n\n__init__(value: index) -> Self\n\nConstruct Int from the given index value.\n\nArgs:\n\n​value (index): The init value.\n\nReturns:\n\nThe constructed Int object.\n\n__init__(value: scalar<si16>) -> Self\n\nConstruct Int from the given Int16 value.\n\nArgs:\n\n​value (scalar<si16>): The init value.\n\nReturns:\n\nThe constructed Int object.\n\n__init__(value: scalar<si32>) -> Self\n\nConstruct Int from the given Int32 value.\n\nArgs:\n\n​value (scalar<si32>): The init value.\n\nReturns:\n\nThe constructed Int object.\n\n__init__(value: scalar<si64>) -> Self\n\nConstruct Int from the given Int64 value.\n\nArgs:\n\n​value (scalar<si64>): The init value.\n\nReturns:\n\nThe constructed Int object.\n\n__init__(value: scalar<index>) -> Self\n\nConstruct Int from the given Index value.\n\nArgs:\n\n​value (scalar<index>): The init value.\n\nReturns:\n\nThe constructed Int object.\n\n__init__(value: IntLiteral) -> Self\n\nConstruct Int from the given IntLiteral value.\n\nArgs:\n\n​value (IntLiteral): The init value.\n\nReturns:\n\nThe constructed Int object.\n\n__bool__\n\n__bool__(self: Self) -> Bool\n\nConvert this Int to Bool.\n\nReturns:\n\nFalse Bool value if the value is equal to 0 and True otherwise.\n\n__neg__\n\n__neg__(self: Self) -> Self\n\nReturn -self.\n\nReturns:\n\nThe -self value.\n\n__pos__\n\n__pos__(self: Self) -> Self\n\nReturn +self.\n\nReturns:\n\nThe +self value.\n\n__invert__\n\n__invert__(self: Self) -> Self\n\nReturn ~self.\n\nReturns:\n\nThe ~self value.\n\n__lt__\n\n__lt__(self: Self, rhs: Self) -> Bool\n\nCompare this Int to the RHS using LT comparison.\n\nArgs:\n\n​rhs (Self): The other Int to compare against.\n\nReturns:\n\nTrue if this Int is less-than the RHS Int and False otherwise.\n\n__le__\n\n__le__(self: Self, rhs: Self) -> Bool\n\nCompare this Int to the RHS using LE comparison.\n\nArgs:\n\n​rhs (Self): The other Int to compare against.\n\nReturns:\n\nTrue if this Int is less-or-equal than the RHS Int and False otherwise.\n\n__eq__\n\n__eq__(self: Self, rhs: Self) -> Bool\n\nCompare this Int to the RHS using EQ comparison.\n\nArgs:\n\n​rhs (Self): The other Int to compare against.\n\nReturns:\n\nTrue if this Int is equal to the RHS Int and False otherwise.\n\n__ne__\n\n__ne__(self: Self, rhs: Self) -> Bool\n\nCompare this Int to the RHS using NE comparison.\n\nArgs:\n\n​rhs (Self): The other Int to compare against.\n\nReturns:\n\nTrue if this Int is non-equal to the RHS Int and False otherwise.\n\n__gt__\n\n__gt__(self: Self, rhs: Self) -> Bool\n\nCompare this Int to the RHS using GT comparison.\n\nArgs:\n\n​rhs (Self): The other Int to compare against.\n\nReturns:\n\nTrue if this Int is greater-than the RHS Int and False otherwise.\n\n__ge__\n\n__ge__(self: Self, rhs: Self) -> Bool\n\nCompare this Int to the RHS using GE comparison.\n\nArgs:\n\n​rhs (Self): The other Int to compare against.\n\nReturns:\n\nTrue if this Int is greater-or-equal than the RHS Int and False otherwise.\n\n__add__\n\n__add__(self: Self, rhs: Self) -> Self\n\nReturn self + rhs.\n\nArgs:\n\n​rhs (Self): The value to add.\n\nReturns:\n\nself + rhs value.\n\n__sub__\n\n__sub__(self: Self, rhs: Self) -> Self\n\nReturn self - rhs.\n\nArgs:\n\n​rhs (Self): The value to subtract.\n\nReturns:\n\nself - rhs value.\n\n__mul__\n\n__mul__(self: Self, rhs: Self) -> Self\n\nReturn self * rhs.\n\nArgs:\n\n​rhs (Self): The value to multiply with.\n\nReturns:\n\nself * rhs value.\n\n__truediv__\n\n__truediv__(self: Self, rhs: Self) -> SIMD[f64, 1]\n\nReturn the floating point division of self and rhs.\n\nArgs:\n\n​rhs (Self): The value to divide on.\n\nReturns:\n\nfloat(self)/float(rhs) value.\n\n__floordiv__\n\n__floordiv__(self: Self, rhs: Self) -> Self\n\nReturn the division of self and rhs rounded down to the nearest integer.\n\nArgs:\n\n​rhs (Self): The value to divide on.\n\nReturns:\n\nfloor(self/rhs) value.\n\n__mod__\n\n__mod__(self: Self, rhs: Self) -> Self\n\nReturn the remainder of self divided by rhs.\n\nArgs:\n\n​rhs (Self): The value to divide on.\n\nReturns:\n\nThe remainder of dividing self by rhs.\n\n__pow__\n\n__pow__(self: Self, rhs: Self) -> Self\n\nReturn pow(self, rhs).\n\nComputes the power of an integer using the Russian Peasant Method.\n\nArgs:\n\n​rhs (Self): The RHS value.\n\nReturns:\n\nThe value of pow(self, rhs).\n\n__lshift__\n\n__lshift__(self: Self, rhs: Self) -> Self\n\nReturn self << rhs.\n\nArgs:\n\n​rhs (Self): The value to shift with.\n\nReturns:\n\nself << rhs.\n\n__rshift__\n\n__rshift__(self: Self, rhs: Self) -> Self\n\nReturn self >> rhs.\n\nArgs:\n\n​rhs (Self): The value to shift with.\n\nReturns:\n\nself >> rhs.\n\n__and__\n\n__and__(self: Self, rhs: Self) -> Self\n\nReturn self & rhs.\n\nArgs:\n\n​rhs (Self): The RHS value.\n\nReturns:\n\nself & rhs.\n\n__or__\n\n__or__(self: Self, rhs: Self) -> Self\n\nReturn self | rhs.\n\nArgs:\n\n​rhs (Self): The RHS value.\n\nReturns:\n\nself | rhs.\n\n__xor__\n\n__xor__(self: Self, rhs: Self) -> Self\n\nReturn self ^ rhs.\n\nArgs:\n\n​rhs (Self): The RHS value.\n\nReturns:\n\nself ^ rhs.\n\n__radd__\n\n__radd__(self: Self, value: Self) -> Self\n\nReturn value + self.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue + self.\n\n__rsub__\n\n__rsub__(self: Self, value: Self) -> Self\n\nReturn value - self.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue - self.\n\n__rmul__\n\n__rmul__(self: Self, value: Self) -> Self\n\nReturn value * self.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue * self.\n\n__rfloordiv__\n\n__rfloordiv__(self: Self, value: Self) -> Self\n\nReturn value // self.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue // self.\n\n__rmod__\n\n__rmod__(self: Self, value: Self) -> Self\n\nReturn value % self.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue % self.\n\n__rpow__\n\n__rpow__(self: Self, value: Self) -> Self\n\nReturn pow(value,self).\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\npow(value,self).\n\n__rlshift__\n\n__rlshift__(self: Self, value: Self) -> Self\n\nReturn value << self.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue << self.\n\n__rrshift__\n\n__rrshift__(self: Self, value: Self) -> Self\n\nReturn value >> self.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue >> self.\n\n__rand__\n\n__rand__(self: Self, value: Self) -> Self\n\nReturn value & self.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue & self.\n\n__ror__\n\n__ror__(self: Self, value: Self) -> Self\n\nReturn value | self.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue | self.\n\n__rxor__\n\n__rxor__(self: Self, value: Self) -> Self\n\nReturn value ^ self.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue ^ self.\n\n__iadd__\n\n__iadd__(inout self: Self, rhs: Self)\n\nCompute self + rhs and save the result in self.\n\nArgs:\n\n​rhs (Self): The RHS value.\n__isub__\n\n__isub__(inout self: Self, rhs: Self)\n\nCompute self - rhs and save the result in self.\n\nArgs:\n\n​rhs (Self): The RHS value.\n__imul__\n\n__imul__(inout self: Self, rhs: Self)\n\nCompute self*rhs and save the result in self.\n\nArgs:\n\n​rhs (Self): The RHS value.\n__itruediv__\n\n__itruediv__(inout self: Self, rhs: Self)\n\nCompute self / rhs, convert to int, and save the result in self.\n\nSince floor(self / rhs) is equivalent to self // rhs, this yields the same as __ifloordiv__.\n\nArgs:\n\n​rhs (Self): The RHS value.\n__ifloordiv__\n\n__ifloordiv__(inout self: Self, rhs: Self)\n\nCompute self // rhs and save the result in self.\n\nArgs:\n\n​rhs (Self): The RHS value.\n__imod__\n\n__imod__(inout self: Self, rhs: Self)\n\nCompute self % rhs and save the result in self.\n\nArgs:\n\n​rhs (Self): The RHS value.\n__ipow__\n\n__ipow__(inout self: Self, rhs: Self)\n\nCompute pow(self, rhs) and save the result in self.\n\nArgs:\n\n​rhs (Self): The RHS value.\n__ilshift__\n\n__ilshift__(inout self: Self, rhs: Self)\n\nCompute self << rhs and save the result in self.\n\nArgs:\n\n​rhs (Self): The RHS value.\n__irshift__\n\n__irshift__(inout self: Self, rhs: Self)\n\nCompute self >> rhs and save the result in self.\n\nArgs:\n\n​rhs (Self): The RHS value.\n__iand__\n\n__iand__(inout self: Self, rhs: Self)\n\nCompute self & rhs and save the result in self.\n\nArgs:\n\n​rhs (Self): The RHS value.\n__ixor__\n\n__ixor__(inout self: Self, rhs: Self)\n\nCompute self ^ rhs and save the result in self.\n\nArgs:\n\n​rhs (Self): The RHS value.\n__ior__\n\n__ior__(inout self: Self, rhs: Self)\n\nCompute self|rhs and save the result in self.\n\nArgs:\n\n​rhs (Self): The RHS value.\n__int__\n\n__int__(self: Self) -> Self\n\nGets the integral value (this is an identity function for Int).\n\nReturns:\n\nThe value as an integer.\n\n__str__\n\n__str__(self: Self) -> String\n\nGet the integer as a string.\n\nReturns:\n\nA string representation.\n\n__mlir_index__\n\n__mlir_index__(self: Self) -> index\n\nConvert to index.\n\nReturns:\n\nThe corresponding __mlir_type.index value.\n\n__index__\n\n__index__(self: Self) -> Self\n\nReturn self converted to an integer, if self is suitable for use as an index into a list.\n\nFor Int type this is simply the value.\n\nReturns:\n\nThe corresponding Int value.\n\nImplemented Traits:\n\n​CollectionElement\n​Copyable\n​Destructable\n​Intable\n​Movable\n​Stringable\nIntable\n\nThe Intable trait describes a type that can be converted to an Int.\n\nAny type that conforms to Intable or IntableRaising works with the built-in int() function.\n\nThis trait requires the type to implement the __int__() method. For example:\n\n@value\nstruct Foo(Intable):\n    var i: Int\n\n    fn __int__(self) -> Int:\n        return self.i\n\nNow you can use the int() function to convert a Foo to an Int:\n\nlet foo = Foo(42)\nprint(int(foo) == 42)\nTrue\n\nNote: If the __int__() method can raise an error, use the IntableRaising trait instead.\n\nFunctions:\n\n__del__\n\n__del__(owned self: T, /)\n\nDestroy the contained value.\n\nThe destructor receives an owned value and is expected to perform any actions needed to end the lifetime of the object. In the simplest case, this is nothing, and the language treats the object as being dead at the end of this function.\n\n__int__\n\n__int__(self: T) -> Int\n\nGet the integral representation of the value.\n\nReturns:\n\nThe integral representation of the value.\n\nImplemented Traits:\n\n​Destructable\nIntableRaising\n\nThe IntableRaising trait describes a type can be converted to an Int, but the conversion might raise an error.\n\nAny type that conforms to Intable or IntableRaising works with the built-in int() function.\n\nThis trait requires the type to implement the __int__() method, which can raise an error. For example:\n\n@value\nstruct Foo(IntableRaising):\n    var i: Int\n\n    fn __int__(self) raises -> Int:\n        return self.i\n\nNow you can use the int() function to convert a Foo to an Int:\n\nfn main() raises:\n    let x = Foo(42)\n    print(int(x) == 42)\nTrue\n\nFunctions:\n\n__del__\n\n__del__(owned self: T, /)\n\nDestroy the contained value.\n\nThe destructor receives an owned value and is expected to perform any actions needed to end the lifetime of the object. In the simplest case, this is nothing, and the language treats the object as being dead at the end of this function.\n\n__int__\n\n__int__(self: T) -> Int\n\nGet the integral representation of the value.\n\nRaises: If the type does not have an integral representation.\n\nReturns:\n\nThe integral representation of the type.\n\nImplemented Traits:\n\n​Destructable\nint\n\nint[T: Intable](value: T) -> Int\n\nGet the Int representation of the value.\n\nParameters:\n\n​T (Intable): The Intable type.\n\nArgs:\n\n​value (T): The object to get the integral representation of.\n\nReturns:\n\nThe integral representation of the value.\n\nint[T: IntableRaising](value: T) -> Int\n\nGet the Int representation of the value.\n\nRaises: If the type does not have an integral representation.\n\nParameters:\n\n​T (IntableRaising): The Intable type.\n\nArgs:\n\n​value (T): The object to get the integral representation of.\n\nReturns:\n\nThe integral representation of the value.\n\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - float_literal",
    "url": "https://docs.modular.com/mojo/stdlib/builtin/float_literal.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\nbool\nbuiltin_list\nbuiltin_slice\nconstrained\ncoroutine\ndebug_assert\ndestructable\ndtype\nerror\nfile\nfloat_literal\nint\nint_literal\nio\nlen\nobject\nrange\nrebind\nsimd\nstr\nstring\nstring_literal\nstringref\ntuple\ntype_aliases\nvalue\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nFloatLiteral\n__init__\n__bool__\n__neg__\n__lt__\n__le__\n__eq__\n__ne__\n__gt__\n__ge__\n__add__\n__sub__\n__mul__\n__truediv__\n__floordiv__\n__mod__\n__pow__\n__radd__\n__rsub__\n__rmul__\n__rtruediv__\n__rfloordiv__\n__rmod__\n__rpow__\n__iadd__\n__isub__\n__imul__\n__itruediv__\n__ifloordiv__\n__imod__\n__ipow__\n__str__\nto_int\n__int__\nfloat_literal\n\nModule\n\nImplements the FloatLiteral class.\n\nThese are Mojo built-ins, so you don’t need to import them.\n\nFloatLiteral\n\nMojo floating point literal type.\n\nAliases:\n\n​fp_type = scalar<f64>\n\nFields:\n\n​value (scalar<f64>): The underlying storage for the floating point value.\n\nFunctions:\n\n__init__\n\n__init__(value: Self) -> Self\n\nForwarding constructor.\n\nArgs:\n\n​value (Self): The double value.\n\nReturns:\n\nThe value.\n\n__init__(value: f64) -> Self\n\nCreate a double value from a builtin MLIR f64 value.\n\nArgs:\n\n​value (f64): The underlying MLIR value.\n\nReturns:\n\nA double value.\n\n__init__(value: Int) -> Self\n\nConvert an integer to a double value.\n\nArgs:\n\n​value (Int): The integer value.\n\nReturns:\n\nThe integer value as a double.\n\n__init__(value: IntLiteral) -> Self\n\nConvert an IntLiteral to a double value.\n\nArgs:\n\n​value (IntLiteral): The IntLiteral value.\n\nReturns:\n\nThe integer value as a double.\n\n__bool__\n\n__bool__(self: Self) -> Bool\n\nA double value is true if it is non-zero.\n\nReturns:\n\nTrue if non-zero.\n\n__neg__\n\n__neg__(self: Self) -> Self\n\nReturn the negation of the double value.\n\nReturns:\n\nThe negated double value.\n\n__lt__\n\n__lt__(self: Self, rhs: Self) -> Bool\n\nLess than comparison.\n\nArgs:\n\n​rhs (Self): The value to compare.\n\nReturns:\n\nTrue if this value is less than rhs.\n\n__le__\n\n__le__(self: Self, rhs: Self) -> Bool\n\nLess than or equal to comparison.\n\nArgs:\n\n​rhs (Self): The value to compare.\n\nReturns:\n\nTrue if this value is less than or equal to rhs.\n\n__eq__\n\n__eq__(self: Self, rhs: Self) -> Bool\n\nCompare for equality.\n\nArgs:\n\n​rhs (Self): The value to compare.\n\nReturns:\n\nTrue if they are equal.\n\n__ne__\n\n__ne__(self: Self, rhs: Self) -> Bool\n\nCompare for inequality.\n\nArgs:\n\n​rhs (Self): The value to compare.\n\nReturns:\n\nTrue if they are not equal.\n\n__gt__\n\n__gt__(self: Self, rhs: Self) -> Bool\n\nGreater than comparison.\n\nArgs:\n\n​rhs (Self): The value to compare.\n\nReturns:\n\nTrue if this value is greater than rhs.\n\n__ge__\n\n__ge__(self: Self, rhs: Self) -> Bool\n\nGreater than or equal to comparison.\n\nArgs:\n\n​rhs (Self): The value to compare.\n\nReturns:\n\nTrue if this value is greater than or equal to rhs.\n\n__add__\n\n__add__(self: Self, rhs: Self) -> Self\n\nAdd two doubles.\n\nArgs:\n\n​rhs (Self): The value to add.\n\nReturns:\n\nThe sum of the two values.\n\n__sub__\n\n__sub__(self: Self, rhs: Self) -> Self\n\nSubtract two doubles.\n\nArgs:\n\n​rhs (Self): The value to subtract.\n\nReturns:\n\nThe difference of the two values.\n\n__mul__\n\n__mul__(self: Self, rhs: Self) -> Self\n\nMultiply two doubles.\n\nArgs:\n\n​rhs (Self): The value to multiply.\n\nReturns:\n\nThe product of the two values.\n\n__truediv__\n\n__truediv__(self: Self, rhs: Self) -> Self\n\nDivide two doubles.\n\nArgs:\n\n​rhs (Self): The value to divide.\n\nReturns:\n\nThe quotient of the two values.\n\n__floordiv__\n\n__floordiv__(self: Self, rhs: Self) -> Self\n\nDivide two doubles and round towards negative infinity.\n\nArgs:\n\n​rhs (Self): The value to divide.\n\nReturns:\n\nThe quotient of the two values rounded towards negative infinity.\n\n__mod__\n\n__mod__(self: Self, rhs: Self) -> Self\n\nCompute the remainder of dividing by a value.\n\nArgs:\n\n​rhs (Self): The divisor.\n\nReturns:\n\nThe remainder of the division operation.\n\n__pow__\n\n__pow__(self: Self, rhs: Self) -> Self\n\nCompute the power.\n\nArgs:\n\n​rhs (Self): The exponent.\n\nReturns:\n\nThe current value raised to the exponent.\n\n__radd__\n\n__radd__(self: Self, rhs: Self) -> Self\n\nReversed addition operator.\n\nArgs:\n\n​rhs (Self): The value to add.\n\nReturns:\n\nThe sum of this and the given value.\n\n__rsub__\n\n__rsub__(self: Self, rhs: Self) -> Self\n\nReversed subtraction operator.\n\nArgs:\n\n​rhs (Self): The value to subtract from.\n\nReturns:\n\nThe result of subtracting this from the given value.\n\n__rmul__\n\n__rmul__(self: Self, rhs: Self) -> Self\n\nReversed multiplication operator.\n\nArgs:\n\n​rhs (Self): The value to multiply.\n\nReturns:\n\nThe product of the given number and this.\n\n__rtruediv__\n\n__rtruediv__(self: Self, rhs: Self) -> Self\n\nReversed division.\n\nArgs:\n\n​rhs (Self): The value to be divided by this.\n\nReturns:\n\nThe result of dividing the given value by this.\n\n__rfloordiv__\n\n__rfloordiv__(self: Self, rhs: Self) -> Self\n\nReversed floor division.\n\nArgs:\n\n​rhs (Self): The value to be floor-divided by this.\n\nReturns:\n\nThe result of dividing the given value by this, modulo any remainder.\n\n__rmod__\n\n__rmod__(self: Self, rhs: Self) -> Self\n\nReversed remainder.\n\nArgs:\n\n​rhs (Self): The divisor.\n\nReturns:\n\nThe remainder after dividing the given value by this.\n\n__rpow__\n\n__rpow__(self: Self, rhs: Self) -> Self\n\nReversed power.\n\nArgs:\n\n​rhs (Self): The number to be raised to the power of this.\n\nReturns:\n\nThe result of raising the given number by this value.\n\n__iadd__\n\n__iadd__(inout self: Self, rhs: Self)\n\nIn-place addition operator.\n\nArgs:\n\n​rhs (Self): The value to add.\n__isub__\n\n__isub__(inout self: Self, rhs: Self)\n\nIn-place subtraction operator.\n\nArgs:\n\n​rhs (Self): The value to subtract.\n__imul__\n\n__imul__(inout self: Self, rhs: Self)\n\nIn-place multiplication operator.\n\nArgs:\n\n​rhs (Self): The value to multiply.\n__itruediv__\n\n__itruediv__(inout self: Self, rhs: Self)\n\nIn-place division.\n\nArgs:\n\n​rhs (Self): The value to divide.\n__ifloordiv__\n\n__ifloordiv__(inout self: Self, rhs: Self)\n\nIn-place floor division.\n\nArgs:\n\n​rhs (Self): The value to divide.\n__imod__\n\n__imod__(inout self: Self, rhs: Self)\n\nIn-place remainder.\n\nArgs:\n\n​rhs (Self): The divisor.\n__ipow__\n\n__ipow__(inout self: Self, rhs: Self)\n\nIn-place power.\n\nArgs:\n\n​rhs (Self): The exponent.\n__str__\n\n__str__(self: Self) -> String\n\nGet the float as a string.\n\nReturns:\n\nA string representation.\n\nto_int\n\nto_int(self: Self) -> Int\n\nCasts to the floating point value to an Int. If there is a fractional component, then the value is truncated towards zero.\n\nReturns:\n\nThe value as an integer.\n\n__int__\n\n__int__(self: Self) -> Int\n\nCasts to the floating point value to an Int. If there is a fractional component, then the value is truncated towards zero.\n\nReturns:\n\nThe value as an integer.\n\nImplemented Traits:\n\n​Destructable\n​Intable\n​Stringable\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - file",
    "url": "https://docs.modular.com/mojo/stdlib/builtin/file.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\nbool\nbuiltin_list\nbuiltin_slice\nconstrained\ncoroutine\ndebug_assert\ndestructable\ndtype\nerror\nfile\nfloat_literal\nint\nint_literal\nio\nlen\nobject\nrange\nrebind\nsimd\nstr\nstring\nstring_literal\nstringref\ntuple\ntype_aliases\nvalue\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nFileHandle\n__init__\n__moveinit__\n__takeinit__\n__del__\nclose\nread\nread_bytes\nseek\nwrite\n__enter__\nopen\nfile\n\nModule\n\nImplements the file based methods.\n\nThese are Mojo built-ins, so you don’t need to import them.\n\nFor example, here’s how to read a file:\n\nvar  f = open(\"my_file.txt\", \"r\")\nprint(f.read())\nf.close()\n\nOr use a with statement to close the file automatically:\n\nwith open(\"my_file.txt\", \"r\") as f:\n  print(f.read())\nFileHandle\n\nFile handle to an opened file.\n\nFields:\n\n​handle (DTypePointer[invalid, 0]): The underlying pointer to the file handle.\n\nFunctions:\n\n__init__\n\n__init__(inout self: Self)\n\nDefault constructor.\n\n__init__(inout self: Self, path: StringLiteral, mode: StringLiteral)\n\nConstruct the FileHandle using the file path and mode.\n\nArgs:\n\n​path (StringLiteral): The file path.\n​mode (StringLiteral): The mode to open the file in (the mode can be “r” or “w”).\n\n__init__(inout self: Self, path: String, mode: String)\n\nConstruct the FileHandle using the file path and mode.\n\nArgs:\n\n​path (String): The file path.\n​mode (String): The mode to open the file in (the mode can be “r” or “w”).\n\n__init__(inout self: Self, path: StringRef, mode: StringRef)\n\nConstruct the FileHandle using the file path and string.\n\nArgs:\n\n​path (StringRef): The file path.\n​mode (StringRef): The mode to open the file in (the mode can be “r” or “w”).\n__moveinit__\n\n__moveinit__(inout self: Self, owned existing: Self)\n\nMoves constructor for the file handle.\n\nArgs:\n\n​existing (Self): The existing file handle.\n__takeinit__\n\n__takeinit__(inout self: Self, inout existing: Self)\n\nMoves constructor for the file handle.\n\nArgs:\n\n​existing (Self): The existing file handle.\n__del__\n\n__del__(owned self: Self)\n\nCloses the file handle.\n\nclose\n\nclose(inout self: Self)\n\nCloses the file handle.\n\nread\n\nread(self: Self, size: SIMD[si64, 1]) -> String\n\nReads the data from the file.\n\nArgs:\n\n​size (SIMD[si64, 1]): Requested number of bytes to read.\n\nReturns:\n\nThe contents of the file.\n\nread_bytes\n\nread_bytes(self: Self, size: SIMD[si64, 1]) -> Tensor[si8]\n\nRead from file buffer until we have size characters or we hit EOF. If size is negative or omitted, read until EOF.\n\nArgs:\n\n​size (SIMD[si64, 1]): Requested number of bytes to read.\n\nReturns:\n\nThe contents of the file.\n\nseek\n\nseek(self: Self, offset: SIMD[ui64, 1]) -> SIMD[ui64, 1]\n\nSeeks to the given offset in the file.\n\nRaises: An error if this file handle is invalid, or if file seek returned a failure.\n\nArgs:\n\n​offset (SIMD[ui64, 1]): The byte offset to seek to from the start of the file.\n\nReturns:\n\nThe resulting byte offset from the start of the file.\n\nwrite\n\nwrite(self: Self, data: StringLiteral)\n\nWrite the data to the file.\n\nArgs:\n\n​data (StringLiteral): The data to write to the file.\n\nwrite(self: Self, data: String)\n\nWrite the data to the file.\n\nArgs:\n\n​data (String): The data to write to the file.\n\nwrite(self: Self, data: StringRef)\n\nWrite the data to the file.\n\nArgs:\n\n​data (StringRef): The data to write to the file.\n__enter__\n\n__enter__(owned self: Self) -> Self\n\nThe function to call when entering the context.\n\nopen\n\nopen(path: StringLiteral, mode: StringLiteral) -> FileHandle\n\nOpens the file specified by path using the mode provided, returning a FileHandle.\n\nArgs:\n\n​path (StringLiteral): The path to the file to open.\n​mode (StringLiteral): The mode to open the file in (the mode can be “r” or “w”).\n\nReturns:\n\nA file handle.\n\nopen(path: StringRef, mode: StringRef) -> FileHandle\n\nOpens the file specified by path using the mode provided, returning a FileHandle.\n\nArgs:\n\n​path (StringRef): The path to the file to open.\n​mode (StringRef): The mode to open the file in (the mode can be “r” or “w”).\n\nReturns:\n\nA file handle.\n\nopen(path: String, mode: String) -> FileHandle\n\nOpens the file specified by path using the mode provided, returning a FileHandle.\n\nArgs:\n\n​path (String): The path to the file to open.\n​mode (String): The mode to open the file in.\n\nReturns:\n\nA file handle.\n\nopen(path: Path, mode: String) -> FileHandle\n\nOpens the file specified by path using the mode provided, returning a FileHandle.\n\nArgs:\n\n​path (Path): The path to the file to open.\n​mode (String): The mode to open the file in (the mode can be “r” or “w”).\n\nReturns:\n\nA file handle.\n\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - error",
    "url": "https://docs.modular.com/mojo/stdlib/builtin/error.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\nbool\nbuiltin_list\nbuiltin_slice\nconstrained\ncoroutine\ndebug_assert\ndestructable\ndtype\nerror\nfile\nfloat_literal\nint\nint_literal\nio\nlen\nobject\nrange\nrebind\nsimd\nstr\nstring\nstring_literal\nstringref\ntuple\ntype_aliases\nvalue\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nError\n__init__\n__copyinit__\n__del__\n__bool__\n__str__\n__repr__\nerror\n\nModule\n\nImplements the Error class.\n\nThese are Mojo built-ins, so you don’t need to import them.\n\nError\n\nThis type represents an Error.\n\nFields:\n\n​data (DTypePointer[si8, 0]): A pointer to the beginning of the string data being referenced.\n​loaded_length (Int): The length of the string being referenced. Error instances conditionally own their error message. To reduce the size of the error instance we use the sign bit of the length field to store the ownership value. When loaded_length is negative it indicates ownership and a free is executed in the destructor.\n\nFunctions:\n\n__init__\n\n__init__() -> Self\n\nDefault constructor.\n\nReturns:\n\nThe constructed Error object.\n\n__init__(value: StringLiteral) -> Self\n\nConstruct an Error object with a given string literal.\n\nArgs:\n\n​value (StringLiteral): The error message.\n\nReturns:\n\nThe constructed Error object.\n\n__init__(src: String) -> Self\n\nConstruct an Error object with a given string.\n\nArgs:\n\n​src (String): The error message.\n\nReturns:\n\nThe constructed Error object.\n\n__init__(src: StringRef) -> Self\n\nConstruct an Error object with a given string ref.\n\nArgs:\n\n​src (StringRef): The error message.\n\nReturns:\n\nThe constructed Error object.\n\n__copyinit__\n\n__copyinit__(existing: Self) -> Self\n\nCreates a deep copy of an existing error.\n\nReturns:\n\nThe copy of the original error.\n\n__del__\n\n__del__(owned self: Self)\n\nReleases memory if allocated.\n\n__bool__\n\n__bool__(self: Self) -> Bool\n\nReturns True if the error is set and false otherwise.\n\nReturns:\n\nTrue if the error object contains a value and False otherwise.\n\n__str__\n\n__str__(self: Self) -> String\n\nConverts the Error to string representation.\n\nReturns:\n\nA String of the error message.\n\n__repr__\n\n__repr__(self: Self) -> String\n\nConverts the Error to printable representation.\n\nReturns:\n\nA printable representation of the error message.\n\nImplemented Traits:\n\n​Destructable\n​Stringable\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - dtype",
    "url": "https://docs.modular.com/mojo/stdlib/builtin/dtype.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\nbool\nbuiltin_list\nbuiltin_slice\nconstrained\ncoroutine\ndebug_assert\ndestructable\ndtype\nerror\nfile\nfloat_literal\nint\nint_literal\nio\nlen\nobject\nrange\nrebind\nsimd\nstr\nstring\nstring_literal\nstringref\ntuple\ntype_aliases\nvalue\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nDType\n__eq__\n__ne__\n__str__\nget_value\nisa\nis_bool\nis_uint8\nis_int8\nis_uint16\nis_int16\nis_uint32\nis_int32\nis_uint64\nis_int64\nis_bfloat16\nis_float16\nis_float32\nis_tensor_float32\nis_float64\nis_index\nis_address\nis_unsigned\nis_signed\nis_integral\nis_floating_point\nsizeof\nbitwidth\ndispatch_integral\ndispatch_floating\ndispatch_arithmetic\ndtype\n\nModule\n\nImplements the DType class.\n\nThese are Mojo built-ins, so you don’t need to import them.\n\nDType\n\nRepresents DType and provides methods for working with it.\n\nAliases:\n\n​type = dtype\n​invalid = invalid: Represents an invalid or unknown data type.\n​bool = bool: Represents a boolean data type.\n​int8 = si8: Represents a signed integer type whose bitwidth is 8.\n​uint8 = ui8: Represents an unsigned integer type whose bitwidth is 8.\n​int16 = si16: Represents a signed integer type whose bitwidth is 16.\n​uint16 = ui16: Represents an unsigned integer type whose bitwidth is 16.\n​int32 = si32: Represents a signed integer type whose bitwidth is 32.\n​uint32 = ui32: Represents an unsigned integer type whose bitwidth is 32.\n​int64 = si64: Represents a signed integer type whose bitwidth is 64.\n​uint64 = ui64: Represents an unsigned integer type whose bitwidth is 64.\n​bfloat16 = bf16: Represents a brain floating point value whose bitwidth is 16.\n​float16 = f16: Represents an IEEE754-2008 binary16 floating point value.\n​float32 = f32: Represents an IEEE754-2008 binary32 floating point value.\n​tensor_float32 = tf32: Represents a special floating point format supported by NVIDIA Tensor Cores, with the same range as float32 and reduced precision (>=10 bits). Note that this type is only available on NVIDIA GPUs.\n​float64 = f64: Represents an IEEE754-2008 binary64 floating point value.\n​index = index: Represents an integral type whose bitwidth is the maximum integral value on the system.\n​address = address: Represents a pointer type whose bitwidth is the same as the bitwidth of the hardware’s pointer type (32-bit on 32-bit machines and 64-bit on 64-bit machines).\n\nFields:\n\n​value (dtype): The underlying storage for the DType value.\n\nFunctions:\n\n__eq__\n\n__eq__(self: Self, rhs: Self) -> Bool\n\nCompares one DType to another for equality.\n\nArgs:\n\n​rhs (Self): The DType to compare against.\n\nReturns:\n\nTrue if the DTypes are the same and False otherwise.\n\n__ne__\n\n__ne__(self: Self, rhs: Self) -> Bool\n\nCompares one DType to another for non-equality.\n\nArgs:\n\n​rhs (Self): The DType to compare against.\n\nReturns:\n\nFalse if the DTypes are the same and True otherwise.\n\n__str__\n\n__str__(self: Self) -> String\n\nGets the name of the DType.\n\nReturns:\n\nThe name of the dtype.\n\nget_value\n\nget_value(self: Self) -> dtype\n\nGets the associated internal kgen.dtype value.\n\nReturns:\n\nThe kgen.dtype value.\n\nisa\n\nisa[other: Self](self: Self) -> Bool\n\nChecks if this DType matches the other one, specified as a parameter.\n\nParameters:\n\n​other (Self): The DType to compare against.\n\nReturns:\n\nTrue if the DTypes are the same and False otherwise.\n\nis_bool\n\nis_bool(self: Self) -> Bool\n\nChecks if this DType is Bool.\n\nReturns:\n\nTrue if the DType is Bool and False otherwise.\n\nis_uint8\n\nis_uint8(self: Self) -> Bool\n\nChecks if this DType is UInt8.\n\nReturns:\n\nTrue if the DType is UInt8 and False otherwise.\n\nis_int8\n\nis_int8(self: Self) -> Bool\n\nChecks if this DType is Int8.\n\nReturns:\n\nTrue if the DType is Int8 and False otherwise.\n\nis_uint16\n\nis_uint16(self: Self) -> Bool\n\nChecks if this DType is UInt16.\n\nReturns:\n\nTrue if the DType is UInt16 and False otherwise.\n\nis_int16\n\nis_int16(self: Self) -> Bool\n\nChecks if this DType is Int16.\n\nReturns:\n\nTrue if the DType is Int16 and False otherwise.\n\nis_uint32\n\nis_uint32(self: Self) -> Bool\n\nChecks if this DType is UInt32.\n\nReturns:\n\nTrue if the DType is UInt32 and False otherwise.\n\nis_int32\n\nis_int32(self: Self) -> Bool\n\nChecks if this DType is Int32.\n\nReturns:\n\nTrue if the DType is Int32 and False otherwise.\n\nis_uint64\n\nis_uint64(self: Self) -> Bool\n\nChecks if this DType is UInt64.\n\nReturns:\n\nTrue if the DType is UInt64 and False otherwise.\n\nis_int64\n\nis_int64(self: Self) -> Bool\n\nChecks if this DType is Int64.\n\nReturns:\n\nTrue if the DType is Int64 and False otherwise.\n\nis_bfloat16\n\nis_bfloat16(self: Self) -> Bool\n\nChecks if this DType is BFloat16.\n\nReturns:\n\nTrue if the DType is BFloat16 and False otherwise.\n\nis_float16\n\nis_float16(self: Self) -> Bool\n\nChecks if this DType is Float16.\n\nReturns:\n\nTrue if the DType is Float16 and False otherwise.\n\nis_float32\n\nis_float32(self: Self) -> Bool\n\nChecks if this DType is Float32.\n\nReturns:\n\nTrue if the DType is Float32 and False otherwise.\n\nis_tensor_float32\n\nis_tensor_float32(self: Self) -> Bool\n\nChecks if this DType is Tensor Float32.\n\nReturns:\n\nTrue if the DType is Tensor Float32 and False otherwise.\n\nis_float64\n\nis_float64(self: Self) -> Bool\n\nChecks if this DType is Float64.\n\nReturns:\n\nTrue if the DType is Float64 and False otherwise.\n\nis_index\n\nis_index(self: Self) -> Bool\n\nChecks if this DType is Index.\n\nReturns:\n\nTrue if the DType is Index and False otherwise.\n\nis_address\n\nis_address(self: Self) -> Bool\n\nChecks if this DType is Address.\n\nReturns:\n\nTrue if the DType is Address and False otherwise.\n\nis_unsigned\n\nis_unsigned(self: Self) -> Bool\n\nReturns True if the type parameter is unsigned and False otherwise.\n\nReturns:\n\nReturns True if the input type parameter is unsigned.\n\nis_signed\n\nis_signed(self: Self) -> Bool\n\nReturns True if the type parameter is signed and False otherwise.\n\nReturns:\n\nReturns True if the input type parameter is signed.\n\nis_integral\n\nis_integral(self: Self) -> Bool\n\nReturns True if the type parameter is an integer and False otherwise.\n\nReturns:\n\nReturns True if the input type parameter is an integer.\n\nis_floating_point\n\nis_floating_point(self: Self) -> Bool\n\nReturns True if the type parameter is a floating-point and False otherwise.\n\nReturns:\n\nReturns True if the input type parameter is a floating-point.\n\nsizeof\n\nsizeof(self: Self) -> Int\n\nReturns the size in bytes of the current DType.\n\nReturns:\n\nReturns the size in bytes of the current DType and -1 if the size is unknown.\n\nbitwidth\n\nbitwidth(self: Self) -> Int\n\nReturns the size in bits of the current DType.\n\nReturns:\n\nReturns the size in bits of the current DType and -1 if the size is unknown.\n\ndispatch_integral\n\ndispatch_integral[func: fn[DType]() capturing -> None](self: Self)\n\nDispatches an integral function corresponding to the current DType.\n\nConstraints:\n\nDType must be integral.\n\nParameters:\n\n​func (fn[DType]() capturing -> None): A parametrized on dtype function to dispatch.\n\ndispatch_integral[func: fn[DType]() capturing -> None](self: Self, out_chain: OutputChainPtr)\n\nDispatches an integral function corresponding to the current DType.\n\nConstraints:\n\nDType must be integral.\n\nParameters:\n\n​func (fn[DType]() capturing -> None): A parametrized on dtype function to dispatch.\n\nArgs:\n\n​out_chain (OutputChainPtr): The output chain used to report errors.\ndispatch_floating\n\ndispatch_floating[func: fn[DType]() capturing -> None](self: Self)\n\nDispatches a floating-point function corresponding to the current DType.\n\nConstraints:\n\nDType must be floating-point.\n\nParameters:\n\n​func (fn[DType]() capturing -> None): A parametrized on dtype function to dispatch.\n\ndispatch_floating[func: fn[DType]() capturing -> None](self: Self, out_chain: OutputChainPtr)\n\nDispatches a floating-point function corresponding to the current DType.\n\nConstraints:\n\nDType must be floating-point or integral.\n\nParameters:\n\n​func (fn[DType]() capturing -> None): A parametrized on dtype function to dispatch.\n\nArgs:\n\n​out_chain (OutputChainPtr): The output chain used to report errors.\ndispatch_arithmetic\n\ndispatch_arithmetic[func: fn[DType]() capturing -> None](self: Self)\n\nDispatches a function corresponding to the current DType.\n\nParameters:\n\n​func (fn[DType]() capturing -> None): A parametrized on dtype function to dispatch.\n\ndispatch_arithmetic[func: fn[DType]() capturing -> None](self: Self, out_chain: OutputChainPtr)\n\nDispatches a function corresponding to the current DType.\n\nParameters:\n\n​func (fn[DType]() capturing -> None): A parametrized on dtype function to dispatch.\n\nArgs:\n\n​out_chain (OutputChainPtr): The output chain used to report errors.\n\nImplemented Traits:\n\n​Destructable\n​Stringable\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - destructable",
    "url": "https://docs.modular.com/mojo/stdlib/builtin/destructable.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\nbool\nbuiltin_list\nbuiltin_slice\nconstrained\ncoroutine\ndebug_assert\ndestructable\ndtype\nerror\nfile\nfloat_literal\nint\nint_literal\nio\nlen\nobject\nrange\nrebind\nsimd\nstr\nstring\nstring_literal\nstringref\ntuple\ntype_aliases\nvalue\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nDestructable\n__del__\ndestructable\n\nModule\n\nDefines the Destructable trait.\n\nThese are Mojo built-ins, so you don’t need to import them.\n\nDestructable\n\nThe Destructable trait describes a type that has a destructor.\n\nIn Mojo, a type that provide a destructor indicates to the language that it is an object with a lifetime whose destructor needs to be called whenever an instance of the object reaches the end of its lifetime. Hence, only non-trivial types may have destructors.\n\nAny composition of types that have lifetimes is also an object with a lifetime, and the resultant type receives a destructor regardless of whether the user explicitly defines one.\n\nAll types pessimistically require a destructor when used in generic functions. Hence, all Mojo traits are considered to inherit from Destructable, providing a default no-op destructor implementation for types that may need them.\n\nExample implementing the Destructable trait on Foo that frees the allocated memory:\n\n@value\nstruct Foo(Destructable):\n    var p: Pointer[Int]\n    var size: Int\n\n    fn __init__(inout self, size: Int):\n        self.p = Pointer[Int].alloc(size)\n        self.size = size\n\n    fn __del__(owned self):\n        print(\"--freeing allocated memory--\")\n        self.p.free()\n\nFunctions:\n\n__del__\n\n__del__(owned self: T, /)\n\nDestroy the contained value.\n\nThe destructor receives an owned value and is expected to perform any actions needed to end the lifetime of the object. In the simplest case, this is nothing, and the language treats the object as being dead at the end of this function.\n\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - debug_assert",
    "url": "https://docs.modular.com/mojo/stdlib/builtin/debug_assert.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\nbool\nbuiltin_list\nbuiltin_slice\nconstrained\ncoroutine\ndebug_assert\ndestructable\ndtype\nerror\nfile\nfloat_literal\nint\nint_literal\nio\nlen\nobject\nrange\nrebind\nsimd\nstr\nstring\nstring_literal\nstringref\ntuple\ntype_aliases\nvalue\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\ndebug_assert\ndebug_assert\n\nModule\n\nImplements a debug assert.\n\nThese are Mojo built-ins, so you don’t need to import them.\n\ndebug_assert\n\ndebug_assert(cond: Bool, msg: StringLiteral)\n\nAsserts that the condition is true.\n\nThe debug_assert is similar to assert in C++. It is a no-op in release builds.\n\nArgs:\n\n​cond (Bool): The bool value to assert.\n​msg (StringLiteral): The message to display on failure.\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - coroutine",
    "url": "https://docs.modular.com/mojo/stdlib/builtin/coroutine.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\nbool\nbuiltin_list\nbuiltin_slice\nconstrained\ncoroutine\ndebug_assert\ndestructable\ndtype\nerror\nfile\nfloat_literal\nint\nint_literal\nio\nlen\nobject\nrange\nrebind\nsimd\nstr\nstring\nstring_literal\nstringref\ntuple\ntype_aliases\nvalue\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nCoroutineContext\nCoroutine\nRaisingCoroutine\ncoroutine\n\nModule\n\nImplements classes and methods for coroutines.\n\nThese are Mojo built-ins, so you don’t need to import them.\n\nCoroutineContext\n\nRepresents a callback closure (fn_ptr + captures).\n\nCoroutine\n\nRepresents a coroutine.\n\nCoroutines can pause execution saving the state of the program (including values of local variables and the location of the next instruction to be executed). When the coroutine is resumed, execution continues from where it left off, with the saved state restored.\n\nParameters:\n\n​type (AnyRegType): Type of value returned upon completion of the coroutine.\n\nFunctions:\n\n__init__\n\n__init__(handle: !pop.coroutine<() -> !kgen.paramref<*\"type\">>) -> Self\n\nConstruct a coroutine object from a handle.\n\nArgs:\n\n​handle (!pop.coroutine<() -> !kgen.paramref<*\"type\">>): The init handle.\n\nReturns:\n\nThe constructed coroutine object.\n\n__del__\n\n__del__(owned self: Self)\n\nDestroy the coroutine object.\n\n__await__\n\n__await__(self: Self) -> *\"type\"\n\nSuspends the current coroutine until the coroutine is complete.\n\nReturns:\n\nThe coroutine promise.\n\nget_promise\n\nget_promise(self: Self) -> Pointer[*\"type\", 0]\n\nReturn the pointer to the beginning of the memory where the async function results are stored.\n\nReturns:\n\nThe coroutine promise.\n\nget\n\nget(self: Self) -> *\"type\"\n\nGet the value of the fulfilled coroutine promise.\n\nReturns:\n\nThe value of the fulfilled promise.\n\nget_ctx\n\nget_ctx[ctx_type: AnyRegType](self: Self) -> Pointer[ctx_type, 0]\n\nReturns the pointer to the coroutine context.\n\nParameters:\n\n​ctx_type (AnyRegType): The type of the coroutine context.\n\nReturns:\n\nThe coroutine context.\n\n__call__\n\n__call__(self: Self) -> *\"type\"\n\nExecute the coroutine synchronously.\n\nReturns:\n\nThe coroutine promise.\n\nRaisingCoroutine\n\nRepresents a coroutine that can raise.\n\nCoroutines can pause execution saving the state of the program (including values of local variables and the location of the next instruction to be executed). When the coroutine is resumed, execution continues from where it left off, with the saved state restored.\n\nParameters:\n\n​type (AnyRegType): Type of value returned upon completion of the coroutine.\n\nFunctions:\n\n__init__\n\n__init__(handle: !pop.coroutine<() throws -> !kgen.variant<!kgen.declref<_\"$builtin\"::_\"$error\"::_Error, !lit.metatype<_\"$builtin\"::_\"$error\"::_Error>>, *\"type\">>) -> Self\n\nConstruct a coroutine object from a handle.\n\nArgs:\n\n​handle (!pop.coroutine<() throws -> !kgen.variant<!kgen.declref<_\"$builtin\"::_\"$error\"::_Error, !lit.metatype<_\"$builtin\"::_\"$error\"::_Error>>, *\"type\">>): The init handle.\n\nReturns:\n\nThe constructed coroutine object.\n\n__del__\n\n__del__(owned self: Self)\n\nDestroy the coroutine object.\n\n__await__\n\n__await__(self: Self) -> *\"type\"\n\nSuspends the current coroutine until the coroutine is complete.\n\nReturns:\n\nThe coroutine promise.\n\nget_promise\n\nget_promise(self: Self) -> Pointer[Variant[Error, *\"type\"], 0]\n\nReturn the pointer to the beginning of the memory where the async function results are stored.\n\nReturns:\n\nThe coroutine promise.\n\nget\n\nget(self: Self) -> *\"type\"\n\nGet the value of the fulfilled coroutine promise.\n\nReturns:\n\nThe value of the fulfilled promise.\n\nget_ctx\n\nget_ctx[ctx_type: AnyRegType](self: Self) -> Pointer[ctx_type, 0]\n\nReturns the pointer to the coroutine context.\n\nParameters:\n\n​ctx_type (AnyRegType): The type of the coroutine context.\n\nReturns:\n\nThe coroutine context.\n\n__call__\n\n__call__(self: Self) -> *\"type\"\n\nExecute the coroutine synchronously.\n\nReturns:\n\nThe coroutine promise.\n\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - constrained",
    "url": "https://docs.modular.com/mojo/stdlib/builtin/constrained.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\nbool\nbuiltin_list\nbuiltin_slice\nconstrained\ncoroutine\ndebug_assert\ndestructable\ndtype\nerror\nfile\nfloat_literal\nint\nint_literal\nio\nlen\nobject\nrange\nrebind\nsimd\nstr\nstring\nstring_literal\nstringref\ntuple\ntype_aliases\nvalue\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nconstrained\nconstrained\n\nModule\n\nImplements compile time contraints.\n\nThese are Mojo built-ins, so you don’t need to import them.\n\nconstrained\n\nconstrained[cond: Bool, msg: StringLiteral]()\n\nCompile time checks that the condition is true.\n\nThe constrained is similar to static_assert in C++ and is used to introduce constraints on the enclosing function. In Mojo, the assert places a constraint on the function. The message is displayed when the assertion fails.\n\nParameters:\n\n​cond (Bool): The bool value to assert.\n​msg (StringLiteral): The message to display on failure.\n\nconstrained[cond: Bool]()\n\nCompile time checks that the condition is true.\n\nThe constrained is similar to static_assert in C++ and is used to introduce constraints on the enclosing function. In Mojo, the assert places a constraint on the function.\n\nParameters:\n\n​cond (Bool): The bool value to assert.\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - builtin_slice",
    "url": "https://docs.modular.com/mojo/stdlib/builtin/builtin_slice.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\nbool\nbuiltin_list\nbuiltin_slice\nconstrained\ncoroutine\ndebug_assert\ndestructable\ndtype\nerror\nfile\nfloat_literal\nint\nint_literal\nio\nlen\nobject\nrange\nrebind\nsimd\nstr\nstring\nstring_literal\nstringref\ntuple\ntype_aliases\nvalue\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nslice\n__init__\n__getitem__\n__eq__\n__ne__\n__len__\nbuiltin_slice\n\nModule\n\nImplements slice.\n\nThese are Mojo built-ins, so you don’t need to import them.\n\nslice\n\nRepresents a slice expression.\n\nObjects of this type are generated when slice syntax is used within square brackets, e.g.:\n\nlet msg: String = \"Hello Mojo\"\n\n# Both are equivalent and print \"Mojo\".\nprint(msg[6:])\nprint(msg.__getitem__(slice(6, len(msg))))\n\nFields:\n\n​start (Int): The starting index of the slice.\n​end (Int): The end index of the slice.\n​step (Int): The step increment value of the slice.\n\nFunctions:\n\n__init__\n\n__init__(end: Int) -> Self\n\nConstruct slice given the end value.\n\nArgs:\n\n​end (Int): The end value.\n\nReturns:\n\nThe constructed slice.\n\n__init__(start: Int, end: Int) -> Self\n\nConstruct slice given the start and end values.\n\nArgs:\n\n​start (Int): The start value.\n​end (Int): The end value.\n\nReturns:\n\nThe constructed slice.\n\n__init__[T0: AnyRegType, T1: AnyRegType, T2: AnyRegType](start: T0, end: T1, step: T2) -> Self\n\nConstruct slice given the start, end and step values.\n\nParameters:\n\n​T0 (AnyRegType): Type of the start value.\n​T1 (AnyRegType): Type of the end value.\n​T2 (AnyRegType): Type of the step value.\n\nArgs:\n\n​start (T0): The start value.\n​end (T1): The end value.\n​step (T2): The step value.\n\nReturns:\n\nThe constructed slice.\n\n__getitem__\n\n__getitem__(self: Self, idx: Int) -> Int\n\nGet the slice index.\n\nArgs:\n\n​idx (Int): The index.\n\nReturns:\n\nThe slice index.\n\n__eq__\n\n__eq__(self: Self, other: Self) -> Bool\n\nCompare this slice to the other.\n\nArgs:\n\n​other (Self): The slice to compare to.\n\nReturns:\n\nTrue if start, end, and step values of this slice match the corresponding values of the other slice and False otherwise.\n\n__ne__\n\n__ne__(self: Self, other: Self) -> Bool\n\nCompare this slice to the other.\n\nArgs:\n\n​other (Self): The slice to compare to.\n\nReturns:\n\nFalse if start, end, and step values of this slice match the corresponding values of the other slice and True otherwise.\n\n__len__\n\n__len__(self: Self) -> Int\n\nReturn the length of the slice.\n\nReturns:\n\nThe length of the slice.\n\nImplemented Traits:\n\n​Destructable\n​Sized\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - builtin_list",
    "url": "https://docs.modular.com/mojo/stdlib/builtin/builtin_list.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\nbool\nbuiltin_list\nbuiltin_slice\nconstrained\ncoroutine\ndebug_assert\ndestructable\ndtype\nerror\nfile\nfloat_literal\nint\nint_literal\nio\nlen\nobject\nrange\nrebind\nsimd\nstr\nstring\nstring_literal\nstringref\ntuple\ntype_aliases\nvalue\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nListLiteral\n__init__\n__len__\nget\nVariadicList\nVariadicListMem\nbuiltin_list\n\nModule\n\nImplements the ListLiteral class.\n\nThese are Mojo built-ins, so you don’t need to import them.\n\nListLiteral\n\nThe type of a literal heterogenous list expression.\n\nA list consists of zero or more values, separated by commas.\n\nParameters:\n\n​Ts (*AnyRegType): The type of the elements.\n\nFields:\n\n​storage (!kgen.pack<Ts>): The underlying storage for the list.\n\nFunctions:\n\n__init__\n\n__init__(args: !kgen.pack<Ts>) -> Self\n\nConstruct the list literal from the given values.\n\nArgs:\n\n​args (!kgen.pack<Ts>): The init values.\n\nReturns:\n\nThe constructed ListLiteral.\n\n__len__\n\n__len__(self: Self) -> Int\n\nGet the list length.\n\nReturns:\n\nThe length of this ListLiteral.\n\nget\n\nget[i: Int, T: AnyRegType](self: Self) -> T\n\nGet a list element at the given index.\n\nParameters:\n\n​i (Int): The element index.\n​T (AnyRegType): The element type.\n\nReturns:\n\nThe element at the given index.\n\nImplemented Traits:\n\n​Destructable\n​Sized\nVariadicList\n\nA utility class to access variadic function arguments. Provides a “list” view of the function argument so that the size of the argument list and each individual argument can be accessed.\n\nParameters:\n\n​type (AnyRegType): The type of the elements in the list.\n\nAliases:\n\n​StorageType = variadic<*\"type\">\n​IterType = _VariadicListIter[*\"type\", VariadicList[*\"type\"], __getitem__[*\"type\"]]\n\nFields:\n\n​value (variadic<*\"type\">): The underlying storage for the variadic list.\n\nFunctions:\n\n__init__\n\n__init__(*value: *\"type\") -> Self\n\nConstructs a VariadicList from a variadic list of arguments.\n\nArgs:\n\n​value (**\"type\"): The variadic argument list to construct the variadic list with.\n\nReturns:\n\nThe VariadicList constructed.\n\n__init__(*value: *\"type\") -> Self\n\nConstructs a VariadicList from a variadic argument type.\n\nArgs:\n\n​value (**\"type\"): The variadic argument to construct the list with.\n\nReturns:\n\nThe VariadicList constructed.\n\n__getitem__\n\n__getitem__(self: Self, index: Int) -> *\"type\"\n\nGets a single element on the variadic list.\n\nArgs:\n\n​index (Int): The index of the element to access on the list.\n\nReturns:\n\nThe element on the list corresponding to the given index.\n\n__len__\n\n__len__(self: Self) -> Int\n\nGets the size of the list.\n\nReturns:\n\nThe number of elements on the variadic list.\n\n__iter__\n\n__iter__(self: Self) -> _VariadicListIter[*\"type\", VariadicList[*\"type\"], __getitem__[*\"type\"]]\n\nIterate over the list.\n\nReturns:\n\nAn iterator to the start of the list.\n\nImplemented Traits:\n\n​Destructable\n​Sized\nVariadicListMem\n\nA utility class to access variadic function arguments of memory-only types that may have ownership. It exposes pointers to the elements in a way that can be enumerated. Each element may be accessed with __get_address_as_lvalue.\n\nParameters:\n\n​type (AnyRegType): The type of the elements in the list.\n\nAliases:\n\n​StorageType = variadic<pointer<*\"type\">>\n​IterType = _VariadicListIter[pointer<*\"type\">, VariadicListMem[*\"type\"], __getitem__[*\"type\"]]\n\nFields:\n\n​value (variadic<pointer<*\"type\">>): The underlying storage, a variadic list of pointers to elements of the given type.\n\nFunctions:\n\n__init__\n\n__init__(*value: pointer<*\"type\">) -> Self\n\nConstructs a VariadicList from a variadic argument type.\n\nArgs:\n\n​value (*pointer<*\"type\">): The variadic argument to construct the list with.\n\nReturns:\n\nThe VariadicList constructed.\n\n__getitem__\n\n__getitem__(self: Self, index: Int) -> pointer<*\"type\">\n\nGets a single element on the variadic list.\n\nArgs:\n\n​index (Int): The index of the element to access on the list.\n\nReturns:\n\nA low-level pointer to the element on the list corresponding to the given index.\n\n__len__\n\n__len__(self: Self) -> Int\n\nGets the size of the list.\n\nReturns:\n\nThe number of elements on the variadic list.\n\n__iter__\n\n__iter__(self: Self) -> _VariadicListIter[pointer<*\"type\">, VariadicListMem[*\"type\"], __getitem__[*\"type\"]]\n\nIterate over the list.\n\nReturns:\n\nAn iterator to the start of the list.\n\nImplemented Traits:\n\n​Destructable\n​Sized\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - bool",
    "url": "https://docs.modular.com/mojo/stdlib/builtin/bool.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\nbool\nbuiltin_list\nbuiltin_slice\nconstrained\ncoroutine\ndebug_assert\ndestructable\ndtype\nerror\nfile\nfloat_literal\nint\nint_literal\nio\nlen\nobject\nrange\nrebind\nsimd\nstr\nstring\nstring_literal\nstringref\ntuple\ntype_aliases\nvalue\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nBool\n__init__\n__bool__\n__mlir_i1__\n__invert__\n__eq__\n__ne__\n__and__\n__or__\n__xor__\n__rand__\n__ror__\n__rxor__\n__str__\nbool\n\nModule\n\nImplements the Bool class.\n\nThese are Mojo built-ins, so you don’t need to import them.\n\nBool\n\nThe primitive Bool scalar value used in Mojo.\n\nFields:\n\n​value (scalar<bool>): The underlying storage of the boolean value.\n\nFunctions:\n\n__init__\n\n__init__(value: i1) -> Self\n\nConstruct a Bool value given a __mlir_type.i1 value.\n\nArgs:\n\n​value (i1): The initial __mlir_type.i1 value.\n\nReturns:\n\nThe constructed Bool value.\n\n__init__(value: Self) -> Self\n\nConstruct a Bool value given a __mlir_type.i1 value.\n\nArgs:\n\n​value (Self): The initial __mlir_type.i1 value.\n\nReturns:\n\nThe constructed Bool value.\n\n__init__[width: Int](value: SIMD[bool, width]) -> Self\n\nConstruct a Bool value given a SIMD value.\n\nIf there is more than a single element in the SIMD value, then value is reduced using the and operator.\n\nArgs:\n\n​value (SIMD[bool, width]): The initial SIMD value.\n\nReturns:\n\nThe constructed Bool value.\n\n__bool__\n\n__bool__(self: Self) -> Self\n\nConvert to Bool.\n\nReturns:\n\nThis value.\n\n__mlir_i1__\n\n__mlir_i1__(self: Self) -> i1\n\nConvert this Bool to __mlir_type.i1.\n\nThis method is a special hook used by the compiler to test boolean objects in control flow conditions. It should be implemented by Bool but not other general boolean convertible types (they should implement __bool__ instead).\n\nReturns:\n\nThe underlying value for the Bool.\n\n__invert__\n\n__invert__(self: Self) -> Self\n\nInverts the Bool value.\n\nReturns:\n\nTrue if the object is false and False otherwise.\n\n__eq__\n\n__eq__(self: Self, rhs: Self) -> Self\n\nCompare this Bool to RHS.\n\nPerforms an equality comparison between the Bool value and the argument. This method gets invoked when a user uses the == infix operator.\n\nArgs:\n\n​rhs (Self): The rhs value of the equality statement.\n\nReturns:\n\nTrue if the two values match and False otherwise.\n\n__ne__\n\n__ne__(self: Self, rhs: Self) -> Self\n\nCompare this Bool to RHS.\n\nPerforms a non-equality comparison between the Bool value and the argument. This method gets invoked when a user uses the != infix operator.\n\nArgs:\n\n​rhs (Self): The rhs value of the non-equality statement.\n\nReturns:\n\nFalse if the two values do match and True otherwise.\n\n__and__\n\n__and__(self: Self, rhs: Self) -> Self\n\nCompute self & rhs.\n\nBitwise and’s the Bool value with the argument. This method gets invoked when a user uses the and infix operator.\n\nArgs:\n\n​rhs (Self): The rhs value of the and statement.\n\nReturns:\n\nself & rhs.\n\n__or__\n\n__or__(self: Self, rhs: Self) -> Self\n\nCompute self | rhs.\n\nBitwise or’s the Bool value with the argument. This method gets invoked when a user uses the or infix operator.\n\nArgs:\n\n​rhs (Self): The rhs value of the or statement.\n\nReturns:\n\nself | rhs.\n\n__xor__\n\n__xor__(self: Self, rhs: Self) -> Self\n\nCompute self ^ rhs.\n\nBitwise Xor’s the Bool value with the argument. This method gets invoked when a user uses the ^ infix operator.\n\nArgs:\n\n​rhs (Self): The rhs value of the xor statement.\n\nReturns:\n\nself ^ rhs.\n\n__rand__\n\n__rand__(self: Self, value: Self) -> Self\n\nReturn value & self.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue & self.\n\n__ror__\n\n__ror__(self: Self, value: Self) -> Self\n\nReturn value | self.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue | self.\n\n__rxor__\n\n__rxor__(self: Self, value: Self) -> Self\n\nReturn value ^ self.\n\nArgs:\n\n​value (Self): The other value.\n\nReturns:\n\nvalue ^ self.\n\n__str__\n\n__str__(self: Self) -> String\n\nGet the bool as a string.\n\nReturns:\n\nA string representation.\n\nImplemented Traits:\n\n​Destructable\n​Stringable\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - benchmark",
    "url": "https://docs.modular.com/mojo/stdlib/benchmark/benchmark.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbenchmark\nbuiltin\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nBatch\nmean\nUnit\nReport\nrun\nclobber_memory\nkeep\nbenchmark\n\nModule\n\nImplements the benchmark module for runtime benchmarking.\n\nYou can import these APIs from the benchmark package. For example:\n\nimport benchmark\nfrom time import sleep\n\nYou can pass any fn as a parameter into benchmark.run[...](), it will return a Report where you can get the mean, duration, max, and more:\n\nfn sleeper():\n    sleep(.01)\n\nlet report = benchmark.run[sleeper]()\nprint(report.mean())\n0.012256487394957985\n\nYou can print a full report:\n\nreport.print()\n---------------------\nBenchmark Report (s)\n---------------------\nMean: 0.012265747899159664\nTotal: 1.459624\nIters: 119\nWarmup Mean: 0.01251\nWarmup Total: 0.025020000000000001\nWarmup Iters: 2\nFastest Mean: 0.0121578\nSlowest Mean: 0.012321428571428572\n\n\nOr all the batch runs:\n\nreport.print_full()\n---------------------\nBenchmark Report (s)\n---------------------\nMean: 0.012368649122807017\nTotal: 1.410026\nIters: 114\nWarmup Mean: 0.0116705\nWarmup Total: 0.023341000000000001\nWarmup Iters: 2\nFastest Mean: 0.012295586956521738\nSlowest Mean: 0.012508099999999999\n\nBatch: 1\nIterations: 20\nMean: 0.012508099999999999\nDuration: 0.250162\n\nBatch: 2\nIterations: 46\nMean: 0.012295586956521738\nDuration: 0.56559700000000002\n\nBatch: 3\nIterations: 48\nMean: 0.012380562499999999\nDuration: 0.59426699999999999\n\nIf you want to use a different time unit you can bring in the Unit and pass it in as an argument:\n\nfrom benchmark import Unit\n\nreport.print(Unit.ms)\n---------------------\nBenchmark Report (ms)\n---------------------\nMean: 0.012312411764705882\nTotal: 1.465177\nIters: 119\nWarmup Mean: 0.012505499999999999\nWarmup Total: 0.025010999999999999\nWarmup Iters: 2\nFastest Mean: 0.012015649999999999\nSlowest Mean: 0.012421204081632654\n\nThe unit’s are just aliases for StringLiteral, so you can for example:\n\nprint(report.mean(\"ms\"))\n12.199145299145298\n\nBenchmark.run takes four arguments to change the behaviour, to set warmup iterations to 5:\n\nr = benchmark.run[sleeper](5)\n0.012004808080808081\n\nTo set 1 warmup iteration, 2 max iterations, a min total time of 3 sec, and a max total time of 4 s:\n\nr = benchmark.run[sleeper](1, 2, 3, 4)\n\nNote that the min total time will take precedence over max iterations\n\nBatch\n\nA batch of benchmarks, the benchmark.run() function works out how many iterations to run in each batch based the how long the previous iterations took.\n\nFields:\n\n​duration (Int): Total duration of batch stored as nanoseconds.\n​iterations (Int): Total iterations in the batch.\n\nFunctions:\n\nmean\n\nmean(self: Self, unit: String) -> SIMD[f64, 1]\n\nReturns the average duration of the batch.\n\nArgs:\n\n​unit (String): The time unit to display for example: ns, ms, s (default s).\n\nReturns:\n\nThe average duration of the batch.\n\nImplemented Traits:\n\n​CollectionElement\n​Copyable\n​Destructable\n​Movable\nUnit\n\nTime Unit used by Benchmark Report.\n\nAliases:\n\n​ns = \"ns\": Nanoseconds\n​ms = \"ms\": Milliseconds\n​s = \"s\": Seconds\nReport\n\nContains the average execution time, iterations, min and max of each batch.\n\nFields:\n\n​warmup_iters (Int): The total warmup iterations.\n​warmup_duration (Int): The total duration it took to warmup.\n​runs (DynamicVector[Batch]): A DynamicVector of benchmark runs.\n\nFunctions:\n\n__init__\n\n__init__(inout self: Self)\n\nDefault initializer for the Report.\n\nSets all values to 0\n\n__copyinit__\n\n__copyinit__(inout self: Self, existing: Self)\n\nCreates a shallow copy (it doesn’t copy the data).\n\nArgs:\n\n​existing (Self): The Report to copy.\niters\n\niters(self: Self) -> Int\n\nThe total benchmark iterations.\n\nReturns:\n\nThe total benchmark iterations.\n\nduration\n\nduration(self: Self, unit: String) -> SIMD[f64, 1]\n\nThe total duration it took to run all benchmarks.\n\nArgs:\n\n​unit (String): The time unit to display for example: ns, ms, s (default s).\n\nReturns:\n\nThe total duration it took to run all benchmarks.\n\nmean\n\nmean(self: Self, unit: String) -> SIMD[f64, 1]\n\nThe average duration of all benchmark runs.\n\nArgs:\n\n​unit (String): The time unit to display for example: ns, ms, s (default s).\n\nReturns:\n\nThe average duration of all benchmark runs.\n\nmin\n\nmin(self: Self, unit: String) -> SIMD[f64, 1]\n\nThe batch of benchmarks that was the fastest to run.\n\nArgs:\n\n​unit (String): The time unit to display for example: ns, ms, s (default s).\n\nReturns:\n\nThe fastest duration out of all batches.\n\nmax\n\nmax(self: Self, unit: String) -> SIMD[f64, 1]\n\nThe batch of benchmarks that was the slowest to run.\n\nArgs:\n\n​unit (String): The time unit to display for example: ns, ms, s (default s).\n\nReturns:\n\nThe slowest duration out of all batches.\n\nprint\n\nprint(self: Self, unit: String)\n\nPrints out the shortened version of the report.\n\nArgs:\n\n​unit (String): The time unit to display for example: ns, ms, s (default s).\nprint_full\n\nprint_full(self: Self, unit: String)\n\nPrints out the full version of the report with each batch of benchmark runs.\n\nArgs:\n\n​unit (String): The time unit to display for example: ns, ms, s (default s).\nrun\n\nrun[func: fn() -> None](num_warmup: Int, max_iters: Int, min_runtime_secs: SIMD[f64, 1], max_runtime_secs: SIMD[f64, 1], max_batch_size: Int) -> Report\n\nBenchmarks the function passed in as a parameter.\n\nBenchmarking continues until ‘min_time_ns’ has elapsed and either max_time_ns OR max_iters is achieved.\n\nParameters:\n\n​func (fn() -> None): The function to benchmark.\n\nArgs:\n\n​num_warmup (Int): Number of warmup iterations to run before starting benchmarking (default 2).\n​max_iters (Int): Max number of iterations to run (default 1_000_000_000).\n​min_runtime_secs (SIMD[f64, 1]): Upper bound on benchmarking time in secs (default 2).\n​max_runtime_secs (SIMD[f64, 1]): Lower bound on benchmarking time in secs (default 60).\n​max_batch_size (Int): The maximum number of iterations to perform per time measurement.\n\nReturns:\n\nAverage execution time of func in ns.\n\nrun[func: fn() capturing -> None](num_warmup: Int, max_iters: Int, min_runtime_secs: SIMD[f64, 1], max_runtime_secs: SIMD[f64, 1], max_batch_size: Int) -> Report\n\nBenchmarks the function passed in as a parameter.\n\nBenchmarking continues until ‘min_time_ns’ has elapsed and either max_time_ns OR max_iters is achieved.\n\nParameters:\n\n​func (fn() capturing -> None): The function to benchmark.\n\nArgs:\n\n​num_warmup (Int): Number of warmup iterations to run before starting benchmarking (default 2).\n​max_iters (Int): Max number of iterations to run (default 1_000_000_000).\n​min_runtime_secs (SIMD[f64, 1]): Upper bound on benchmarking time in secs (default 2).\n​max_runtime_secs (SIMD[f64, 1]): Lower bound on benchmarking time in secs (default 60).\n​max_batch_size (Int): The maximum number of iterations to perform per time measurement.\n\nReturns:\n\nAverage execution time of func in ns.\n\nclobber_memory\n\nclobber_memory()\n\nForces all pending memory writes to be flushed to memory.\n\nThis ensures that the compiler does not optimize away memory writes if it deems them to be not neccessary. In effect, this operation acts a barrier to memory reads and writes.\n\nkeep\n\nkeep(val: Bool)\n\nProvides a hint to the compiler to not optimize the variable use away.\n\nThis is useful in benchmarking to avoid the compiler not deleting the code to be benchmarked because the variable is not used in a side-effecting manner.\n\nArgs:\n\n​val (Bool): The value to not optimize away.\n\nkeep(val: Int)\n\nProvides a hint to the compiler to not optimize the variable use away.\n\nThis is useful in benchmarking to avoid the compiler not deleting the code to be benchmarked because the variable is not used in a side-effecting manner.\n\nArgs:\n\n​val (Int): The value to not optimize away.\n\nkeep[type: DType, simd_width: Int](val: SIMD[type, simd_width])\n\nProvides a hint to the compiler to not optimize the variable use away.\n\nThis is useful in benchmarking to avoid the compiler not deleting the code to be benchmarked because the variable is not used in a side-effecting manner.\n\nParameters:\n\n​type (DType): The dtype of the input and output SIMD vector.\n​simd_width (Int): The width of the input and output SIMD vector.\n\nArgs:\n\n​val (SIMD[type, simd_width]): The value to not optimize away.\n\nkeep[type: DType](val: DTypePointer[type, 0])\n\nProvides a hint to the compiler to not optimize the variable use away.\n\nThis is useful in benchmarking to avoid the compiler not deleting the code to be benchmarked because the variable is not used in a side-effecting manner.\n\nParameters:\n\n​type (DType): The type of the input.\n\nArgs:\n\n​val (DTypePointer[type, 0]): The value to not optimize away.\n\nkeep[type: AnyRegType](val: Pointer[*\"type\", 0])\n\nProvides a hint to the compiler to not optimize the variable use away.\n\nThis is useful in benchmarking to avoid the compiler not deleting the code to be benchmarked because the variable is not used in a side-effecting manner.\n\nParameters:\n\n​type (AnyRegType): The type of the input.\n\nArgs:\n\n​val (Pointer[*\"type\", 0]): The value to not optimize away.\n\nkeep[type: AnyRegType](inout *val: \"type\")\n\nProvides a hint to the compiler to not optimize the variable use away.\n\nThis is useful in benchmarking to avoid the compiler not deleting the code to be benchmarked because the variable is not used in a side-effecting manner.\n\nParameters:\n\n​type (AnyRegType): The type of the input.\n\nArgs:\n\n​val (*\"type\"): The value to not optimize away.\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - base64",
    "url": "https://docs.modular.com/mojo/stdlib/base64/base64.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nb64encode\nbase64\n\nModule\n\nProvides functions for base64 encoding strings.\n\nYou can import these APIs from the base64 package. For example:\n\nfrom base64 import b64encode\nb64encode\n\nb64encode(str: String) -> String\n\nPerforms base64 encoding on the input string.\n\nArgs:\n\n​str (String): The input string.\n\nReturns:\n\nBase64 encoding of the input string.\n\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - autotuning",
    "url": "https://docs.modular.com/mojo/stdlib/autotune/autotuning.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nautotuning\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nautotune\nautotune_fork\nsearch\ncost_of\nautotuning\n\nModule\n\nImplements the autotune functionality.\n\nYou can import these APIs from the autotune package. For example:\n\nfrom autotune import search\nautotune\n\nautotune[T: AnyRegType, *Ts: AnyRegType](value: T, values: !kgen.pack<Ts>) -> T\n\nForks compilation to evaluate each of the provided values.\n\nParameters:\n\n​T (AnyRegType): The first value type.\n​Ts (*AnyRegType): The types of the rest of the parameters.\n\nArgs:\n\n​value (T): The first value in the pack.\n​values (!kgen.pack<Ts>): The tail values.\n\nReturns:\n\nThe value being used in the current compilation fork.\n\nautotune_fork\n\nautotune_fork[type: AnyRegType, *values: *\"type\"]()\n\nForks compilation to evaluate each of the provided values.\n\nReturn parameters: out: The value being used in the current compilation fork.\n\nParameters:\n\n​type (AnyRegType): The type of the parameters to be evaluated.\n​values (**\"type\"): A list of parameters to be evaluated.\nsearch\n\nsearch[fn_type: AnyRegType, candidates: VariadicList[fn_type], evaluator: fn(Pointer[fn_type, 0], Int, /) -> Int]()\n\nFinds the best implementation among all candidates.\n\nThe function runs the search among the list of candidates using the provided evaluator. The evaluator function needs to take two inputs: a pointer to array of all candidates and the size of that array - and return an index of the best candidate.\n\nReturn parameters: The best found candidate.\n\nParameters:\n\n​fn_type (AnyRegType): The signature type of the function.\n​candidates (VariadicList[fn_type]): A list of candidates to search from.\n​evaluator (fn(Pointer[fn_type, 0], Int, /) -> Int): The evaluator function.\ncost_of\n\ncost_of[fn_type: AnyRegType, func: fn_type]() -> Int\n\nCount the number of operations in a function.\n\nThis function takes a function reference and estimates the “cost” of invoking the function by counting the number of MLIR operations in the function after elaboration.\n\nParameters:\n\n​fn_type (AnyRegType): The signature type of the function.\n​func (fn_type): The function to evaluate.\n\nReturns:\n\nThe number of post-elaboration operations in the function.\n\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - sort",
    "url": "https://docs.modular.com/mojo/stdlib/algorithm/sort.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nfunctional\nreduction\nsort\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\npartition\nsort\nsort\n\nModule\n\nImplements sorting functions.\n\nYou can import these APIs from the algorithm package. For example:\n\nfrom algorithm.sort import sort\npartition\n\npartition[type: AnyRegType, cmp_fn: fn[AnyRegType]($0, $0, /) capturing -> Bool](buff: Pointer[*\"type\", 0], k: Int, size: Int)\n\nPartition the input vector inplace such that first k elements are the largest (or smallest if cmp_fn is <= operator) elements. The ordering of the first k elements is undefined.\n\nParameters:\n\n​type (AnyRegType): DType of the underlying data.\n​cmp_fn (fn[AnyRegType]($0, $0, /) capturing -> Bool): Comparison functor of type, type) capturing -> Bool type.\n\nArgs:\n\n​buff (Pointer[*\"type\", 0]): Input buffer.\n​k (Int): Index of the partition element.\n​size (Int): The length of the buffer.\nsort\n\nsort(inout buff: Pointer[Int, 0], len: Int)\n\nSort the vector inplace.\n\nThe function doesn’t return anything, the vector is updated inplace.\n\nArgs:\n\n​buff (Pointer[Int, 0]): Input buffer.\n​len (Int): The length of the buffer.\n\nsort[type: DType](inout buff: Pointer[SIMD[type, 1], 0], len: Int)\n\nSort the vector inplace.\n\nThe function doesn’t return anything, the vector is updated inplace.\n\nParameters:\n\n​type (DType): DType of the underlying data.\n\nArgs:\n\n​buff (Pointer[SIMD[type, 1], 0]): Input buffer.\n​len (Int): The length of the buffer.\n\nsort(inout v: DynamicVector[Int])\n\nSort the vector inplace.\n\nThe function doesn’t return anything, the vector is updated inplace.\n\nArgs:\n\n​v (DynamicVector[Int]): Input integer vector to sort.\n\nsort[type: DType](inout v: DynamicVector[SIMD[type, 1]])\n\nSort the vector inplace.\n\nThe function doesn’t return anything, the vector is updated inplace.\n\nParameters:\n\n​type (DType): DType of the underlying data.\n\nArgs:\n\n​v (DynamicVector[SIMD[type, 1]]): Input vector to sort.\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - reduction",
    "url": "https://docs.modular.com/mojo/stdlib/algorithm/reduction.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nfunctional\nreduction\nsort\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nmap_reduce\nreduce\nreduce_boolean\nmax\nmin\nsum\nproduct\nmean\nvariance\nall_true\nany_true\nnone_true\nargmax\nargmin\nreduce_shape\ncumsum\nreduction\n\nModule\n\nImplements SIMD reductions.\n\nYou can import these APIs from the algorithm package. For example:\n\nfrom algorithm import map_reduce\nmap_reduce\n\nmap_reduce[simd_width: Int, size: Dim, type: DType, acc_type: DType, input_gen_fn: fn[DType, Int](Int, /) capturing -> SIMD[*(0,0), *(0,1)], reduce_vec_to_vec_fn: fn[DType, DType, Int](SIMD[*(0,0), *(0,2)], SIMD[*(0,1), *(0,2)], /) capturing -> SIMD[*(0,0), *(0,2)], reduce_vec_to_scalar_fn: fn[DType, Int](SIMD[*(0,0), *(0,1)], /) -> SIMD[*(0,0), 1]](dst: Buffer[size, type, 0], init: SIMD[acc_type, 1]) -> SIMD[acc_type, 1]\n\nStores the result of calling input_gen_fn in dst and simultaneously reduce the result using a custom reduction function.\n\nParameters:\n\n​simd_width (Int): The vector width for the computation.\n​size (Dim): The buffer size.\n​type (DType): The buffer elements dtype.\n​acc_type (DType): The dtype of the reduction accumulator.\n​input_gen_fn (fn[DType, Int](Int, /) capturing -> SIMD[*(0,0), *(0,1)]): A function that generates inputs to reduce.\n​reduce_vec_to_vec_fn (fn[DType, DType, Int](SIMD[*(0,0), *(0,2)], SIMD[*(0,1), *(0,2)], /) capturing -> SIMD[*(0,0), *(0,2)]): A mapping function. This function is used to combine (accumulate) two chunks of input data: e.g. we load two 8xfloat32 vectors of elements and need to reduce them into a single 8xfloat32 vector.\n​reduce_vec_to_scalar_fn (fn[DType, Int](SIMD[*(0,0), *(0,1)], /) -> SIMD[*(0,0), 1]): A reduction function. This function is used to reduce a vector to a scalar. E.g. when we got 8xfloat32 vector and want to reduce it to an float32 scalar.\n\nArgs:\n\n​dst (Buffer[size, type, 0]): The output buffer.\n​init (SIMD[acc_type, 1]): The initial value to use in accumulator.\n\nReturns:\n\nThe computed reduction value.\n\nreduce\n\nreduce[simd_width: Int, size: Dim, type: DType, acc_type: DType, reduce_fn: fn[DType, DType, Int](SIMD[*(0,0), *(0,2)], SIMD[*(0,1), *(0,2)], /) capturing -> SIMD[*(0,0), *(0,2)]](src: Buffer[size, type, 0], init: SIMD[acc_type, 1]) -> SIMD[acc_type, 1]\n\nComputes a custom reduction of buffer elements.\n\nParameters:\n\n​simd_width (Int): The vector width for the computation.\n​size (Dim): The buffer size.\n​type (DType): The buffer elements dtype.\n​acc_type (DType): The dtype of the reduction accumulator.\n​reduce_fn (fn[DType, DType, Int](SIMD[*(0,0), *(0,2)], SIMD[*(0,1), *(0,2)], /) capturing -> SIMD[*(0,0), *(0,2)]): The lambda implementing the reduction.\n\nArgs:\n\n​src (Buffer[size, type, 0]): The input buffer.\n​init (SIMD[acc_type, 1]): The initial value to use in accumulator.\n\nReturns:\n\nThe computed reduction value.\n\nreduce[simd_width: Int, rank: Int, input_shape: DimList, output_shape: DimList, type: DType, acc_type: DType, map_fn: fn[DType, DType, Int](SIMD[*(0,0), *(0,2)], SIMD[*(0,1), *(0,2)], /) capturing -> SIMD[*(0,0), *(0,2)], reduce_fn: fn[DType, Int](SIMD[*(0,0), *(0,1)], /) -> SIMD[*(0,0), 1], reduce_axis: Int](src: NDBuffer[rank, input_shape, type, 0], dst: NDBuffer[rank, output_shape, acc_type, 0], init: SIMD[acc_type, 1])\n\nPerforms a reduction across reduce_axis of an NDBuffer (src) and stores the result in an NDBuffer (dst).\n\nFirst src is reshaped into a 3D tensor. Without loss of generality, the three axes will be referred to as [H,W,C], where the axis to reduce across is W, the axes before the reduce axis are packed into H, and the axes after the reduce axis are packed into C. i.e. a tensor with dims [D1, D2, …, Di, …, Dn] reducing across axis i gets packed into a 3D tensor with dims [H, W, C], where H=prod(D1,…,Di-1), W = Di, and C = prod(Di+1,…,Dn).\n\nParameters:\n\n​simd_width (Int): The vector width for the computation.\n​rank (Int): The rank of the input/output buffers.\n​input_shape (DimList): The input buffer shape.\n​output_shape (DimList): The output buffer shape.\n​type (DType): The buffer elements dtype.\n​acc_type (DType): The dtype of the reduction accumulator.\n​map_fn (fn[DType, DType, Int](SIMD[*(0,0), *(0,2)], SIMD[*(0,1), *(0,2)], /) capturing -> SIMD[*(0,0), *(0,2)]): A mapping function. This function is used when to combine (accumulate) two chunks of input data: e.g. we load two 8xfloat32 vectors of elements and need to reduce them to a single 8xfloat32 vector.\n​reduce_fn (fn[DType, Int](SIMD[*(0,0), *(0,1)], /) -> SIMD[*(0,0), 1]): A reduction function. This function is used to reduce a vector to a scalar. E.g. when we got 8xfloat32 vector and want to reduce it to 1xfloat32.\n​reduce_axis (Int): The axis to reduce across.\n\nArgs:\n\n​src (NDBuffer[rank, input_shape, type, 0]): The input buffer.\n​dst (NDBuffer[rank, output_shape, acc_type, 0]): The output buffer.\n​init (SIMD[acc_type, 1]): The initial value to use in accumulator.\nreduce_boolean\n\nreduce_boolean[simd_width: Int, size: Dim, type: DType, reduce_fn: fn[DType, Int](SIMD[*(0,0), *(0,1)], /) capturing -> Bool, continue_fn: fn(Bool, /) capturing -> Bool](src: Buffer[size, type, 0], init: Bool) -> Bool\n\nComputes a bool reduction of buffer elements. The reduction will early exit if the continue_fn returns False.\n\nParameters:\n\n​simd_width (Int): The vector width for the computation.\n​size (Dim): The buffer size.\n​type (DType): The buffer elements dtype.\n​reduce_fn (fn[DType, Int](SIMD[*(0,0), *(0,1)], /) capturing -> Bool): A boolean reduction function. This function is used to reduce a vector to a scalar. E.g. when we got 8xfloat32 vector and want to reduce it to a bool.\n​continue_fn (fn(Bool, /) capturing -> Bool): A function to indicate whether we want to continue processing the rest of the iterations. This takes the result of the reduce_fn and returns True to continue processing and False to early exit.\n\nArgs:\n\n​src (Buffer[size, type, 0]): The input buffer.\n​init (Bool): The initial value to use.\n\nReturns:\n\nThe computed reduction value.\n\nmax\n\nmax[size: Dim, type: DType](src: Buffer[size, type, 0]) -> SIMD[type, 1]\n\nComputes the max element in a buffer.\n\nParameters:\n\n​size (Dim): The buffer size.\n​type (DType): The buffer elements dtype.\n\nArgs:\n\n​src (Buffer[size, type, 0]): The buffer.\n\nReturns:\n\nThe maximum of the buffer elements.\n\nmax[rank: Int, input_shape: DimList, output_shape: DimList, type: DType, reduce_axis: Int](src: NDBuffer[rank, input_shape, type, 0], dst: NDBuffer[rank, output_shape, type, 0])\n\nComputes the max across reduce_axis of an NDBuffer.\n\nParameters:\n\n​rank (Int): The rank of the input/output buffers.\n​input_shape (DimList): The input buffer shape.\n​output_shape (DimList): The output buffer shape.\n​type (DType): The buffer elements dtype.\n​reduce_axis (Int): The axis to reduce across.\n\nArgs:\n\n​src (NDBuffer[rank, input_shape, type, 0]): The input buffer.\n​dst (NDBuffer[rank, output_shape, type, 0]): The output buffer.\nmin\n\nmin[size: Dim, type: DType](src: Buffer[size, type, 0]) -> SIMD[type, 1]\n\nComputes the min element in a buffer.\n\nParameters:\n\n​size (Dim): The buffer size.\n​type (DType): The buffer elements dtype.\n\nArgs:\n\n​src (Buffer[size, type, 0]): The buffer.\n\nReturns:\n\nThe minimum of the buffer elements.\n\nmin[rank: Int, input_shape: DimList, output_shape: DimList, type: DType, reduce_axis: Int](src: NDBuffer[rank, input_shape, type, 0], dst: NDBuffer[rank, output_shape, type, 0])\n\nComputes the min across reduce_axis of an NDBuffer.\n\nParameters:\n\n​rank (Int): The rank of the input/output buffers.\n​input_shape (DimList): The input buffer shape.\n​output_shape (DimList): The output buffer shape.\n​type (DType): The buffer elements dtype.\n​reduce_axis (Int): The axis to reduce across.\n\nArgs:\n\n​src (NDBuffer[rank, input_shape, type, 0]): The input buffer.\n​dst (NDBuffer[rank, output_shape, type, 0]): The output buffer.\nsum\n\nsum[size: Dim, type: DType](src: Buffer[size, type, 0]) -> SIMD[type, 1]\n\nComputes the sum of buffer elements.\n\nParameters:\n\n​size (Dim): The buffer size.\n​type (DType): The buffer elements dtype.\n\nArgs:\n\n​src (Buffer[size, type, 0]): The buffer.\n\nReturns:\n\nThe sum of the buffer elements.\n\nsum[rank: Int, input_shape: DimList, output_shape: DimList, type: DType, reduce_axis: Int](src: NDBuffer[rank, input_shape, type, 0], dst: NDBuffer[rank, output_shape, type, 0])\n\nComputes the sum across reduce_axis of an NDBuffer.\n\nParameters:\n\n​rank (Int): The rank of the input/output buffers.\n​input_shape (DimList): The input buffer shape.\n​output_shape (DimList): The output buffer shape.\n​type (DType): The buffer elements dtype.\n​reduce_axis (Int): The axis to reduce across.\n\nArgs:\n\n​src (NDBuffer[rank, input_shape, type, 0]): The input buffer.\n​dst (NDBuffer[rank, output_shape, type, 0]): The output buffer.\nproduct\n\nproduct[size: Dim, type: DType](src: Buffer[size, type, 0]) -> SIMD[type, 1]\n\nComputes the product of the buffer elements.\n\nParameters:\n\n​size (Dim): The buffer size.\n​type (DType): The buffer elements dtype.\n\nArgs:\n\n​src (Buffer[size, type, 0]): The buffer.\n\nReturns:\n\nThe product of the buffer elements.\n\nproduct[rank: Int, input_shape: DimList, output_shape: DimList, type: DType, reduce_axis: Int](src: NDBuffer[rank, input_shape, type, 0], dst: NDBuffer[rank, output_shape, type, 0])\n\nComputes the product across reduce_axis of an NDBuffer.\n\nParameters:\n\n​rank (Int): The rank of the input/output buffers.\n​input_shape (DimList): The input buffer shape.\n​output_shape (DimList): The output buffer shape.\n​type (DType): The buffer elements dtype.\n​reduce_axis (Int): The axis to reduce across.\n\nArgs:\n\n​src (NDBuffer[rank, input_shape, type, 0]): The input buffer.\n​dst (NDBuffer[rank, output_shape, type, 0]): The output buffer.\nmean\n\nmean[size: Dim, type: DType](src: Buffer[size, type, 0]) -> SIMD[type, 1]\n\nComputes the mean value of the elements in a buffer.\n\nParameters:\n\n​size (Dim): The size of the input buffer..\n​type (DType): The type of the elements of the input buffer and output SIMD vector.\n\nArgs:\n\n​src (Buffer[size, type, 0]): The buffer of elements for which the mean is computed.\n\nReturns:\n\nThe mean value of the elements in the given buffer.\n\nmean[rank: Int, input_shape: DimList, output_shape: DimList, type: DType, reduce_axis: Int](src: NDBuffer[rank, input_shape, type, 0], dst: NDBuffer[rank, output_shape, type, 0])\n\nComputes the mean across reduce_axis of an NDBuffer.\n\nParameters:\n\n​rank (Int): The rank of the input/output buffers.\n​input_shape (DimList): The input buffer shape.\n​output_shape (DimList): The output buffer shape.\n​type (DType): The buffer elements dtype.\n​reduce_axis (Int): The axis to reduce across.\n\nArgs:\n\n​src (NDBuffer[rank, input_shape, type, 0]): The input buffer.\n​dst (NDBuffer[rank, output_shape, type, 0]): The output buffer.\n\nmean[type: DType, rank: Int, single_thread_blocking_override: Bool, input_fn: fn[Int, Int](StaticIntTuple[*(0,1)], /) capturing -> SIMD[type, *(0,0)], output_fn: fn[Int, Int](StaticIntTuple[*(0,1)], SIMD[type, *(0,0)], /) capturing -> None, target: StringLiteral](input_shape: StaticIntTuple[rank], reduce_dim: Int, output_shape: StaticIntTuple[rank], out_chain: OutputChainPtr)\n\nComputes the mean across the input and output shape.\n\nThis performs the mean computation on the domain specified by input_shape, storing the results using theinput_0_fn. The results’ domain is output_shape which are stored using the output_0_fn.\n\nParameters:\n\n​type (DType): The type of the input and output.\n​rank (Int): The rank of the domain.\n​single_thread_blocking_override (Bool): Whether the operation is performed async.\n​input_fn (fn[Int, Int](StaticIntTuple[*(0,1)], /) capturing -> SIMD[type, *(0,0)]): The function to load the input.\n​output_fn (fn[Int, Int](StaticIntTuple[*(0,1)], SIMD[type, *(0,0)], /) capturing -> None): The function to store the output.\n​target (StringLiteral): The target architecture.\n\nArgs:\n\n​input_shape (StaticIntTuple[rank]): The input shape.\n​reduce_dim (Int): The axis to perform the mean on.\n​output_shape (StaticIntTuple[rank]): The output shape.\n​out_chain (OutputChainPtr): The output chain to use.\nvariance\n\nvariance[size: Dim, type: DType](src: Buffer[size, type, 0], mean_value: SIMD[type, 1], correction: Int) -> SIMD[type, 1]\n\nGiven a mean, computes the variance of elements in a buffer.\n\nThe mean value is used to avoid a second pass over the data:\n\nvariance = sum((x - E(x))^2) / (size - correction)\n\nParameters:\n\n​size (Dim): The buffer size.\n​type (DType): The buffer elements dtype.\n\nArgs:\n\n​src (Buffer[size, type, 0]): The buffer.\n​mean_value (SIMD[type, 1]): The mean value of the buffer.\n​correction (Int): Normalize variance by size - correction.\n\nReturns:\n\nThe variance value of the elements in a buffer.\n\nvariance[size: Dim, type: DType](src: Buffer[size, type, 0], correction: Int) -> SIMD[type, 1]\n\nComputes the variance value of the elements in a buffer.\n\nvariance(src) = sum((x - E(x))^2) / (size - correction)\n\nParameters:\n\n​size (Dim): The buffer size.\n​type (DType): The buffer elements dtype.\n\nArgs:\n\n​src (Buffer[size, type, 0]): The buffer.\n​correction (Int): Normalize variance by size - correction (Default=1).\n\nReturns:\n\nThe variance value of the elements in a buffer.\n\nall_true\n\nall_true[size: Dim, type: DType](src: Buffer[size, type, 0]) -> Bool\n\nReturns True if all the elements in a buffer are True and False otherwise.\n\nParameters:\n\n​size (Dim): The buffer size.\n​type (DType): The buffer elements dtype.\n\nArgs:\n\n​src (Buffer[size, type, 0]): The buffer.\n\nReturns:\n\nTrue if all of the elements of the buffer are True and False otherwise.\n\nany_true\n\nany_true[size: Dim, type: DType](src: Buffer[size, type, 0]) -> Bool\n\nReturns True if any the elements in a buffer are True and False otherwise.\n\nParameters:\n\n​size (Dim): The buffer size.\n​type (DType): The buffer elements dtype.\n\nArgs:\n\n​src (Buffer[size, type, 0]): The buffer.\n\nReturns:\n\nTrue if any of the elements of the buffer are True and False otherwise.\n\nnone_true\n\nnone_true[size: Dim, type: DType](src: Buffer[size, type, 0]) -> Bool\n\nReturns True if none of the elements in a buffer are True and False otherwise.\n\nParameters:\n\n​size (Dim): The buffer size.\n​type (DType): The buffer elements dtype.\n\nArgs:\n\n​src (Buffer[size, type, 0]): The buffer.\n\nReturns:\n\nTrue if none of the elements of the buffer are True and False otherwise.\n\nargmax\n\nargmax[type: DType, out_type: DType, rank: Int](input: NDBuffer[rank, create_unknown[$builtin::$int::Int][rank](), type, 0], axis: Int, output: NDBuffer[rank, create_unknown[$builtin::$int::Int][rank](), out_type, 0], out_chain: OutputChainPtr)\n\nFinds the indices of the maximum element along the specified axis.\n\nParameters:\n\n​type (DType): Type of the input tensor.\n​out_type (DType): Type of the output tensor.\n​rank (Int): The rank of the input / output.\n\nArgs:\n\n​input (NDBuffer[rank, create_unknown[$builtin::$int::Int][rank](), type, 0]): The input tensor.\n​axis (Int): The axis.\n​output (NDBuffer[rank, create_unknown[$builtin::$int::Int][rank](), out_type, 0]): The output tensor.\n​out_chain (OutputChainPtr): The chain to attach results to.\n\nargmax[type: DType, out_type: DType, axis_type: DType, rank: Int](input: NDBuffer[rank, create_unknown[$builtin::$int::Int][rank](), type, 0], axis_buf: NDBuffer[1, create_unknown[$builtin::$int::Int][1](), axis_type, 0], output: NDBuffer[rank, create_unknown[$builtin::$int::Int][rank](), out_type, 0], out_chain: OutputChainPtr)\n\nFinds the indices of the maximum element along the specified axis.\n\nParameters:\n\n​type (DType): Type of the input tensor.\n​out_type (DType): Type of the output tensor.\n​axis_type (DType): Type of the axis tensor.\n​rank (Int): The rank of the input / output.\n\nArgs:\n\n​input (NDBuffer[rank, create_unknown[$builtin::$int::Int][rank](), type, 0]): The input tensor.\n​axis_buf (NDBuffer[1, create_unknown[$builtin::$int::Int][1](), axis_type, 0]): The axis tensor.\n​output (NDBuffer[rank, create_unknown[$builtin::$int::Int][rank](), out_type, 0]): The axis tensor.\n​out_chain (OutputChainPtr): The chain to attach results to.\nargmin\n\nargmin[type: DType, out_type: DType, rank: Int](input: NDBuffer[rank, create_unknown[$builtin::$int::Int][rank](), type, 0], axis: Int, output: NDBuffer[rank, create_unknown[$builtin::$int::Int][rank](), out_type, 0], out_chain: OutputChainPtr)\n\nFinds the indices of the maximum element along the specified axis.\n\nParameters:\n\n​type (DType): Type of the input tensor.\n​out_type (DType): Type of the output tensor.\n​rank (Int): The rank of the input / output.\n\nArgs:\n\n​input (NDBuffer[rank, create_unknown[$builtin::$int::Int][rank](), type, 0]): The input tensor.\n​axis (Int): The axis.\n​output (NDBuffer[rank, create_unknown[$builtin::$int::Int][rank](), out_type, 0]): The output tensor.\n​out_chain (OutputChainPtr): The chain to attach results to.\n\nargmin[type: DType, out_type: DType, axis_type: DType, rank: Int](input: NDBuffer[rank, create_unknown[$builtin::$int::Int][rank](), type, 0], axis_buf: NDBuffer[1, create_unknown[$builtin::$int::Int][1](), axis_type, 0], output: NDBuffer[rank, create_unknown[$builtin::$int::Int][rank](), out_type, 0], out_chain: OutputChainPtr)\n\nFinds the indices of the minimum element along the specified axis.\n\nParameters:\n\n​type (DType): Type of the input tensor.\n​out_type (DType): Type of the output tensor.\n​axis_type (DType): Type of the axis tensor.\n​rank (Int): The rank of the input / output.\n\nArgs:\n\n​input (NDBuffer[rank, create_unknown[$builtin::$int::Int][rank](), type, 0]): The input tensor.\n​axis_buf (NDBuffer[1, create_unknown[$builtin::$int::Int][1](), axis_type, 0]): The axis tensor.\n​output (NDBuffer[rank, create_unknown[$builtin::$int::Int][rank](), out_type, 0]): The axis tensor.\n​out_chain (OutputChainPtr): The chain to attach results to.\nreduce_shape\n\nreduce_shape[input_rank: Int, input_type: DType, axis_type: DType, single_thread_blocking_override: Bool](input_buf: NDBuffer[input_rank, create_unknown[$builtin::$int::Int][input_rank](), input_type, 0], axis_buf: NDBuffer[1, create_unknown[$builtin::$int::Int][1](), axis_type, 0]) -> StaticIntTuple[input_rank]\n\nCompute the output shape of a pad operation, and assert the inputs are compatible.\n\nParameters:\n\n​input_rank (Int): Input_rank of the input tensor.\n​input_type (DType): Type of the input tensor.\n​axis_type (DType): Type of the axis tensor.\n​single_thread_blocking_override (Bool): Whether this function can block.\n\nArgs:\n\n​input_buf (NDBuffer[input_rank, create_unknown[$builtin::$int::Int][input_rank](), input_type, 0]): The input tensor.\n​axis_buf (NDBuffer[1, create_unknown[$builtin::$int::Int][1](), axis_type, 0]): The axis tensor.\n\nReturns:\n\nThe output shape.\n\ncumsum\n\ncumsum[size: Int, type: DType](dst: Buffer[Dim(size), type, 0], src: Buffer[Dim(size), type, 0])\n\nComputes the cumulative sum of all elements in a buffer. dst[i] = src[i] + src[i-1] + … + src[0].\n\nParameters:\n\n​size (Int): The size of the input and output buffers.\n​type (DType): The type of the elements of the input and output buffers.\n\nArgs:\n\n​dst (Buffer[Dim(size), type, 0]): The buffer that stores the result of cumulative sum operation.\n​src (Buffer[Dim(size), type, 0]): The buffer of elements for which the cumulative sum is computed.\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - functional",
    "url": "https://docs.modular.com/mojo/stdlib/algorithm/functional.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nfunctional\nreduction\nsort\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nOn this page\nmap\nunroll\nvectorize\nvectorize_unroll\nasync_parallelize\nsync_parallelize\nparallelize\ntile\nunswitch\ntile_and_unswitch\nelementwise\nparallelize_over_rows\nstencil\nfunctional\n\nModule\n\nImplements higher-order functions.\n\nYou can import these APIs from the algorithm package. For example:\n\nfrom algorithm import map\n\nAliases:\n\n​Static1DTileUnitFunc = fn[Int](Int, /) capturing -> None: Signature of a 1d tiled function that performs some work with a static tile size and an offset. i.e. func<tile_size: Int> (offset: Int)\n​Dynamic1DTileUnitFunc = fn(Int, Int, /) capturing -> None: Signature of a 1d tiled function that performs some work with a dynamic tile size and an offset. i.e. func(offset: Int, tile_size: Int)\n​BinaryTile1DTileUnitFunc = fn[Int](Int, Int, /) capturing -> None: Signature of a tiled function that performs some work with a dynamic tile size and a secondary static tile size.\n​Static2DTileUnitFunc = fn[Int, Int](Int, Int, /) capturing -> None: Signature of a 2d tiled function that performs some work with a static tile size and an offset. i.e. func<tile_size_x: Int, tile_size_y: Int> (offset_x: Int, offset_y: Int)\n​SwitchedFunction = fn[Bool]() capturing -> None\n​SwitchedFunction2 = fn[Bool, Bool]() capturing -> None\n​Static1DTileUnswitchUnitFunc = fn[Int, Bool](Int, Int, /) capturing -> None: Signature of a tiled function that performs some work with a static tile size and an offset. i.e. func<tile_size: Int> (offset: Int)\n​Dynamic1DTileUnswitchUnitFunc = fn[Bool](Int, Int, Int, /) capturing -> None\nmap\n\nmap[func: fn(Int, /) capturing -> None](size: Int)\n\nMaps a function over a range from 0 to size.\n\nParameters:\n\n​func (fn(Int, /) capturing -> None): Function to map.\n\nArgs:\n\n​size (Int): The number of elements.\nunroll\n\nunroll[count: Int, func: fn[Int]() capturing -> None]()\n\nRepeatedly evaluates a function count times.\n\nParameters:\n\n​count (Int): A number of repetitions.\n​func (fn[Int]() capturing -> None): The function to evaluate. The function should take a single Int argument, which is the loop index value.\n\nunroll[dim0: Int, dim1: Int, func: fn[Int, Int]() capturing -> None]()\n\nRepeatedly evaluates a 2D nested loop.\n\nParameters:\n\n​dim0 (Int): The first dimension size.\n​dim1 (Int): The second dimension size.\n​func (fn[Int, Int]() capturing -> None): The function to evaluate. The function should take two Int arguments: the outer and inner loop index values.\n\nunroll[dim0: Int, dim1: Int, dim2: Int, func: fn[Int, Int, Int]() capturing -> None]()\n\nRepeatedly evaluates a 3D nested loop.\n\nParameters:\n\n​dim0 (Int): The first dimension size.\n​dim1 (Int): The second dimension size.\n​dim2 (Int): The second dimension size.\n​func (fn[Int, Int, Int]() capturing -> None): The function to evaluate. The function should take three Int arguments: one for each nested loop index value.\nvectorize\n\nvectorize[simd_width: Int, func: fn[Int](Int, /) capturing -> None](size: Int)\n\nMaps a function which is parametrized over a simd_width over a range from 0 to size in simd fashion.\n\nParameters:\n\n​simd_width (Int): The SIMD vector width.\n​func (fn[Int](Int, /) capturing -> None): The function for the loop body.\n\nArgs:\n\n​size (Int): The total loop count.\nvectorize_unroll\n\nvectorize_unroll[simd_width: Int, unroll_factor: Int, func: fn[Int](Int, /) capturing -> None](size: Int)\n\nMaps a function which is parametrized over a simd_width over a range from 0 to size in simd fashion and unroll the loop by unroll_factor.\n\nParameters:\n\n​simd_width (Int): The SIMD vector width.\n​unroll_factor (Int): The unroll factor for the main loop.\n​func (fn[Int](Int, /) capturing -> None): The function for the loop body.\n\nArgs:\n\n​size (Int): The total loop count.\nasync_parallelize\n\nasync_parallelize[func: fn(Int, /) capturing -> None](out_chain: OutputChainPtr, num_work_items: Int)\n\nExecutes func(0) … func(num_work_items-1) as sub-tasks in parallel and returns immediately. The out_chain will be marked as ready only when all sub-tasks have completed.\n\nExecute func(0) … func(num_work_items-1) as sub-tasks in parallel and mark out_chain as ready when all functions have returned. This function will return when the sub-tasks have been scheduled but not necessarily completed. The runtime may execute the sub-tasks in any order and with any degree of concurrency.\n\nAll free variables in func must be “async safe”. Currently this means: - The variable must be bound by a by-val function argument (ie no &), or let binding. - The variable’s type must be “async safe”, ie is marked as @register_passable and any internal pointers are to memory with lifetime at least until out_chain is ready. In practice, this means only pointers to buffers held alive by the runtime. Consider using sync_parallelize if this requirement is too onerous.\n\nIf num_work_items is 0 then the out_chain is marked as ready before async_parallelize returns. If num_work_items is 1 then func(0) may still be executed as a sub-task.\n\nParameters:\n\n​func (fn(Int, /) capturing -> None): The function to invoke.\n\nArgs:\n\n​out_chain (OutputChainPtr): Out chain onto which to signal completion.\n​num_work_items (Int): Number of parallel tasks.\nsync_parallelize\n\nsync_parallelize[func: fn(Int, /) capturing -> None](out_chain: OutputChainPtr, num_work_items: Int)\n\nExecutes func(0) … func(num_work_items-1) as sub-tasks in parallel. Marks out_chain as ready and returns only when all sub-tasks have completed.\n\nExecute func(0) … func(num_work_items-1) as sub-tasks in parallel, and return only when they have all functions have returned. The runtime may execute the sub-tasks in any order and with any degree of concurrency. The out_chain will be marked as ready before returning.\n\nParameters:\n\n​func (fn(Int, /) capturing -> None): The function to invoke.\n\nArgs:\n\n​out_chain (OutputChainPtr): Out chain onto which to signal completion.\n​num_work_items (Int): Number of parallel tasks.\nparallelize\n\nparallelize[func: fn(Int, /) capturing -> None]()\n\nExecutes func(0) … func(N-1) as sub-tasks in parallel and returns when all are complete. N is chosen to be the number of processors on the system.\n\nExecute func(0) … func(N-1) as sub-tasks in parallel. This function will return only after all the sub-tasks have completed.\n\nCAUTION: Creates and destroys a local runtime! Do not use from kernels!\n\nParameters:\n\n​func (fn(Int, /) capturing -> None): The function to invoke.\n\nparallelize[func: fn(Int, /) capturing -> None](num_work_items: Int)\n\nExecutes func(0) … func(num_work_items-1) as sub-tasks in parallel and returns when all are complete.\n\nExecute func(0) … func(num_work_items-1) as sub-tasks in parallel. This function will return only after all the sub-tasks have completed.\n\nCAUTION: Creates and destroys a local runtime! Do not use from kernels!\n\nParameters:\n\n​func (fn(Int, /) capturing -> None): The function to invoke.\n\nArgs:\n\n​num_work_items (Int): Number of parallel tasks.\n\nparallelize[func: fn(Int, /) capturing -> None](num_work_items: Int, num_workers: Int)\n\nExecutes func(0) … func(num_work_items-1) as sub-tasks in parallel and returns when all are complete.\n\nExecute func(0) … func(num_work_items-1) as sub-tasks in parallel. This function will return only after all the sub-tasks have completed.\n\nParameters:\n\n​func (fn(Int, /) capturing -> None): The function to invoke.\n\nArgs:\n\n​num_work_items (Int): Number of parallel tasks.\n​num_workers (Int): The number of works to use for execution.\ntile\n\ntile[workgroup_function: fn[Int](Int, /) capturing -> None, tile_size_list: VariadicList[Int]](offset: Int, upperbound: Int)\n\nA generator that launches work groups in specified list of tile sizes.\n\nA workgroup function is a function that can process a configurable consecutive “tile” of workload. E.g. work_on[3](5) should launch computation on item 5,6,7, and should be semantically equivalent to work_on[1](5), work_on[1](6), work_on[1](7).\n\nThis generator will try to proceed with the given list of tile sizes on the listed order. E.g. tile[func, (3,2,1)](offset, upperbound) will try to call func[3] starting from offset until remaining work is less than 3 from upperbound and then try func[2], and then func[1], etc.\n\nParameters:\n\n​workgroup_function (fn[Int](Int, /) capturing -> None): Workgroup function that processes one tile of workload.\n​tile_size_list (VariadicList[Int]): List of tile sizes to launch work.\n\nArgs:\n\n​offset (Int): The initial index to start the work from.\n​upperbound (Int): The runtime upperbound that the work function should not exceed.\n\ntile[workgroup_function: fn(Int, Int, /) capturing -> None](offset: Int, upperbound: Int, tile_size_list: VariadicList[Int])\n\nA generator that launches work groups in specified list of tile sizes.\n\nThis is the version of tile generator for the case where work_group function can take the tile size as a runtime value.\n\nParameters:\n\n​workgroup_function (fn(Int, Int, /) capturing -> None): Workgroup function that processes one tile of workload.\n\nArgs:\n\n​offset (Int): The initial index to start the work from.\n​upperbound (Int): The runtime upperbound that the work function should not exceed.\n​tile_size_list (VariadicList[Int]): List of tile sizes to launch work.\n\ntile[secondary_tile_size_list: VariadicList[Int], secondary_cleanup_tile: Int, workgroup_function: fn[Int](Int, Int, /) capturing -> None](offset: Int, upperbound: Int, primary_tile_size_list: VariadicList[Int], primary_cleanup_tile: Int)\n\nA generator that launches work groups in specified list of tile sizes until the sum of primary_tile_sizes has exceeded the upperbound.\n\nParameters:\n\n​secondary_tile_size_list (VariadicList[Int]): List of static tile sizes to launch work.\n​secondary_cleanup_tile (Int): Last static tile to use when primary tile sizes don’t fit exactly within the upperbound.\n​workgroup_function (fn[Int](Int, Int, /) capturing -> None): Workgroup function that processes one tile of workload.\n\nArgs:\n\n​offset (Int): The initial index to start the work from.\n​upperbound (Int): The runtime upperbound that the work function should not exceed.\n​primary_tile_size_list (VariadicList[Int]): List of dynamic tile sizes to launch work.\n​primary_cleanup_tile (Int): Last dynamic tile to use when primary tile sizes don’t fit exactly within the upperbound.\n\ntile[workgroup_function: fn[Int, Int](Int, Int, /) capturing -> None, tile_sizes_x: VariadicList[Int], tile_sizes_y: VariadicList[Int]](offset_x: Int, offset_y: Int, upperbound_x: Int, upperbound_y: Int)\n\nLaunches workgroup_function using the largest tile sizes possible in each dimension, starting from the x and y offset, until the x and y upperbounds are reached.\n\nParameters:\n\n​workgroup_function (fn[Int, Int](Int, Int, /) capturing -> None): Function that is invoked for each tile and offset.\n​tile_sizes_x (VariadicList[Int]): List of tile sizes to use for the first parameter of workgroup_function.\n​tile_sizes_y (VariadicList[Int]): List of tile sizes to use for the second parameter of workgroup_function.\n\nArgs:\n\n​offset_x (Int): Initial x offset passed to workgroup_function.\n​offset_y (Int): Initial y offset passed to workgroup_function.\n​upperbound_x (Int): Max offset in x dimension passed to workgroup function.\n​upperbound_y (Int): Max offset in y dimension passed to workgroup function.\nunswitch\n\nunswitch[switched_func: fn[Bool]() capturing -> None](dynamic_switch: Bool)\n\nPerforms a functional unswitch transformation.\n\nUnswitch is a simple pattern that is similar idea to loop unswitching pass but extended to functional patterns. The pattern facilitates the following code transformation that reduces the number of branches in the generated code\n\nBefore:\n\nfor i in range(...)\n    if i < xxx:\n        ...\n\nAfter:\n\nif i < ...\n    for i in range(...)\n        ...\nelse\n    for i in range(...)\n        if i < xxx:\n            ...\n\nThis unswitch function generalizes that pattern with the help of meta parameters and can be used to perform both loop unswitching and other tile predicate lifting like in simd and amx.\n\nTODO: Generalize to support multiple predicates. TODO: Once nested lambdas compose well should make unswitch compose with tile in an easy way.\n\nParameters:\n\n​switched_func (fn[Bool]() capturing -> None): The function containing the inner loop logic that can be unswitched.\n\nArgs:\n\n​dynamic_switch (Bool): The dynamic condition that enables the unswitched code path.\n\nunswitch[switched_func: fn[Bool, Bool]() capturing -> None](dynamic_switch_a: Bool, dynamic_switch_b: Bool)\n\nPerforms a functional 2-predicates unswitch transformation.\n\nParameters:\n\n​switched_func (fn[Bool, Bool]() capturing -> None): The function containing the inner loop logic that has 2 predicates which can be unswitched.\n\nArgs:\n\n​dynamic_switch_a (Bool): The first dynamic condition that enables the outer unswitched code path.\n​dynamic_switch_b (Bool): The second dynamic condition that enables the inner unswitched code path.\ntile_and_unswitch\n\ntile_and_unswitch[workgroup_function: fn[Int, Bool](Int, Int, /) capturing -> None, tile_size_list: VariadicList[Int]](offset: Int, upperbound: Int)\n\nPerforms time and unswitch functional transformation.\n\nA variant of static tile given a workgroup function that can be unswitched. This generator is a fused version of tile and unswitch, where the static unswitch is true throughout the “inner” portion of the workload and is false only on the residue tile.\n\nParameters:\n\n​workgroup_function (fn[Int, Bool](Int, Int, /) capturing -> None): Workgroup function that processes one tile of workload.\n​tile_size_list (VariadicList[Int]): List of tile sizes to launch work.\n\nArgs:\n\n​offset (Int): The initial index to start the work from.\n​upperbound (Int): The runtime upperbound that the work function should not exceed.\n\ntile_and_unswitch[workgroup_function: fn[Bool](Int, Int, Int, /) capturing -> None](offset: Int, upperbound: Int, tile_size_list: VariadicList[Int])\n\nPerforms time and unswitch functional transformation.\n\nA variant of dynamic tile given a workgroup function that can be unswitched. This generator is a fused version of tile and unswitch, where the static unswitch is true throughout the “inner” portion of the workload and is false only on the residue tile.\n\nParameters:\n\n​workgroup_function (fn[Bool](Int, Int, Int, /) capturing -> None): Workgroup function that processes one tile of workload.\n\nArgs:\n\n​offset (Int): The initial index to start the work from.\n​upperbound (Int): The runtime upperbound that the work function should not exceed.\n​tile_size_list (VariadicList[Int]): List of tile sizes to launch work.\nelementwise\n\nelementwise[rank: Int, simd_width: Int, func: fn[Int, Int](StaticIntTuple[*(0,1)], /) capturing -> None](shape: StaticIntTuple[rank])\n\nExecutes func[width, rank](indices) as sub-tasks for a suitable combination of width and indices so as to cover shape.\n\nParameters:\n\n​rank (Int): The rank of the buffer.\n​simd_width (Int): The SIMD vector width to use.\n​func (fn[Int, Int](StaticIntTuple[*(0,1)], /) capturing -> None): The body function.\n\nArgs:\n\n​shape (StaticIntTuple[rank]): The shape of the buffer.\n\nelementwise[rank: Int, simd_width: Int, func: fn[Int, Int](StaticIntTuple[*(0,1)], /) capturing -> None](shape: StaticIntTuple[rank], out_chain: OutputChainPtr)\n\nExecutes func[width, rank](indices) as sub-tasks for a suitable combination of width and indices so as to cover shape.\n\nParameters:\n\n​rank (Int): The rank of the buffer.\n​simd_width (Int): The SIMD vector width to use.\n​func (fn[Int, Int](StaticIntTuple[*(0,1)], /) capturing -> None): The body function.\n\nArgs:\n\n​shape (StaticIntTuple[rank]): The shape of the buffer.\n​out_chain (OutputChainPtr): The output chain to attach results to.\nparallelize_over_rows\n\nparallelize_over_rows[rank: Int, func: fn(Int, Int, /) capturing -> None](shape: StaticIntTuple[rank], axis: Int, out_chain: OutputChainPtr, grain_size: Int)\n\nParallelize func over non-axis dims of shape.\n\nParameters:\n\n​rank (Int): Rank of shape.\n​func (fn(Int, Int, /) capturing -> None): Function to call on range of rows.\n\nArgs:\n\n​shape (StaticIntTuple[rank]): Shape to parallelize over.\n​axis (Int): Rows are slices along the axis dimension of shape.\n​out_chain (OutputChainPtr): The out chain to attach results to.\n​grain_size (Int): The minimum number of elements to warrant using an additional thread.\nstencil\n\nstencil[rank: Int, stencil_rank: Int, stencil_axis: StaticIntTuple[stencil_rank], simd_width: Int, type: DType, map_fn: fn(StaticIntTuple[stencil_rank], /) capturing -> Tuple[StaticIntTuple[stencil_rank], StaticIntTuple[stencil_rank]], map_strides: fn(dim = Int) capturing -> Int, load_fn: fn[Int, DType](StaticIntTuple[rank], /) capturing -> SIMD[*(0,1), *(0,0)], compute_init_fn: fn[Int]() capturing -> SIMD[type, *(0,0)], compute_fn: fn[Int](StaticIntTuple[rank], SIMD[type, *(0,0)], SIMD[type, *(0,0)], /) capturing -> SIMD[type, *(0,0)], compute_finalize_fn: fn[Int](StaticIntTuple[rank], SIMD[type, *(0,0)], /) capturing -> None](shape: StaticIntTuple[rank], out_chain: OutputChainPtr)\n\nComputes stencil operation in parallel.\n\nComputes output as a function that processes input stencils, stencils are computed as a continuous region for each output point that is determined by map_fn : map_fn(y) -> lower_bound, upper_bound. The boundary conditions for regions that fail out of the input domain are handled by load_fn.\n\nParameters:\n\n​rank (Int): Input and output domain rank.\n​stencil_rank (Int): Rank of stencil subdomain slice.\n​stencil_axis (StaticIntTuple[stencil_rank]): Stencil subdomain axes.\n​simd_width (Int): The SIMD vector width to use.\n​type (DType): The input and output data type.\n​map_fn (fn(StaticIntTuple[stencil_rank], /) capturing -> Tuple[StaticIntTuple[stencil_rank], StaticIntTuple[stencil_rank]]): A function that a point in the output domain to the input co-domain.\n​map_strides (fn(dim = Int) capturing -> Int): A function that returns the stride for the dim.\n​load_fn (fn[Int, DType](StaticIntTuple[rank], /) capturing -> SIMD[*(0,1), *(0,0)]): A function that loads a vector of simd_width from input.\n​compute_init_fn (fn[Int]() capturing -> SIMD[type, *(0,0)]): A function that initialzies vector compute over the stencil.\n​compute_fn (fn[Int](StaticIntTuple[rank], SIMD[type, *(0,0)], SIMD[type, *(0,0)], /) capturing -> SIMD[type, *(0,0)]): A function the process the value computed for each point in the stencil.\n​compute_finalize_fn (fn[Int](StaticIntTuple[rank], SIMD[type, *(0,0)], /) capturing -> None): A function that finalizes the computation of a point in the output domain given a stencil.\n\nArgs:\n\n​shape (StaticIntTuple[rank]): The shape of the buffer.\n​out_chain (OutputChainPtr): The our chain to attach results to.\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  },
  {
    "title": "Modular Docs - Mojo🔥 modules",
    "url": "https://docs.modular.com/mojo/lib.html",
    "html": "MAX Engine\nMAX Serving\nMojo🔥\nGet Started\nOverview\nWhy Mojo\nMojo Manual\nIntro\nGet started\nLanguage basics\nFunctions\nVariables\nStructs\nTraits\nValue ownership\nValue lifecycle\nMetaprogramming\nPython\nDecorators\nModules and packages\nMojo notebooks\nOverview\nLow-level IR in Mojo\nMandelbrot in Mojo with Python plots\nMatrix multiplication in Mojo\nFast memset in Mojo\nRay tracing in Mojo\nMojo library\nModule index\nalgorithm\nautotune\nbase64\nbenchmark\nbuiltin\ncomplex\nmath\nmemory\nos\npathlib\npython\nrandom\nsys\ntensor\ntesting\ntime\nutils\nMojo CLI\nmojo\nmojo build\nmojo debug\nmojo demangle\nmojo doc\nmojo format\nmojo package\nmojo repl\nmojo run\nRoadmap & sharp edges\nChangelog\nFAQ\nCommunity\nMojo🔥 modules\n\nThese are all the modules in the Mojo standard library.\n\narg\nImplements functions and variables for interacting with execution and system environment.\natomic\nImplements the Atomic class.\nautotuning\nImplements the autotune functionality.\nbase64\nProvides functions for base64 encoding strings.\nbenchmark\nImplements the benchmark module for runtime benchmarking.\nbit\nProvides functions for bit manipulation.\nbool\nImplements the Bool class.\nbuffer\nImplements the Buffer class.\nbuiltin_list\nImplements the ListLiteral class.\nbuiltin_slice\nImplements slice.\ncomplex\nImplements the Complex type.\nconstrained\nImplements compile time contraints.\ncoroutine\nImplements classes and methods for coroutines.\ndebug_assert\nImplements a debug assert.\ndestructable\nDefines the Destructable trait.\ndtype\nImplements the DType class.\nenv\nImplements basic routines for working with the OS.\nerror\nImplements the Error class.\nfile\nImplements the file based methods.\nfloat_literal\nImplements the FloatLiteral class.\nfunctional\nImplements higher-order functions.\nindex\nImplements StaticIntTuple which is commonly used to represent N-D indices.\ninfo\nImplements methods for querying the host target info.\nint\nImplements the Int class.\nint_literal\nImplements the IntLiteral class.\nintrinsics\nDefines intrinsics.\nio\nProvides utilities for working with input/output.\nlen\nProvides the len() function and its associated traits.\nlimit\nProvides interfaces to query numeric various numeric properties of types.\nlist\nProvides utilities for working with static and variadic lists.\nmath\nDefines math utilities.\nmemory\nDefines functions for memory manipulations.\nobject\nDefines the object type, which is used to represent untyped values.\nobject\nImplements PythonObject.\nparam_env\nImplements functions for retrieving compile-time defines.\npath\nImplements Path and related functions.\npolynomial\nProvides two implementations for evaluating polynomials.\npython\nImplements Python interoperability.\nrandom\nProvides functions for random numbers.\nrange\nImplements a ‘range’ call.\nrebind\nImplements type rebind.\nreduction\nImplements SIMD reductions.\nsimd\nImplements SIMD struct.\nsort\nImplements sorting functions.\nstatic_tuple\nImplements StaticTuple, a statically-sized uniform container.\nstr\nProvides the str function.\nstring\nImplements basic object methods for working with strings.\nstring_literal\nImplements the StringLiteral class.\nstringref\nImplements the StringRef class.\ntensor\nImplements the Tensor type.\ntensor_shape\nImplements the TensorShape type.\ntensor_spec\nImplements the TensorSpec type.\ntesting\nImplements various testing utils.\ntime\nImplements basic utils for working with time.\ntuple\nImplements the Tuple type.\ntype_aliases\nDefines some type aliases.\nunsafe\nImplements classes for working with unsafe pointers.\nvalue\nDefines core value traits.\nvector\nDefines several vector-like classes.\n© 2023 Modular Inc\ncookie\nModular.com\nTerms\nPrivacy\nGet started\nPlease accept our cookies\nWe use cookies to monitor visitor traffic and gain valuable insights that help us improve the website and documentation. Read more\nAccept\nReject"
  }
]