[
    {
        "url": "https://github.com/modularml/mojo/blob/main/LICENSE",
        "content": "==============================================================================================\nThe Mojo repository is licensed under the Apache License v2.0 with LLVM Exceptions:\n==============================================================================================\n\n                                 Apache License\n                           Version 2.0, January 2004\n                        http://www.apache.org/licenses/\n\n    TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n    1. Definitions.\n\n      \"License\" shall mean the terms and conditions for use, reproduction,\n      and distribution as defined by Sections 1 through 9 of this document.\n\n      \"Licensor\" shall mean the copyright owner or entity authorized by\n      the copyright owner that is granting the License.\n\n      \"Legal Entity\" shall mean the union of the acting entity and all\n      other entities that control, are controlled by, or are under common\n      control with that entity. For the purposes of this definition,\n      \"control\" means (i) the power, direct or indirect, to cause the\n      direction or management of such entity, whether by contract or\n      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n      outstanding shares, or (iii) beneficial ownership of such entity.\n\n      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n      exercising permissions granted by this License.\n\n      \"Source\" form shall mean the preferred form for making modifications,\n      including but not limited to software source code, documentation\n      source, and configuration files.\n\n      \"Object\" form shall mean any form resulting from mechanical\n      transformation or translation of a Source form, including but\n      not limited to compiled object code, generated documentation,\n      and conversions to other media types.\n\n      \"Work\" shall mean the work of authorship, whether in Source or\n      Object form, made available under the License, as indicated by a\n      copyright notice that is included in or attached to the work\n      (an example is provided in the Appendix below).\n\n      \"Derivative Works\" shall mean any work, whether in Source or Object\n      form, that is based on (or derived from) the Work and for which the\n      editorial revisions, annotations, elaborations, or other modifications\n      represent, as a whole, an original work of authorship. For the purposes\n      of this License, Derivative Works shall not include works that remain\n      separable from, or merely link (or bind by name) to the interfaces of,\n      the Work and Derivative Works thereof.\n\n      \"Contribution\" shall mean any work of authorship, including\n      the original version of the Work and any modifications or additions\n      to that Work or Derivative Works thereof, that is intentionally\n      submitted to Licensor for inclusion in the Work by the copyright owner\n      or by an individual or Legal Entity authorized to submit on behalf of\n      the copyright owner. For the purposes of this definition, \"submitted\"\n      means any form of electronic, verbal, or written communication sent\n      to the Licensor or its representatives, including but not limited to\n      communication on electronic mailing lists, source code control systems,\n      and issue tracking systems that are managed by, or on behalf of, the\n      Licensor for the purpose of discussing and improving the Work, but\n      excluding communication that is conspicuously marked or otherwise\n      designated in writing by the copyright owner as \"Not a Contribution.\"\n\n      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n      on behalf of whom a Contribution has been received by Licensor and\n      subsequently incorporated within the Work.\n\n    2. Grant of Copyright License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      copyright license to reproduce, prepare Derivative Works of,\n      publicly display, publicly perform, sublicense, and distribute the\n      Work and such Derivative Works in Source or Object form.\n\n    3. Grant of Patent License. Subject to the terms and conditions of\n      this License, each Contributor hereby grants to You a perpetual,\n      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n      (except as stated in this section) patent license to make, have made,\n      use, offer to sell, sell, import, and otherwise transfer the Work,\n      where such license applies only to those patent claims licensable\n      by such Contributor that are necessarily infringed by their\n      Contribution(s) alone or by combination of their Contribution(s)\n      with the Work to which such Contribution(s) was submitted. If You\n      institute patent litigation against any entity (including a\n      cross-claim or counterclaim in a lawsuit) alleging that the Work\n      or a Contribution incorporated within the Work constitutes direct\n      or contributory patent infringement, then any patent licenses\n      granted to You under this License for that Work shall terminate\n      as of the date such litigation is filed.\n\n    4. Redistribution. You may reproduce and distribute copies of the\n      Work or Derivative Works thereof in any medium, with or without\n      modifications, and in Source or Object form, provided that You\n      meet the following conditions:\n\n      (a) You must give any other recipients of the Work or\n          Derivative Works a copy of this License; and\n\n      (b) You must cause any modified files to carry prominent notices\n          stating that You changed the files; and\n\n      (c) You must retain, in the Source form of any Derivative Works\n          that You distribute, all copyright, patent, trademark, and\n          attribution notices from the Source form of the Work,\n          excluding those notices that do not pertain to any part of\n          the Derivative Works; and\n\n      (d) If the Work includes a \"NOTICE\" text file as part of its\n          distribution, then any Derivative Works that You distribute must\n          include a readable copy of the attribution notices contained\n          within such NOTICE file, excluding those notices that do not\n          pertain to any part of the Derivative Works, in at least one\n          of the following places: within a NOTICE text file distributed\n          as part of the Derivative Works; within the Source form or\n          documentation, if provided along with the Derivative Works; or,\n          within a display generated by the Derivative Works, if and\n          wherever such third-party notices normally appear. The contents\n          of the NOTICE file are for informational purposes only and\n          do not modify the License. You may add Your own attribution\n          notices within Derivative Works that You distribute, alongside\n          or as an addendum to the NOTICE text from the Work, provided\n          that such additional attribution notices cannot be construed\n          as modifying the License.\n\n      You may add Your own copyright statement to Your modifications and\n      may provide additional or different license terms and conditions\n      for use, reproduction, or distribution of Your modifications, or\n      for any such Derivative Works as a whole, provided Your use,\n      reproduction, and distribution of the Work otherwise complies with\n      the conditions stated in this License.\n\n    5. Submission of Contributions. Unless You explicitly state otherwise,\n      any Contribution intentionally submitted for inclusion in the Work\n      by You to the Licensor shall be under the terms and conditions of\n      this License, without any additional terms or conditions.\n      Notwithstanding the above, nothing herein shall supersede or modify\n      the terms of any separate license agreement you may have executed\n      with Licensor regarding such Contributions.\n\n    6. Trademarks. This License does not grant permission to use the trade\n      names, trademarks, service marks, or product names of the Licensor,\n      except as required for reasonable and customary use in describing the\n      origin of the Work and reproducing the content of the NOTICE file.\n\n    7. Disclaimer of Warranty. Unless required by applicable law or\n      agreed to in writing, Licensor provides the Work (and each\n      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n      implied, including, without limitation, any warranties or conditions\n      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n      PARTICULAR PURPOSE. You are solely responsible for determining the\n      appropriateness of using or redistributing the Work and assume any\n      risks associated with Your exercise of permissions under this License.\n\n    8. Limitation of Liability. In no event and under no legal theory,\n      whether in tort (including negligence), contract, or otherwise,\n      unless required by applicable law (such as deliberate and grossly\n      negligent acts) or agreed to in writing, shall any Contributor be\n      liable to You for damages, including any direct, indirect, special,\n      incidental, or consequential damages of any character arising as a\n      result of this License or out of the use or inability to use the\n      Work (including but not limited to damages for loss of goodwill,\n      work stoppage, computer failure or malfunction, or any and all\n      other commercial damages or losses), even if such Contributor\n      has been advised of the possibility of such damages.\n\n    9. Accepting Warranty or Additional Liability. While redistributing\n      the Work or Derivative Works thereof, You may choose to offer,\n      and charge a fee for, acceptance of support, warranty, indemnity,\n      or other liability obligations and/or rights consistent with this\n      License. However, in accepting such obligations, You may act only\n      on Your own behalf and on Your sole responsibility, not on behalf\n      of any other Contributor, and only if You agree to indemnify,\n      defend, and hold each Contributor harmless for any liability\n      incurred by, or claims asserted against, such Contributor by reason\n      of your accepting any such warranty or additional liability.\n\n    END OF TERMS AND CONDITIONS\n\n    APPENDIX: How to apply the Apache License to your work.\n\n      To apply the Apache License to your work, attach the following\n      boilerplate notice, with the fields enclosed by brackets \"[]\"\n      replaced with your own identifying information. (Don't include\n      the brackets!)  The text should be enclosed in the appropriate\n      comment syntax for the file format. We also recommend that a\n      file or class name and description of purpose be included on the\n      same \"printed page\" as the copyright notice for easier\n      identification within third-party archives.\n\n    Copyright [yyyy] [name of copyright owner]\n\n    Licensed under the Apache License, Version 2.0 (the \"License\");\n    you may not use this file except in compliance with the License.\n    You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n    Unless required by applicable law or agreed to in writing, software\n    distributed under the License is distributed on an \"AS IS\" BASIS,\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n    See the License for the specific language governing permissions and\n    limitations under the License.\n\n---- LLVM Exceptions to the Apache 2.0 License ----\n\nAs an exception, if, as a result of your compiling your source code, portions\nof this Software are embedded into an Object form of such source code, you\nmay redistribute such embedded portions in such Object form without complying\nwith the conditions of Sections 4(a), 4(b) and 4(d) of the License.\n\nIn addition, if you combine or link compiled forms of this Software with\nsoftware that is licensed under the GPLv2 (\"Combined Software\") and if a\ncourt of competent jurisdiction determines that the patent provision (Section\n3), the indemnity provision (Section 9) or other Section of the License\nconflicts with the conditions of the GPLv2, you may retroactively and\nprospectively choose to deem waived or otherwise exclude such Section(s) of\nthe License, but only in their entirety and only with respect to the Combined\nSoftware.\n\n==============================================================================\nSoftware from third parties included in the LLVM Project:\n==============================================================================\n\nThe LLVM Project contains third party software which is under different license\nterms. All such code will be identified clearly using at least one of two\nmechanisms:\n\n1) It will be in a separate directory tree with its own `LICENSE.txt` or\n   `LICENSE` file at the top containing the specific license and restrictions\n   which apply to that software, or\n2) It will contain specific license and restriction terms at the top of every\n   file.\n"
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/README.md",
        "content": "# Mojo documentation\n\nThis directory includes most of the documentation at\n[docs.modular.com/mojo](https://docs.modular.com/mojo).\n\nThe only things not here are the Jupyter notebooks, which are instead in the\n[`examples/notebooks/`](../examples/notebooks/) directory, the `mojo` CLI pages,\nand the Mojo Standard Library reference. The reference docs are generated from\nsource files, which are currently not open-sourced.\n\n## Contributing\n\nIf you see something in the docs that is wrong or could be improved, we'd love\nto accept your contributions.\n\nBe aware that we don't provide tools to generate a preview of the website,\nbecause the Mojo docs are built along with other content that's not included in\nthis repo. As such, we recommend you preview your edits in an IDE that can\nrender markdown and Jupyter notebook files, such as VS Code, including the [VS\nCode environment in GitHub](https://github.dev/modularml/mojo/blob/main/).\n\nFor more information about how to contribute, see the [Contributor\nGuide](../CONTRIBUTING.md)\n"
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/changelog.md",
        "content": "---\ntitle: Mojo🔥 changelog\nsidebar_label: Changelog\ndescription: A history of significant Mojo changes.\ntoc_max_heading_level: 2\nwebsite:\n  open-graph:\n    image: /static/images/mojo-social-card.png\n  twitter-card:\n    image: /static/images/mojo-social-card.png\n---\n\nThis is a running list of significant changes for the Mojo language and tools.\nIt doesn't include all internal implementation changes.\n\n## Update Mojo\n\nIf you don't have Mojo yet, see the [get started\nguide](/mojo/manual/get-started/#get-the-mojo-sdk).\n\nTo see your current Mojo version, run this:\n\n```sh\nmojo --version\n```\n\nTo update Mojo to the latest release, run this:\n\n```sh\nmodular update mojo\n```\n\nHowever, if your current version is 0.3.0 or lower, you'll need these additional\ncommands:\n\n```sh\nsudo apt-get update\nsudo apt-get install modular\nmodular clean\nmodular install mojo\n```\n\n[//]: # Here's the template to use when starting a new batch of notes:\n[//]: ## UNRELEASED\n[//]: ### ⭐️ New\n[//]: ### 🦋 Changed\n[//]: ### 🛠️ Fixed\n\n## v0.6.0 (2023-12-04)\n\n### 🔥 Legendary\n\n- Traits have arrived!\n\n  You can now define a _trait_, which consists of a required set of method\n  prototypes. A struct can _conform to_ the trait by implementing these methods.\n  This lets you write generic functions that work on any structs that conform to\n  a given trait.\n\n  The following section gives a brief overview of traits—see the\n  [Mojo Manual](/mojo/manual/traits.html) and this\n  [traits blog post](https://modul.ar/traits-blog) for more details!\n\n  Traits are declared with the `trait` keyword. The bodies of traits should\n  contain method signatures declared with `...` as their bodies. Default\n  method implementations are not supported yet.\n\n  ```mojo\n  trait SomeTrait:\n      fn required_method(self, x: Int): ...\n  ```\n\n  The trait can be implemented on a struct by inheriting from it.\n\n  ```mojo\n  struct SomeStruct(SomeTrait):\n      fn required_method(self, x: Int):\n          print(\"hello traits\", x)\n  ```\n\n  You can then write a generic functions that accepts any type that conforms to\n  the trait. You do this by creating a parameterized function with a\n  trait-typed parameter:\n\n  ```mojo\n  fn fun_with_traits[T: SomeTrait](x: T):\n      x.required_method(42)\n  ```\n\n  Which can be invoked with instances of types that conform to the trait:\n\n  ```mojo\n  var thing = SomeStruct()\n  # Infer the parameter `T`!\n  fun_with_traits(thing)\n  ```\n\n  Traits can also inherit from other traits, which simply requires that\n  implementors of the child trait also conform to all parent traits.\n\n  ```mojo\n  trait Parent:\n      fn parent_func(self): ...\n\n  trait Child(Parent):\n      fn child_func(self): ...\n  ```\n\n  Then, both child and parent trait methods can be invoked on instances of\n  the trait `Child`. As well, an instance of the child trait can be converted to\n  an instance of the parent trait.\n\n  ```mojo\n  fn the_parents[T: Parent](x: T):\n      x.parent_func()\n\n  fn the_children[T: Child](x: T):\n      x.child_func()\n      x.parent_func()\n      # Upcast `x` from instance of `Child` to `Parent`.\n      the_parents(x)\n  ```\n\n  For more information, see the [Traits page](/mojo/manual/traits.html)\n  in the Mojo Manual.\n\n- A fundamental `Destructable` trait has been added to the language. This is a\n  core trait that every trait automatically conforms to. This enables\n  destruction of generic types and generic collections.\n\n  **Note:** We're aware that this trait might be better spelled `Destructible`.\n  We're planning on removing it in the future and moving its functionality to\n  `AnyType` so that any type that doesn't provide its own destructor will have\n  a default, no-op destructor.\n\n- We've added some traits to the standard library, you can implement these on\n  your own types:\n\n  - [`Destructable`](/mojo/stdlib/builtin/destructable.html)\n  - [`Copyable`](/mojo/stdlib/builtin/value.html#copyable)\n  - [`Movable`](/mojo/stdlib/builtin/value.html#movable)\n  - [`Stringable`](/mojo/stdlib/builtin/str.html#stringable)\n  - [`Intable`](/mojo/stdlib/builtin/int.html#intable)\n  - [`Sized`](/mojo/stdlib/builtin/len.html#sized)\n  - [`CollectionElement`](/mojo/stdlib/utils/vector.html#collectionelement)\n\n- We added built-in [`len()`](/mojo/stdlib/builtin/len.html#len),\n  [`str()`](/mojo/stdlib/builtin/str.html#str), and\n  [`int()`](/mojo/stdlib/builtin/int.html#int-1) functions, which work with\n  types that implement the `Sized`, `Stringable`, and `Intable` traits,\n  respectively.\n\n- [`DynamicVector`](/mojo/stdlib/utils/vector.html#dynamicvector) is now a\n  proper generic collection that can use any type that implements the `Movable`\n  and `Copyable` traits. This means you can now write, for example,\n  `DynamicVector[String]`. Also, `DynamicVector` now invokes its element\n  destructors upon destruction, so `_del_old` has been deleted.\n\n- `print` now works on any types that implement `Stringable` by invoking their\n  `__str__` method:\n\n  ```mojo\n  @value\n  struct BoxedInt(Stringable):\n      var value: Int\n\n      fn __str__(self) -> String:\n          return self.value\n\n  print(BoxedInt(11), \"hello traits!\", BoxedInt(42))\n  ```\n\n### ⭐️ New\n\n- The [Mojo Manual](/mojo/manual/) is an all-new, complete Mojo user guide.\n  It doesn't include _everything_ about Mojo yet, but it includes a lot,\n  and more than the original [programming\n  manual](/mojo/programming-manual.html) (now deprecated).\n\n  Plus, the entire Mojo Manual and other Mojo docs are now [open-sourced on\n  GitHub](https://github.com/modularml/mojo/tree/main/docs), and we'd love\n  to accept contributions to help us improve them!\n\n- Mojo now supports partial automatic parameterization: when a function is\n  declared with an argument of a partially bound type, the unbound parameters\n  of that type are implicitly added to the function's input parameters. For\n  example:\n\n  ```mojo\n  @value\n  struct Fudge[a: Int, b: Int, c: Int = 7]: ...\n\n  # These function declarations are roughly equivalent:\n  fn eat(f: Fudge[5]): ...               # implicitly parameterized\n  fn eat[_b: Int](f: Fudge[5, _b]): ...  # explicitly parameterized\n  ```\n\n  In the first signature for `eat()`, the `b` parameter isn't bound, so it's\n  _implicitly_ added as an input parameter on the function.\n\n  In the second signature for `eat()`, the author has explicitly defined an\n  input parameter (`_b`), which is bound to the second parameter on the argument\n  type (which happens to be `b`).\n\n  Both functions can be called like this:\n\n  ```mojo\n  eat(Fudge[5, 8]())\n  ```\n\n  Mojo infers the value of the `b` parameter from the argument (in this case,\n  8).\n\n  With the second signature, you can also pass the `_b` parameter value\n  explicitly:\n\n  ```mojo\n  eat[3](Fudge[5, 3]())\n  ```\n\n  Moreover, Mojo now allows you to explicitly mark parameters as unbound using\n  the `_` as syntax meaning \"placeholder for an unbound parameter.\" For example:\n\n  ```mojo\n  # These function declarations are roughly equivalent:\n  fn eat(f: Fudge[5, _, c=_]): ...                    # implicitly parameterized\n  fn eat(f: Fudge[c=_, a=5, b=_]): ...                # implicitly parameterized\n  fn eat[_b: Int, _c: Int](f: Fudge[5, _b, _c]): ...  # explicitly parameterized\n  ```\n\n  The first two signatures explicitly unbind the `b` and `c` parameters.\n\n  In the last signature, the `_b` and `_c` parameters are explicitly declared by\n  the author, and bound to the `b` and `c` parameters in the argument type.\n\n  Any of these signatures can be called like this:\n\n  ```mojo\n  eat(Fudge[5, 8]())\n  eat(Fudge[5, 8, 9]())\n  ```\n\n  Note that the default parameter values of struct parameters are bound, unless\n  explicitly unbound by the user.\n\n  For more information, see the\n  [Mojo Manual](/mojo/manual/parameters/#partial-automatic-parameterization).\n\n- Parametric types can now be partially bound in certain contexts. For example,\n  a new `Scalar` type alias has been added defined as:\n\n  ```mojo\n  alias Scalar = SIMD[size=1]\n  ```\n\n  Which creates a parametric type alias `Scalar` with a single parameter of type\n  `DType`. Types can also be partially or fully bound in other contexts. For\n  instance, `alias` declarations of type values inside functions now work\n  properly:\n\n  ```mojo\n  fn type_aliases():\n      alias T = SIMD\n      print(T[DType.float32, 1]())\n      alias Partial = T[type=DType.int32]\n      print(Partial[2]())\n  ```\n\n- The `__mlir_op` feature now supports operations that return multiple results.\n  To use them, you write the `_type` field as a `Tuple` of types.  For example:\n\n  ```mojo\n  # The `ret` variable has type `Tuple[Int, Int]`.\n  let ret = __mlir_op.`multi_result_op`[ _type = (Int, Int) ]()\n  ```\n\n- Mojo now has the ability to read raw bytes from a file using the\n  [`read_bytes()`](/mojo/stdlib/builtin/file.html#read_bytes) method.\n  For example:\n\n  ```mojo\n  with open(\"file.binary\", \"r\") as f:\n      data = f.read_bytes()\n  ```\n\n- A size argument was added to the\n  [`read()`](/mojo/stdlib/builtin/file.html#read) and\n  [`read_bytes()`](/mojo/stdlib/builtin/file.html#read_bytes) methods on the\n  builtin `file.FileHandle`. The size argument defaults to -1 and maintains the\n  previous \"read to EOF\" behavior when size is negative.\n\n  ```mojo\n  with open(\"file.binary\", \"r\") as f:\n      data1 = f.read_bytes(1024)\n      data2 = f.read_bytes(256)\n  ```\n\n- [`Path`](/mojo/stdlib/pathlib/path.html#path) now has `read_bytes()` and\n  `read_text()` methods to read file contents from a path:\n\n  ```mojo\n  let text_path = Path(\"file.txt\")\n  let text = text_path.read_text()\n\n  let binary_path = Path(\"file.binary\")\n  let data = binary_path.read_bytes()\n  ```\n\n- [`Tensor`](/mojo/stdlib/tensor/tensor.html) has new `save()` and `load()`\n  methods to save and load to file. These\n  methods preserve shape and datatype information. For example:\n\n  ```mojo\n  let tensor = Tensor[DType.float32]()\n  tensor.save(path)\n\n  let tensor_from_file = Tensor[DType.float32].load(path)\n  ```\n\n  - Subscripting added to\n    [`DTypePointer`](/mojo/stdlib/memory/unsafe.html#dtypepointer) and\n    [`Pointer`](/mojo/stdlib/memory/unsafe.html#pointer):\n\n    ```mojo\n    let p = DTypePointer[DType.float16].alloc(4)\n    for i in range(4):\n        p[i] = i\n        print(p[i])\n    ```\n\n- `file.FileHandle` now has a `seek()` method.\n\n- [`String`](/mojo/stdlib/builtin/string.html#string) now has an\n  [`rfind()`](/mojo/stdlib/builtin/string.html#rfind) method analogous to\n  Python's `str.rfind()`.\n\n- `String` now has an [`split()`](/mojo/stdlib/builtin/string.html#split) method\n  analogous to Python's `str.split()`.\n\n- [`Path`](/stdlib/pathlib/path.html#path) now has a\n  [`suffix()`](/mojo/stdlib/pathlib/path.html#suffix) method analogous to\n  Python's `pathlib.Path.suffix`.\n\n- The Mojo REPL now supports indented expressions, making it a bit easier to\n  execute expressions copied from an indented block (such as a doc string).\n\n- The Mojo Language Server now implements the Document Symbols request. IDEs use\n  this to provide support for **Outline View** and **Go to Symbol**. This\n  addresses [Issue #960](https://github.com/modularml/mojo/issues/960).\n\n- The Mojo Language Server now shows documentation when code completing modules\n  or packages in `import` statements.\n\n- The Mojo Language Server now supports processing code examples, defined as\n  markdown Mojo code blocks, inside of doc strings. This enables IDE features\n  while writing examples in API documentation.\n\n- The Mojo Language Server now provides semantic token information, providing\n  better highlighting for symbols whose semantics are not statically analyzable.\n\n- The Mojo Language Server now classifies doc strings as folding ranges,\n  making them easier to collapse, reducing vertical space while editing.\n\n- Command line options for the `mojo` driver that take arguments can now be\n  written in either of two ways: both `--foo FOO` and `--foo=FOO`. Previously,\n  only the former was valid.\n\n### 🦋 Changed\n\n- Variadic list types\n  [`VariadicList`](/mojo/stdlib/builtin/builtin_list.html#variadiclist) and\n  [`VariadicListMem`](/mojo/stdlib/builtin/builtin_list.html#variadiclistmem)\n  are now iterable. Variadic arguments are automatically projected into one of\n  these types inside the function body, so var args can be iterated:\n\n  ```mojo\n  fn print_ints(*nums: Int):\n      for num in nums:\n          print(num)\n      print(len(nums))\n  ```\n\n- The assert functions in the [`testing`](/mojo/stdlib/testing/testing.html)\n  package now raise an `Error` when the assertion fails instead of returning a\n  `Bool` for whether the assertion succeeded or not.\n\n- Parameters of [`AnyType`](/mojo/stdlib/builtin/type_aliases.html) type are no\n  longer (implicitly) assumed to be register-passable. A new `AnyRegType` type\n  is used to represent generic types that are register passable.\n\n- Changing the units in a [`benchmark`](/mojo/stdlib/benchmark/benchmark.html)\n  report is now an argument instead of a parameter:\n\n  ```mojo\n  let report = benchmark.run[timer]()\n  report.print(Unit.ms)\n  ```\n\n- Default values on `inout` arguments are no longer permitted, i.e. the\n  following will now raise an error:\n\n  ```mojo\n  fn inout_default(inout x: Int = 2): ...\n  ```\n\n- The `to_string()` function has been removed from\n  [`PythonObject`](/mojo/stdlib/python/object.html#pythonobject) in favor of\n  the new `__str__()` function.  This composes better with traits so it can be\n  used with the generic `str()` function.\n\n### 🛠️ Fixed\n\n- [#734](https://github.com/modularml/mojo/issues/734) - Consumption of struct\n  works only for types with a `__del__` method.\n\n- [#910](https://github.com/modularml/mojo/issues/910) - Parser crash when\n  using memory-only generic type as return of function that `raise`s.\n\n- [#1060](https://github.com/modularml/mojo/issues/1060) - Mojo happily parses\n  code that has messed up indentation\n\n- [#1159](https://github.com/modularml/mojo/issues/1159) - The language server\n  doesn't warn about bad return type.\n\n- [#1166](https://github.com/modularml/mojo/issues/1166) - warning: unreachable\n  code after return statement with context manager\n\n- [#1098](https://github.com/modularml/mojo/issues/1098) - The language server\n  doesn't highlight properties of PythonObjects correctly.\n\n- [#1153](https://github.com/modularml/mojo/issues/1153) - The language server\n  crashes when parsing an invalid multi-nested module import.\n\n- [#1236](https://github.com/modularml/mojo/issues/1236) - The language server\n  doesn't show autocomplete in if statements.\n\n- [#1246](https://github.com/modularml/mojo/issues/1246) - Warning diagnostics\n  are transient in the presence of caching.\n\n### Known Issue\n\n- There is an issue affecting Jupyter notebooks that use autotuning and traits.\n  This issue only manifests on macOS, and the same code runs without issue\n  outside of the notebooks. This issue affects the _Matrix multiplication in\n  Mojo_ notebook.\n\n## v0.5.0 (2023-11-2)\n\n### ⭐️ New\n\n- The [`SIMD`](/mojo/stdlib/builtin/simd.html#simd) type now defaults to the\n  architectural SIMD width of the type. This means you can write\n  `SIMD[DType.float32]` which is equivalent to\n  `SIMD[DType.float32, simdwidthof[DType.float32]()]`.\n\n- The [`SIMD`](/mojo/stdlib/builtin/simd.html#simd) type now contains a `join()`\n  function that allows you to concatenate two `SIMD` values together and produce\n  a new `SIMD` value.\n\n- Mojo now supports compile-time _keyword parameters_, in addition to existing\n  support for [keyword\n  arguments](/mojo/manual/basics/#optional-arguments-and-keyword-arguments). For\n  example:\n\n  ```mojo\n  fn foo[a: Int, b: Int = 42]():\n    print(a, \"+\", b)\n\n  foo[a=5]()        # prints '5 + 42'\n  foo[a=7, b=13]()  # prints '7 + 13'\n  foo[b=20, a=6]()  # prints '6 + 20'\n  ```\n\n  Keyword parameters are also supported in structs:\n\n  ```mojo\n  struct KwParamStruct[a: Int, msg: String = \"🔥mojo🔥\"]:\n      fn __init__(inout self):\n          print(msg, a)\n\n  fn use_kw_params():\n      KwParamStruct[a=42]()               # prints '🔥mojo🔥 42'\n      KwParamStruct[5, msg=\"hello\"]()     # prints 'hello 5'\n      KwParamStruct[msg=\"hello\", a=42]()  # prints 'hello 42'\n  ```\n\n  For more detail, see the [programming\n  manual](/mojo/manual/parameters/index.html#optional-parameters-and-keyword-parameters).\n\n  For the time being, the following notable limitations apply:\n\n  - Keyword-only parameters are **not supported** yet:\n\n    ```mojo\n    fn baz[*args: Int, b: Int](): pass  # fails\n    fn baz[a: Int, *, b: Int](): pass  # fails\n    ```\n\n    (The analogous keyword-only arguments in Python are described in\n    [PEP 3102](https://peps.python.org/pep-3102/).)\n\n  - Variadic keyword parameters are **not supported** yet:\n\n    ```mojo\n    fn baz[a: Int, **kwargs: Int](): pass  # fails\n    ```\n\n- Mojo now supports \"automatic\" parameterization of functions. What this means\n  is that if a function argument type is parametric but has no bound parameters,\n  they are automatically added as input parameters on the function. This works\n  with existing features to allow you to write parametric functions with less\n  boilerplate.\n\n  ```mojo\n  @value\n  struct Thing[x: Int, y: Int]:\n      pass\n\n  fn foo(v: Thing):\n      print(v.x)\n      print(v.y)\n\n  fn main():\n      let v = Thing[2, 3]()\n      foo(v)\n  ```\n\n  However, partial autoparameterization is **not supported** yet:\n\n  ```mojo\n  fn foo(v: Thing[y=7]):  # Partially bound type not allowed yet.\n      ...\n  ```\n\n- Keyword argument passing is supported when invoking `__getitem__` using\n  the bracket syntax:\n\n  ```mojo\n  @value\n  struct MyStruct:\n    fn __getitem__(self, x: Int, y: Int, z: Int) -> Int:\n      return x * y + z\n\n  MyStruct()[z=7, x=3, y=5]  # returns 22\n  ```\n\n  However, keyword argument passing to `__setitem__` using the bracket syntax is\n  **not supported** yet:\n\n  ```mojo\n  @value\n  struct OtherStruct:\n      fn __setitem__(self, x: Int, y: Int): pass\n\n  OtherStruct()[x=1] = 4  # fails\n  ```\n\n- Function argument input parameters can now be referenced within the signature\n  of the function:\n\n  ```mojo\n  fn foo(x: SIMD, y: SIMD[x.type, x.size]):\n      pass\n  ```\n\n- The [`benchmark`](/mojo/stdlib/benchmark/benchmark.html) module has been\n  simplified and improved so you can now run:\n\n  ```mojo\n  import benchmark\n  from time import sleep\n\n  fn sleeper():\n      sleep(.01)\n\n  fn main():\n      let report = benchmark.run[sleeper]()\n      print(report.mean())\n  ```\n\n  It no longer requires a capturing `fn` so can benchmark functions outside the\n  same scope.\n\n  You can print a report with:\n\n  ```mojo\n  report.print()\n  ```\n\n  ```plaintext\n  ---------------------\n  Benchmark Report (s)\n  ---------------------\n  Mean: 0.012314264957264957\n  Total: 1.440769\n  Iters: 117\n  Warmup Mean: 0.0119335\n  Warmup Total: 0.023866999999999999\n  Warmup Iters: 2\n  Fastest Mean: 0.012227958333333334\n  Slowest Mean: 0.012442699999999999\n  ```\n\n  Units for all functions default to seconds, but can be changed with:\n\n  ```mojo\n  from benchmark import Unit\n\n  report.print[Unit.ms]()\n  ```\n\n- Mojo now supports struct parameter deduction (a.k.a. class template argument\n  deduction, or CTAD) for partially bound types. Struct parameter deduction is\n  also possible from static methods. For example:\n\n  ```mojo\n  @value\n  struct Thing[v: Int]: pass\n\n  struct CtadStructWithDefault[a: Int, b: Int, c: Int = 8]:\n      fn __init__(inout self, x: Thing[a]):\n          print(\"hello\", a, b, c)\n\n      @staticmethod\n      fn foo(x: Thing[a]):\n          print(\"🔥\", a, b, c)\n\n  fn main():\n      _ = CtadStructWithDefault[b=7](Thing[6]())  # prints 'hello 6 7 8'\n      CtadStructWithDefault[b=7].foo(Thing[6]())  # prints '🔥 6 7 8'\n  ```\n\n- [`Tensor`](/mojo/stdlib/tensor/tensor.html) has new `fromfile()` and\n  `tofile()` methods to save and load as bytes from a file.\n\n- The built-in `print()` function now works on the\n  [`Tensor`](/mojo/stdlib/tensor/tensor.html) type.\n\n- [`TensorShape`](/mojo/stdlib/tensor/tensor_shape.html) and\n  [`TensorSpec`](/mojo/stdlib/tensor/tensor_shape.html) now have constructors\n  that take [`DynamicVector[Int]`](/mojo/stdlib/utils/vector.html#dynamicvector)\n  and [`StaticIntTuple`](/mojo/stdlib/utils/index_.html#staticinttuple) to\n  initialize shapes.\n\n- The [`String`](/mojo/stdlib/builtin/string.html#string) type now has the\n `count()` and `find()` methods to enable counting the number of occurrences or\n  finding the offset index of a substring in a string.\n\n- The `String` type now has a `replace()` method which allows you to replace a\n  substring with another string.\n\n### 🦋 Changed\n\n- [`VariadicList`](/mojo/stdlib/builtin/builtin_list.html#variadiclist) and\n  [`VariadicListMem`](/mojo/stdlib/builtin/builtin_list.html#variadiclistmem)\n  moved under builtins, and no longer need to be imported.\n\n- Variadic arguments are now automatically projected into a `VariadicList` or\n  `VariadicListMem` inside the function body. This allows for more flexibility\n  in using var args. For example:\n\n  ```mojo\n    fn print_ints(*nums: Int):\n        let len = len(nums)\n        for i in range(len):\n            print(nums[i])\n        print(len)\n  ```\n\n- The parameters for\n  [`InlinedFixedVector`](/mojo/stdlib/utils/vector.html#inlinedfixedvector)\n  have been switched. The parameters are now `[type, size]` instead of\n  `[size, type]`. The `InlinedFixedVector` now has a default size which means\n  that one can just use `InlinedFixedVector` as `InlinedFixedVector[Float32]`\n  and the default size is used.\n\n- `write_file()` method in [`Buffer`](/mojo/stdlib/memory/buffer.html#buffer)\n  and [`NDBuffer`](/mojo/stdlib/memory/buffer.html#ndbuffer) is renamed to\n  `tofile()` to match the Python naming.\n\n- Mojo will now utilize all available cores across all NUMA sockets on the host\n  machine by default. The prior default behavior was to use all the cores on\n  the first socket.\n\n#### ❌ Removed\n\n- The `math.numerics` module is now private, because its types (`FPUtils` and\n  `FlushDenormals`) should not be used externally.\n\n### 🛠️ Fixed\n\n- [#532](https://github.com/modularml/mojo/issues/532) - Compiler optimizing\n  while True loop away\n- [#760](https://github.com/modularml/mojo/issues/760) - Compilation error:\n  'hlcf.for.yield' op specifies 0 branch inputs but target expected 1 along\n  control-flow edge from here\n- [#849](https://github.com/modularml/mojo/issues/849) - The `Tensor` type is\n  now initialized with zeros at construction time.\n- [#912](https://github.com/modularml/mojo/issues/912) - Invalid load for\n  `__get_address_as_lvalue`.\n- [#916](https://github.com/modularml/mojo/issues/916) - Parser crash when\n  specifying default values for `inout` arguments.\n- [#943](https://github.com/modularml/mojo/issues/943) - Mojo hangs if you\n  use continue in the nested loop\n- [#957](https://github.com/modularml/mojo/issues/957) - Parser crash when a\n  function call with variadic arguments of a memory-only type is evaluated at\n  compile time.\n- [#990](https://github.com/modularml/mojo/issues/990) - Fixes rounding\n  issue with floor division with negative numerator.\n- [#1018](https://github.com/modularml/mojo/issues/1018) - In some cases the\n  sort function was returning invalid results. This release fixes some of these\n  corner cases.\n- [#1010](https://github.com/modularml/mojo/issues/1010) - Initializing tensor\n  in alias declaration results in crash.\n- [#1110](https://github.com/modularml/mojo/issues/1110) - The `time.now()`\n  function now returns nanoseconds across all operating systems.\n- [#1115](https://github.com/modularml/mojo/issues/1115) - cannot load\n  non-register passable type into SSA register.\n\n## v0.4.0 for Mac (2023-10-19)\n\n### 🔥 Legendary\n\n- Mojo for Mac!\n\n  The Mojo SDK now works on macOS (Apple silicon). This is the same version\n  previously released for Linux. Get the latest version of the SDK for your Mac\n  system:\n\n  [Download Now!](https://developer.modular.com/download)\n\n## v0.4.0 (2023-10-05)\n\n### ⭐️ New\n\n- Mojo now supports default parameter values. For example:\n\n  ```mojo\n  fn foo[a: Int = 3, msg: StringLiteral = \"woof\"]():\n      print(msg, a)\n\n  fn main():\n      foo()  # prints 'woof 3'\n      foo[5]()  # prints 'woof 5'\n      foo[7, \"meow\"]()  # prints 'meow 7'\n  ```\n\n  Inferred parameter values take precedence over defaults:\n\n  ```mojo\n  @value\n  struct Bar[v: Int]:\n      pass\n\n  fn foo[a: Int = 42, msg: StringLiteral = \"quack\"](bar: Bar[a]):\n      print(msg, a)\n\n  fn main():\n      foo(Bar[9]())  # prints 'quack 9'\n  ```\n\n  Structs also support default parameters:\n\n  ```mojo\n  @value\n  struct DefaultParams[msg: StringLiteral = \"woof\"]:\n      alias message = msg\n\n  fn main():\n      print(DefaultParams[]().message)  # prints 'woof'\n      print(DefaultParams[\"meow\"]().message)  # prints 'meow'\n  ```\n\n- The new [`file`](/mojo/stdlib/builtin/file.html) module adds basic file I/O\n  support. You can now write:\n\n  ```mojo\n  var f = open(\"my_file.txt\", \"r\")\n  print(f.read())\n  f.close()\n  ```\n\n  or\n\n  ```mojo\n  with open(\"my_file.txt\", \"r\") as f:\n      print(f.read())\n  ```\n\n- Mojo now allows context managers to support an `__enter__` method without\n  implementing support for an `__exit__` method, enabling idioms like this:\n\n  ```mojo\n  # This context manager consumes itself and returns it as the value.\n  fn __enter__(owned self) -> Self:\n      return self^\n  ```\n\n  Here Mojo _cannot_ invoke a noop `__exit__` method because the context\n  manager is consumed by the `__enter__` method.  This can be used for types\n  (like file descriptors) that are traditionally used with `with` statements,\n  even though Mojo's guaranteed early destruction doesn't require that.\n\n- A very basic version of `pathlib` has been implemented in Mojo. The\n  module will be improved to achieve functional parity with Python in\n  the next few releases.\n\n- The `memory.unsafe` module now contains a `bitcast` function. This is a\n  low-level operation that enables bitcasting between pointers and scalars.\n\n- The input parameters of a parametric type can now be directly accessed as\n  attribute references on the type or variables of the type. For example:\n\n  ```mojo\n  @value\n  struct Thing[param: Int]:\n      pass\n\n  fn main():\n      print(Thing[2].param) # prints '2'\n      let x = Thing[9]()\n      print(x.param) # prints '9'\n  ```\n\n  Input parameters on values can even be accessed in parameter contexts. For\n  example:\n\n  ```mojo\n  fn foo[value: Int]():\n      print(value)\n\n  let y = Thing[12]()\n  alias constant = y.param + 4\n  foo[constant]() # prints '16'\n  ```\n\n- The Mojo REPL now supports code completion. Press <kbd>Tab</kbd> while typing\n  to query potential completion results.\n\n- Error messages from Python are now exposed in Mojo. For example the following\n  should print `No module named 'my_uninstalled_module'`:\n\n    ```mojo\n    fn main():\n        try:\n            let my_module = Python.import_module(\"my_uninstalled_module\")\n        except e:\n            print(e)\n    ```\n\n- Error messages can now store dynamic messages. For example, the following\n  should print \"Failed on: Hello\"\n\n    ```mojo\n    fn foo(x:String) raises:\n        raise Error(\"Failed on: \" + x)\n\n    fn main():\n        try:\n            foo(\"Hello\")\n        except e:\n            print(e)\n    ```\n\n### 🦋 Changed\n\n- We have improved and simplified the `parallelize` function. The function\n  now elides some overhead by caching the Mojo parallel runtime.\n\n- The Mojo REPL and Jupyter environments no longer implicitly expose `Python`,\n  `PythonObject`, or `Pointer`. These symbols must now be imported explicitly,\n  for example:\n\n  ```mojo\n  from python import Python\n  from python.object import PythonObject\n  from memory.unsafe import Pointer\n  ```\n\n- The syntax for specifying attributes with the `__mlir_op` prefix have changed\n  to mimic Python's keyword argument passing syntax. That is, `=` should be used\n  instead of `:`, e.g.:\n\n  ```mojo\n  # Old syntax, now fails.\n  __mlir_op.`index.bool.constant`[value : __mlir_attr.`false`]()\n  # New syntax.\n  __mlir_op.`index.bool.constant`[value=__mlir_attr.`false`]()\n  ```\n\n- You can now print the `Error` object directly. The `message()` method\n  has been removed.\n\n### 🛠️ Fixed\n\n- [#794](https://github.com/modularml/mojo/issues/794) - Parser crash when\n  using the `in` operator.\n- [#936](https://github.com/modularml/mojo/issues/936) - The `Int` constructor\n  now accepts other `Int` instances.\n- [#921](https://github.com/modularml/mojo/issues/921) - Better error message\n  when running `mojo` on a module with no  `main` function.\n- [#556](https://github.com/modularml/mojo/issues/556) - UInt64s are now\n  printed correctly.\n- [#804](https://github.com/modularml/mojo/issues/804) - Emit error instead of\n  crashing when passing variadic arguments of unsupported types.\n- [#833](https://github.com/modularml/mojo/issues/833) - Parser crash when\n  assigning module value.\n- [#752](https://github.com/modularml/mojo/issues/752) - Parser crash when\n  calling async def.\n- [#711](https://github.com/modularml/mojo/issues/711) - The overload resolution\n  logic now correctly prioritizes instance methods over static methods (if\n  candidates are an equally good match otherwise), and no longer crashed if a\n  static method has a `Self` type as its first argument.\n- [#859](https://github.com/modularml/mojo/issues/859) - Fix confusing error and\n  documentation of the `rebind` builtin.\n- [#753](https://github.com/modularml/mojo/issues/753) - Direct use of LLVM\n  dialect produces strange errors in the compiler.\n- [#926](https://github.com/modularml/mojo/issues/926) - Fixes an issue that\n  occured when a function with a return type of `StringRef` raised an error.\n  When the function raised an error, it incorrectly returned the string value of\n  that error.\n- [#536](https://github.com/modularml/mojo/issues/536) - Report More information\n  on python exception.\n\n## v0.3.1 (2023-09-28)\n\nOur first-ever patch release of the Mojo SDK is here! Release v0.3.1\nincludes primarily installation-related fixes. If you’ve had trouble\ninstalling the previous versions of the SDK, this release may be for you.\n\n### 🛠️ Fixed\n\n- [#538](https://github.com/modularml/mojo/issues/538) - Installation hangs\n  during the testing phase. This issue occurs on machines with a low number\n  of CPU cores, such as free AWS EC2 instances and GitHub Codespaces.\n- [#590](https://github.com/modularml/mojo/issues/590) - Installation fails\n  with a “failed to run python” message.\n- [#672](https://github.com/modularml/mojo/issues/672) - Language server hangs\n  on code completion. Related to #538, this occurs on machines with a low\n  number of CPU cores.\n- [#913](https://github.com/modularml/mojo/issues/913) - In the REPL and Jupyter\n  notebooks, inline comments were being parsed incorrectly.\n\n## v0.3.0 (2023-09-21)\n\nThere's more Mojo to love in this, the second release of the Mojo SDK! This\nrelease includes new features, an API change, and bug fixes.\n\nThere's also an updated version of the [Mojo extension for VS\nCode](https://marketplace.visualstudio.com/items?itemName=modular-mojotools.vscode-mojo).\n\n### ⭐️ New\n\n- Mojo now has partial support for passing keyword arguments to functions and\n  methods. For example the following should work:\n\n    ```mojo\n    fn foo(a: Int, b: Int = 3) -> Int:\n        return a * b\n\n    fn main():\n        print(foo(6, b=7))  # prints '42'\n        print(foo(a=6, b=7))  # prints '42'\n        print(foo(b=7, a=6))  # prints '42'\n    ```\n\n  Parameters can also be inferred from keyword arguments, for example:\n\n    ```mojo\n    fn bar[A: AnyType, B: AnyType](a: A, b: B):\n        print(\"Hello 🔥\")\n\n    fn bar[B: AnyType](a: StringLiteral, b: B):\n        print(a)\n\n    fn main():\n        bar(1, 2)  # prints `Hello 🔥`\n        bar(b=2, a=\"Yay!\")  # prints `Yay!`\n    ```\n\n  For the time being, the following notable limitations apply:\n\n  - Keyword-only arguments are not supported:\n\n    ```mojo\n    fn baz(*args: Int, b: Int): pass  # fails\n    fn baz(a: Int, *, b: Int): pass  # fails\n    ```\n\n    (Keyword-only arguments are described in\n    [PEP 3102](https://peps.python.org/pep-3102/).)\n\n  - Variadic keyword arguments are not supported:\n\n    ```mojo\n    fn baz(a: Int, **kwargs: Int): pass  # fails\n    ```\n\n- Mojo now supports the `@nonmaterializable` decorator.  The purpose is to mark\n  data types that should only exist in the parameter domain.  To use it, a\n  struct is decorated with `@nonmaterializable(TargetType)`.  Any time the\n  nonmaterializable type is converted from the parameter domain, it is\n  automatically converted to `TargetType`.  A nonmaterializable struct should\n  have all of its methods annotated as `@always_inline`, and must be computable\n  in the parameter domain.  In the following example, the `NmStruct` type can\n  be added in the parameter domain, but are converted to `HasBool` when\n  materialized.\n\n    ```mojo\n    @value\n    @register_passable(\"trivial\")\n    struct HasBool:\n      var x: Bool\n      fn __init__(x: Bool) -> Self:\n        return Self {x: x}\n      @always_inline(\"nodebug\")\n      fn __init__(nms: NmStruct) -> Self:\n        return Self {x: True if (nms.x == 77) else False}\n\n    @value\n    @nonmaterializable(HasBool)\n    @register_passable(\"trivial\")\n    struct NmStruct:\n      var x: Int\n      @always_inline(\"nodebug\")\n      fn __add__(self: Self, rhs: Self) -> Self:\n        return NmStruct(self.x + rhs.x)\n\n    alias stillNmStruct = NmStruct(1) + NmStruct(2)\n    # When materializing to a run-time variable, it is automatically converted,\n    # even without a type annotation.\n    let convertedToHasBool = stillNmStruct\n    ```\n\n- Mojo integer literals now produce the `IntLiteral` infinite precision integer\n  type when used in the parameter domain.  `IntLiteral` is materialized to the\n  `Int` type for runtime computation, but intermediate computations at compile\n  time, using supported operators, can now exceed the bit width of the `Int`\n  type.\n\n- The Mojo Language Server now supports top-level code completions, enabling\n  completion when typing a reference to a variable, type, etc. This resolves\n  [#679](https://github.com/modularml/mojo/issues/679).\n\n- The Mojo REPL now colorizes the resultant variables to help distinguish input\n  expressions from the output variables.\n\n### 🦋 Changed\n\n- Mojo allows types to implement two forms of move constructors, one that is\n  invoked when the lifetime of one value ends, and one that is invoked if the\n  compiler cannot prove that.  These were previously both named `__moveinit__`,\n  with the following two signatures:\n\n    ```mojo\n    fn __moveinit__(inout self, owned existing: Self): ...\n    fn __moveinit__(inout self, inout existing: Self): ...\n    ```\n\n  We've changed the second form to get its own name to make it more clear that\n  these are two separate operations: the second has been renamed to\n  `__takeinit__`:\n\n    ```mojo\n    fn __moveinit__(inout self, owned existing: Self): ...\n    fn __takeinit__(inout self, inout existing: Self): ...\n    ```\n\n  The name is intended to connote that the operation takes the conceptual value\n  from the source (without destroying it) unlike the first one which \"moves\" a\n  value from one location to another.\n\n  For more information, see the Mojo Manual section on\n  [move constructors](/mojo/manual/lifecycle/life.html#move-constructors).\n\n- The Error type in Mojo has changed. Instead of extracting the error message\n  using `error.value` you will now extract the error message using\n  `error.message()`.\n\n### 🛠️ Fixed\n\n- [#503](https://github.com/modularml/mojo/issues/503) - Improve error message\n  for failure lowering `kgen.param.constant`.\n- [#554](https://github.com/modularml/mojo/issues/554) - Alias of static tuple\n  fails to expand.\n- [#500](https://github.com/modularml/mojo/issues/500) - Call expansion failed\n  due to verifier error.\n- [#422](https://github.com/modularml/mojo/issues/422) - Incorrect comment\n  detection in multiline strings.\n- [#729](https://github.com/modularml/mojo/issues/740) - Improve messaging on\n  how to exit the REPL.\n- [#756](https://github.com/modularml/mojo/issues/756) - Fix initialization\n  errors of the VS Code extension.\n- [#575](https://github.com/modularml/mojo/issues/575) - Build LLDB/REPL with\n  libedit for a nicer editing experience in the terminal.\n\n## v0.2.1 (2023-09-07)\n\nThe first versioned release of Mojo! 🔥\n\nAll earlier releases were considered version 0.1.\n\n### 🔥 Legendary\n\n- First release of the Mojo SDK!\n\n  You can now develop with Mojo locally. The Mojo SDK is currently available\n  for Ubuntu Linux systems, and support for Windows and macOS is coming soon.\n  You can still develop from a Windows or Mac computer using a container or\n  remote Linux system.\n\n  The Mojo SDK includes the Mojo standard library and the [Mojo command-line\n  interface](/mojo/cli/) (CLI), which allows you to run, compile, and package\n  Mojo code. It also provides a REPL programming environment.\n\n  [Get the Mojo SDK!](https://developer.modular.com/download)\n\n- First release of the [Mojo extension for VS\n  Code](https://marketplace.visualstudio.com/items?itemName=modular-mojotools.vscode-mojo).\n\n  This provides essential Mojo language features in Visual Studio Code, such as\n  code completion, code quick fixes, docs tooltips, and more. Even when\n  developing on a remote system, using VS Code with this extension provides\n  a native-like IDE experience.\n\n### ⭐️ New\n\n- A new `clobber_memory` function has been added to the\n  [`benchmark`](/mojo/stdlib/benchmark/benchmark.html) module.\n  The clobber memory function tells the system to flush all memory operations\n  at the specified program point. This allows you to benchmark operations\n  without the compiler reordering memory operations.\n\n- A new `keep` function has been added to the\n  [`benchmark`](/mojo/stdlib/benchmark/benchmark.html) module. The `keep`\n  function tries to tell the compiler not to optimize the variable away\n  if not used. This allows you to avoid compiler's dead code elimination\n  mechanism, with a low footprint side effect.\n\n- New `shift_right` and `shift_left` functions have been added to the\n  [`simd`](/mojo/stdlib/builtin/simd.html) module. They shift the elements in\n  a SIMD vector right/left, filling elements with zeros as needed.\n\n- A new `cumsum` function has been added to the\n  [`reduction`](/mojo/stdlib/algorithm/reduction.html) module that computes\n  the cumulative sum (also known as scan) of input elements.\n\n- Mojo Jupyter kernel now supports code completion.\n\n### 🦋 Changed\n\n- Extends `rotate_bits_left`, `rotate_left`, `rotate_bits_right`, and\n  `rotate_right` to operate on Int values. The ordering of parameters has also\n  been changed to enable type inference. Now it's possible to write\n  `rotate_right[shift_val](simd_val)` and have the `dtype` and `simd_width`\n  inferred from the argument. This addresses\n  [Issue #528](https://github.com/modularml/mojo/issues/528).\n\n### 🛠️ Fixed\n\n- Fixed a bug causing the parser to crash when the `with` statement was written\n  without a colon.\n  This addresses [Issue #529](https://github.com/modularml/mojo/issues/529).\n\n- Incorrect imports no longer crash when there are other errors at the top\n  level of a module. This fixes [Issue\n  #531](https://github.com/modularml/mojo/issues/531).\n\n## August 2023\n\n### 2023-08-24\n\n- Fixed issue where the `with expr as x` statement within `fn` behaved\n  as if it were in a `def`, binding `x` with function scope instead of using\n  lexical scope.\n\n#### ⭐️ New\n\n- Major refactoring of the standard library to enable packaging and better\n  import ergonomics:\n  - The packages are built as binaries to improve startup speed.\n  - Package and module names are now lowercase to align with the Python style.\n  - Modules have been moved to better reflect the purpose of the underlying\n    functions (e.g. `Pointer` is now within the `unsafe` module in the `memory`\n    package).\n  - The following modules are now included as built-ins:\n    `SIMD`, `DType`, `IO`, `Object`, and `String`.\n    This means it's no longer necessary to explicitly import these modules.\n    Instead, these modules will be implicitly imported for the user. Private\n    methods within the module are still accessible using the\n    `builtin.module_name._private_method` import syntax.\n  - New `math` package has been added to contain the `bit`, `math`, `numerics`,\n    and `polynomial` modules. The contents of the `math.math` module are\n    re-exported into the `math` package.\n\n- Mojo now supports using memory-only types in parameter expressions and as\n  function or type parameters:\n\n    ```mojo\n    @value\n    struct IntPair:\n        var first: Int\n        var second: Int\n\n    fn add_them[value: IntPair]() -> Int:\n        return value.first + value.second\n\n    fn main():\n        print(add_them[IntPair(1, 2)]()) # prints '3'\n    ```\n\n- In addition, Mojo supports evaluating code that uses heap-allocated memory\n  at compile-time and materializing compile-time values with heap-allocated\n  memory into dynamic values:\n\n    ```mojo\n    fn fillVector(lowerBound: Int, upperBound: Int, step: Int) -> DynamicVector[Int]:\n        var result = DynamicVector[Int]()\n        for i in range(lowerBound, upperBound, step):\n            result.push_back(i)\n        return result\n\n    fn main():\n        alias values = fillVector(5, 23, 7)\n        for i in range(0, values.__len__()):\n            print(values[i]) # prints '5', '12', and then '19'\n    ```\n\n#### 🦋 Changed\n\n- `def main():`, without the explicit `None` type, can now be used to define\n  the entry point to a Mojo program.\n\n- The `assert_param` function has been renamed to `constrained` and is now\n  a built-in function.\n\n- The `print` function now works on `Complex` values.\n\n#### 🛠️ Fixed\n\n- Fixed issues with print formatting for `DType.uint16` and `DType.int16`.\n- [Issue #499](https://github.com/modularml/mojo/issues/499) - Two new\n  `rotate_right` and `rotate_left` functions have been added to the SIMD module.\n- [Issue #429](https://github.com/modularml/mojo/issues/429) - You can now\n  construct a `Bool` from a `SIMD` type whose element-type is `DType.bool`.\n- [Issue #350](https://github.com/modularml/mojo/issues/350) - Confusing Matrix\n  implementation\n- [Issue #349](https://github.com/modularml/mojo/issues/349) - Missing load_tr\n  in struct Matrix\n- [Issue #501](https://github.com/modularml/mojo/issues/501) - Missing syntax\n  error messages in Python expressions.\n\n### 2023-08-09\n\n#### 🦋 Changed\n\n- The `ref` and `mutref` identifiers are now treated as keywords, which means\n  they cannot be used as variable, attribute, or function names.  These keywords\n  are used by the \"lifetimes\" features, which is still in development.  We can\n  consider renaming these (as well as other related keywords) when the\n  development work gels, support is enabled in public Mojo builds, and when we\n  have experience using them.\n\n- The argument handling in `def` functions has changed: previously, they had\n  special behavior that involved mutable copies in the callee. Now, we have a\n  simple rule, which is that `def` argument default to the `owned` convention\n  (`fn` arguments still default to the `borrowed` convention).\n\n  This change is mostly an internal cleanup and simplification of the compiler\n  and argument model, but does enable one niche use-case: you can now pass\n  non-copyable types to `def` arguments by transferring ownership of a value\n  into the `def` call. Before, that would not be possible because the copy was\n  made on the callee side, not the caller's side. This also allows the explicit\n  use of the `borrowed` keyword with a `def` that wants to opt-in to that\n  behavior.\n\n### 2023-08-03\n\n#### ⭐️ New\n\n- A new [`Tensor`](/mojo/MojoStdlib/Tensor.html) type has been introduced. This\n  tensor type manages its own data (unlike `NDBuffer` and `Buffer` which are\n  just views). Therefore, the tensor type performs its own allocation and\n  free. Here is a simple example of using the tensor type to represent an RGB\n  image and convert it to grayscale:\n\n  ```mojo\n  from tensor import Tensor, TensorShape\n  from utils.index import Index\n  from random import rand\n\n  let height = 256\n  let width = 256\n  let channels = 3\n\n  # Create the tensor of dimensions height, width, channels and fill with\n  # random value.\n  let image = rand[DType.float32](height, width, channels)\n\n  # Declare the grayscale image.\n  var gray_scale_image = Tensor[DType.float32](height, width)\n\n  # Perform the RGB to grayscale transform.\n  for y in range(height):\n    for x in range(width):\n      let r = image[y,x,0]\n      let g = image[y,x,1]\n      let b = image[y,x,2]\n      gray_scale_image[Index(y,x)] = 0.299 * r + 0.587 * g + 0.114 * b\n  ```\n\n#### 🛠️ Fixed\n\n- [Issue #53](https://github.com/modularml/mojo/issues/53) - `Int` now\n  implements true division with the `/` operator. Similar to Python, this\n  returns a 64-bit floating point number. The corresponding in-place operator,\n  `/=`, has the same semantics as `//=`.\n\n## July 2023\n\n### 2023-07-26\n\n#### ⭐️ New\n\n- Types that define both `__getitem__` and `__setitem__` (i.e. where\n  sub-scripting instances creates computed LValues) can now be indexed\n  in parameter expressions.\n\n- Unroll decorator for loops with constant bounds and steps:\n  - `@unroll`: Fully unroll a loop.\n  - `@unroll(n)`: Unroll a loop by factor of n, where `n` is a positive integer.\n  - Unroll decorator requires loop bounds and iteration step to be\n  compiler time constant value, otherwise unrolling will fail with\n  compilation error. This also doesn't make loop induction variable a parameter.\n\n    ```mojo\n      # Fully unroll the loop.\n      @unroll\n      for i in range(5):\n        print(i)\n\n      # Unroll the loop by a factor of 4 (with remainder iterations of 2).\n      @unroll(4)\n      for i in range(10):\n        print(i)\n    ```\n\n- The Mojo REPL now prints the values of variables defined in the REPL. There is\n  full support for scalars and structs. Non-scalar SIMD vectors are not\n  supported at this time.\n\n#### 🛠️ Fixed\n\n- [Issue #437](https://github.com/modularml/mojo/issues/437) - Range can now\n  be instantiated with a PythonObject.\n\n- [Issue #288](https://github.com/modularml/mojo/issues/288) - Python strings\n  can now be safely copied.\n\n### 2023-07-20\n\n#### ⭐️ New\n\n- Mojo now includes a `Limits` module, which contains functions to get the max\n  and min values representable by a type, as requested in [Issue\n  #51](https://github.com/modularml/mojo/issues/51). The following functions\n  moved from `Math` to `Limits`: `inf()`, `neginf()`, `isinf()`, `isfinite()`.\n\n- Mojo decorators are now distinguished between \"signature\" and \"body\"\n  decorators and are ordered. Signature decorators, like `@register_passable`\n  and `@parameter`, modify the type of declaration before the body is parsed.\n  Body decorators, like `@value`, modify the body of declaration after it is\n  fully parsed. Due to ordering, a signature decorator cannot be applied after\n  a body decorator. That means the following is now invalid:\n\n  ```mojo\n  @register_passable # error: cannot apply signature decorator after a body one!\n  @value\n  struct Foo:\n    pass\n  ```\n\n- Global variables can now be exported in Mojo compiled archives, using the\n  `@export` decorator. Exported global variables are public symbols in compiled\n  archives and use the variable name as its linkage name, by default. A custom\n  linkage name can be specified with `@export(\"new_name\")`. This does not affect\n  variable names in Mojo code.\n\n- Mojo now supports packages! A Mojo package is defined by placing an\n  `__init__.mojo` or `__init__.🔥` within a directory. Other files in the same\n  directory form modules within the package (this works exactly like it\n  does [in Python](https://docs.python.org/3/tutorial/modules.html#packages)).\n  Example:\n\n  ```bash\n  main.🔥\n  my_package/\n    __init__.🔥\n    module.🔥\n    my_other_package/\n      __init__.🔥\n      stuff.🔥\n  ```\n\n  ```mojo\n  # main.🔥\n  from my_package.module import some_function\n  from my_package.my_other_package.stuff import SomeType\n\n  fn main():\n      var x: SomeType = some_function()\n  ```\n\n- Mojo now supports direct module and package imports! Modules and packages can\n  be imported and bound to names. Module and package elements, like functions,\n  types, global variables, and other modules, can be accessed using attribute\n  references, like `my_module.foo`. Note that modules lack runtime\n  representations, meaning module references cannot be instantiated.\n\n  ```mojo\n  import builtin.io as io\n  import SIMD\n\n  io.print(\"hello world\")\n  var x: SIMD.Float32 = 1.2\n  ```\n\n#### 🦋 Changed\n\n- Reverted the feature from 2023-02-13 that allowed unqualified struct members.\n  Use the `Self` keyword to conveniently access struct members with bound\n  parameters instead.  This was required to fix\n  [Issue #260](https://github.com/modularml/mojo/issues/260).\n\n- Updated the RayTracing notebook: added step 5 to create specular lighting for\n  more realistic images and step 6 to add a background image.\n\n#### 🛠️ Fixed\n\n- [Issue #260](https://github.com/modularml/mojo/issues/260) - Definitions\n  inside structs no longer shadow definitions outside of struct definitions.\n\n### 2023-07-12\n\n#### ⭐️ New\n\n- Mojo now has support for global variables! This enables `var` and `let`\n  declaration at the top-level scope in Mojo files. Global variable initializers\n  are run when code modules are loaded by the platform according to the order of\n  dependencies between global variables, and their destructors are called in the\n  reverse order.\n\n- The [Mojo programming manual](/mojo/programming-manual.html) is now written\n  as a Jupyter notebook, and available in its entirety in the Mojo Playground\n  (`programming-manual.ipynb`). (Previously, `HelloMojo.ipynb` included most of\n  the same material, but it was not up-to-date.)\n\n- As a result, we've also re-written `HelloMojo.ipynb` to be much shorter and\n  provide a more gentle first-user experience.\n\n- [`Coroutine` module documentation](/mojo/MojoBuiltin/Coroutine.html) is now\n  available.  Coroutines form the basis of Mojo's support for asynchronous\n  execution.  Calls to `async fn`s can be stored into a `Coroutine`, from which\n  they can be resumed, awaited upon, and have their results retrieved upon\n  completion.\n\n#### 🦋 Changed\n\n- `simd_bit_width` in the `TargetInfo` module has been renamed to `simdbitwidth`\n  to better align with `simdwidthof`, `bitwidthof`, etc.\n\n#### 🛠️ Fixed\n\n- The walrus operator now works in if/while statements without parentheses,\n  e.g. `if x := function():`.\n\n- [Issue #428](https://github.com/modularml/mojo/issues/428) - The\n  `FloatLiteral` and `SIMD` types now support conversion to `Int` via the\n  `to_int` or `__int__` method calls. The behavior matches that of Python, which\n  rounds towards zero.\n\n### 2023-07-05\n\n#### ⭐️ New\n\n- Tuple expressions now work without parentheses. For example, `a, b = b, a`\n  works as you'd expect in Python.\n- Chained assignments (e.g. `a = b = 42`) and the walrus operator (e.g.\n  `some_function(b := 17)`) are now supported.\n\n#### 🦋 Changed\n\n- The `simd_width` and `dtype_simd_width` functions in the\n  [`TargetInfo`](/mojo/MojoStdlib/TargetInfo.html) module\n  have been renamed to `simdwidthof`.\n\n- The `dtype_` prefix has been dropped from `alignof`, `sizeof`, and\n  `bitwidthof`. You can now use these functions (e.g. `alignof`) with any\n  argument type, including `DType`.\n\n- The `inf`, `neginf`, `nan`, `isinf`, `isfinite`, and `isnan` functions were\n  moved from the [`Numerics`](/mojo/MojoStdlib/Numerics.html) module to the\n  [`Math`](/mojo/MojoStdlib/Math.html) module, to better align with Python's\n  library structure.\n\n#### 🛠️ Fixed\n\n- [Issue #253](https://github.com/modularml/mojo/issues/253) - Issue\n  when accessing a struct member alias without providing parameters.\n\n- [Issue #404](https://github.com/modularml/mojo/issues/404) - The docs now use\n  `snake_case` for variable names, which more closely conforms to Python's\n  style.\n\n- [Issue #379](https://github.com/modularml/mojo/issues/379) - Tuple\n  limitations have been addressed and multiple return values are now supported,\n  even without parentheses.\n\n- [Issue #347](https://github.com/modularml/mojo/issues/347) - Tuples no longer\n  require parentheses.\n\n- [Issue #320](https://github.com/modularml/mojo/issues/320) - Python objects\n  are now traversable via `for` loops.\n\n## June 2023\n\n### 2023-06-29\n\n#### ⭐️ New\n\n- You can now share `.ipynb` notebook files in Mojo Playground. Just save a\n  file in the `shared` directory, and then right-click the file and select\n  **Copy Sharable link**. To open a shared notebook, you must already have\n  [access to Mojo Playground](/mojo/get-started.html#get-started); when\n  you open a shared notebook, click **Import** at the top of the notebook to\n  save your own copy. For more details about this feature, see the instructions\n  inside the `help` directory, in the Mojo Playground file browser.\n\n#### 🦋 Changed\n\n- The `unroll2()` and `unroll3()` functions in the\n  [`Functional`](/mojo/MojoStdlib/Functional.html) module have been renamed to\n  overload the `unroll()` function. These functions unroll 2D and 3D loops and\n  `unroll()` can determine the intent based on the number of input parameters.\n\n#### 🛠️ Fixed\n\n- [Issue #229](https://github.com/modularml/mojo/issues/229) - Issue when\n  throwing an exception from `__init__` before all fields are initialized.\n\n- [Issue #74](https://github.com/modularml/mojo/issues/74) - Struct\n  definition with recursive reference crashes.\n\n- [Issue #285](https://github.com/modularml/mojo/issues/285) - The\n  [`TargetInfo`](/mojo/MojoStdlib/TargetInfo.html) module now includes\n  `is_little_endian()` and `is_big_endian()` to check if the target host uses\n  either little or big endian.\n\n- [Issue #254](https://github.com/modularml/mojo/issues/254) - Parameter name\n  shadowing in nested scopes is now handled correctly.\n\n### 2023-06-21\n\n#### ⭐️ New\n\n- Added support for overloading on parameter signature. For example, it is now\npossible to write the following:\n\n  ```mojo\n  fn foo[a: Int](x: Int):\n      pass\n\n  fn foo[a: Int, b: Int](x: Int):\n      pass\n  ```\n\n  For details on the overload resolution logic, see the Mojo Manual section on\n  [parameters](/mojo/manual/parameters/index.html#overloading-on-parameters).\n\n- A new `cost_of()` function has been added to `Autotune`. This meta-function\n  must be invoked at compile time, and it returns the number of MLIR operations\n  in a function (at a certain stage in compilation), which can be used to\n  build basic heuristics in higher-order generators.\n\n  ```mojo\n  from autotune import cost_of\n\n  fn generator[f: fn(Int) -> Int]() -> Int:\n      @parameter\n      if cost_of[fn(Int) -> Int, f]() < 10:\n          return f()\n      else:\n          # Do something else for slower functions...\n  ```\n\n- Added a new example notebook with a basic Ray Tracing algorithm.\n\n#### 🦋 Changed\n\n- The `constrained_msg()` in the `Assert` module has been renamed to\n  `constrained()`.\n\n#### 🛠️ Fixed\n\n- Overloads marked with `@adaptive` now correctly handle signatures that differ\nonly in declared parameter names, e.g. the following now works correctly:\n\n  ```mojo\n  @adaptive\n  fn foobar[w: Int, T: DType]() -> SIMD[T, w]: ...\n\n  @adaptive\n  fn foobar[w: Int, S: DType]() -> SIMD[S, w]: ...\n  ```\n\n- [Issue #219](https://github.com/modularml/mojo/issues/219) - Issue when\n  redefining a function and a struct defined in the same cell.\n\n- [Issue #355](https://github.com/modularml/mojo/issues/355) - The loop order\n  in the Matmul notebook for Python and naive mojo have been reordered for\n  consistency. The loop order now follows (M, K, N) ordering.\n\n- [Issue #309](https://github.com/modularml/mojo/issues/309) - Use snake case\n  naming within the testing package and move the asserts out of the TestSuite\n  struct.\n\n### 2023-06-14\n\n#### ⭐️ New\n\n- Tuple type syntax is now supported, e.g. the following works:\n\n  ```mojo\n  fn return_tuple() -> (Int, Int):\n      return (1, 2)\n  ```\n\n#### 🦋 Changed\n\n- The `TupleLiteral` type was renamed to just `Tuple`, e.g.\n  `Tuple[Int, Float]`.\n\n#### 🛠️ Fixed\n\n- [Issue #354](https://github.com/modularml/mojo/issues/354) - Returning a tuple\n  doesn't work even with parens.\n- [Issue #365](https://github.com/modularml/mojo/issues/365) - Copy-paste error\n  in `FloatLiteral` docs.\n- [Issue #357](https://github.com/modularml/mojo/issues/357) - Crash when\n  missing input parameter to variadic parameter struct member function.\n\n### 2023-06-07\n\n#### ⭐️ New\n\n- Tuple syntax now works on the left-hand side of assignments (in \"lvalue\"\n  positions), enabling things like `(a, b) = (b, a)`.  There are several\n  caveats: the element types must exactly match (no implicit conversions),\n  this only works with values of `TupleLiteral` type (notably, it will not work\n  with `PythonObject` yet) and parentheses are required for tuple syntax.\n\n#### ❌ Removed\n\n- Mojo Playground no longer includes the following Python packages (due to size,\n  compute costs, and [environment complications](https://github.com/modularml/mojo/issues/300)):\n  `torch`, `tensorflow`, `keras`, `transformers`.\n\n#### 🦋 Changed\n\n- The data types and scalar names now conform to the naming convention used\n  by numpy. So we use `Int32` instead of `SI32`, similarly using `Float32`\n  instead of `F32`. Closes [Issue #152](https://github.com/modularml/mojo/issues/152).\n\n#### 🛠️ Fixed\n\n- [Issue #287](https://github.com/modularml/mojo/issues/287) - computed\n  lvalues don't handle raising functions correctly\n- [Issue #318](https://github.com/modularml/mojo/issues/318) - Large integers\n  are not being printed correctly\n- [Issue #326](https://github.com/modularml/mojo/issues/326) - Float modulo\n  operator is not working as expected\n- [Issue #282](https://github.com/modularml/mojo/issues/282) - Default arguments\n  are not working as expected\n- [Issue #271](https://github.com/modularml/mojo/issues/271) - Confusing error\n  message when converting between function types with different result semantics\n\n## May 2023\n\n### 2023-05-31\n\n#### ⭐️ New\n\n- Mojo Playground now includes the following Python packages (in response to\n  [popular demand](https://github.com/modularml/mojo/discussions/173)):\n  `torch`, `tensorflow`, `polars`, `opencv-python`, `keras`, `Pillow`, `plotly`,\n  `seaborn`, `sympy`, `transformers`.\n\n- A new optimization is applied to non-trivial copyable values that are passed\n  as an owned value without using the transfer (`^`) operator.  Consider code\n  like this:\n\n  ```mojo\n    var someValue : T = ...\n    ...\n    takeValueAsOwned(someValue)\n    ...\n  ```\n\n  When `takeValueAsOwned()` takes its argument as an\n  [`owned`](/mojo/manual/values/ownership.html#transfer-arguments-owned-and)\n  value (this is\n  common in initializers for example), it is allowed to do whatever it wants\n  with the value and destroy it when it is finished. In order to support this,\n  the Mojo compiler is forced to make a temporary copy of the `someValue`\n  value, and pass that value instead of `someValue`, because there may be other\n  uses of `someValue` after the call.\n\n  The Mojo compiler is now smart enough to detect when there are no uses of\n  `someValue` later, and it will elide the copy just as if you had manually\n  specified the transfer operator like `takeValueAsOwned(someValue^)`.  This\n  provides a nice \"it just works\" behavior for non-trivial types without\n  requiring manual management of transfers.\n\n  If you'd like to take full control and expose full ownership for your type,\n  just don't make it copyable.  Move-only types require the explicit transfer\n  operator so you can see in your code where all ownership transfer happen.\n\n- Similarly, the Mojo compiler now transforms calls to `__copyinit__` methods\n  into calls to `__moveinit__` when that is the last use of the source value\n  along a control flow path. This allows types which are both copyable and\n  movable to get transparent move optimization. For example, the following code\n  is compiled into moves instead of copies even without the use of the transfer\n  operator:\n\n  ```mojo\n    var someValue = somethingCopyableAndMovable()\n    use(someValue)\n    ...\n    let otherValue = someValue      # Last use of someValue\n    use(otherValue)\n    ...\n    var yetAnother = otherValue     # Last use of otherValue\n    mutate(yetAnother)\n  ```\n\n  This is a significant performance optimization for things like `PythonObject`\n  (and more complex value semantic types) that are commonly used in a fluid\n  programming style.  These don't want extraneous reference counting operations\n  performed by its copy constructor.\n\n  If you want explicit control over copying, it is recommended to use a\n  non-dunder `.copy()` method instead of `__copyinit__`, and recall that\n  non-copyable types must always use of the transfer operator for those that\n  want fully explicit behavior.\n\n#### 🛠️ Fixed\n\n- [Issue #231](https://github.com/modularml/mojo/issues/231) - Unexpected error\n   when a Python expression raises an exception\n- [Issue #119](https://github.com/modularml/mojo/issues/119) - The REPL fails\n   when a python variable is redefined\n\n### 2023-05-24\n\n#### ⭐️ New\n\n- `finally` clauses are now supported on `try` statements. In addition, `try`\n  statements no longer require `except` clauses, allowing `try-finally` blocks.\n  `finally` clauses contain code that is always executed from control-flow\n  leaves any of the other clauses of a `try` statement by any means.\n\n#### 🦋 Changed\n\n- `with` statement emission changed to use the new `finally` logic so that\n\n  ```mojo\n  with ContextMgr():\n      return\n  ```\n\n  Will correctly execute `ContextMgr.__exit__` before returning.\n\n#### 🛠️ Fixed\n\n- [Issue #204](https://github.com/modularml/mojo/issues/204) - Mojo REPL\n   crash when returning a String at compile-time\n- [Issue #143](https://github.com/modularml/mojo/issues/143) - synthesized\n   init in `@register_passable` type doesn't get correct convention.\n- [Issue #201](https://github.com/modularml/mojo/issues/201) - String literal\n   concatenation is too eager.\n- [Issue #209](https://github.com/modularml/mojo/issues/209) - [QoI] Terrible\n   error message trying to convert a type to itself.\n- [Issue #32](https://github.com/modularml/mojo/issues/32) - Include struct\n   fields in docgen\n- [Issue #50](https://github.com/modularml/mojo/issues/50) - Int to string\n   conversion crashes due to buffer overflow\n- [Issue #132](https://github.com/modularml/mojo/issues/132) - PythonObject\n   `to_int` method has a misleading name\n- [Issue #189](https://github.com/modularml/mojo/issues/189) - PythonObject bool\n   conversion is incorrect\n- [Issue #65](https://github.com/modularml/mojo/issues/65) - Add SIMD\n   constructor from Bool\n- [Issue #153](https://github.com/modularml/mojo/issues/153) - Meaning of\n   `Time.now` function result is unclear\n- [Issue #165](https://github.com/modularml/mojo/issues/165) - Type in\n   `Pointer.free` documentation\n- [Issue #210](https://github.com/modularml/mojo/issues/210) - Parameter results\n   cannot be declared outside top-level in function\n- [Issue #214](https://github.com/modularml/mojo/issues/214) - Pointer offset\n   calculations at compile-time are incorrect\n- [Issue #115](https://github.com/modularml/mojo/issues/115) - Float printing\n   does not include the right number of digits\n- [Issue #202](https://github.com/modularml/mojo/issues/202) -\n   `kgen.unreachable` inside nested functions is illegal\n- [Issue #235](https://github.com/modularml/mojo/issues/235) - Crash when\n   register passable struct field is not register passable\n- [Issue #237](https://github.com/modularml/mojo/issues/237) - Parameter\n   closure sharp edges are not documented\n\n### 2023-05-16\n\n#### ⭐️ New\n\n- Added missing dunder methods to `PythonObject`, enabling the use of common\n  arithmetic and logical operators on imported Python values.\n\n- `PythonObject` is now [printable from\nMojo](/mojo/notebooks/HelloMojo.html#python-integration), instead of requiring\nyou to import Python's print function.\n\n#### 🛠️ Fixed\n\n- [Issue #98](https://github.com/modularml/mojo/issues/98):\n  Incorrect error with lifetime tracking in loop.\n\n- [Issue #49](https://github.com/modularml/mojo/issues/49): Type inference\n  issue (?) in 'ternary assignment' operation (FloatLiteral vs. 'SIMD[f32, 1]').\n\n- [Issue #48](https://github.com/modularml/mojo/issues/48):\n  and/or don't work with memory-only types.\n\n- [Issue #11](https://github.com/modularml/mojo/issues/11): `setitem` Support\n  for `PythonObject`.\n\n### 2023-05-11\n\n#### ⭐️ New\n\n- `NDBuffer` and `Buffer` are now constructable via `Pointer` and\n  `DTypePointer`.\n\n- `String` now supports indexing with either integers or slices.\n\n- Added factorial function to the `Math` module.\n\n#### 🦋 Changed\n\n- The \"byref\" syntax with the `&` sigil has changed to use an `inout`\n  keyword to be more similar to the `borrowed` and `owned` syntax in arguments.\n  Please see [Issue #7](https://github.com/modularml/mojo/issues/7) for more\n  information.\n\n- Optimized the Matrix multiplication implementation in the notebook.\n  Initially we were optimizing for expandability rather than performance. We\n  have found a way to get the best of both worlds and now the performance of the\n  optimized Matmul implementation is 3x faster.\n\n- Renamed the [`^` postfix\noperator](/mojo/manual/values/ownership.html#transfer-arguments-owned-and)\nfrom \"consume\" to \"transfer.\"\n\n#### 🛠️ Fixed\n\n- Fixed missing overloads for `Testing.assertEqual` so that they work on\n`Integer` and `String` values.\n\n- [Issue #6](https://github.com/modularml/mojo/issues/6):\nPlayground stops evaluating cells when a simple generic is defined.\n\n- [Issue #18](https://github.com/modularml/mojo/issues/18):\nMemory leak in Python interoperability was removed.\n\n### 2023-05-02\n\n#### 📢 Released\n\n- Mojo publicly launched! This was epic, with lots of great coverage online\nincluding a [wonderful post by Jeremy\nHoward](https://www.fast.ai/posts/2023-05-03-mojo-launch.html). The team is\nbusy this week.\n\n#### ⭐️ New\n\n- Added a Base64 encoding function to perform base64 encoding on strings.\n\n#### 🦋 Changed\n\n- Decreased memory usage of serialization of integers to strings.\n\n- Speedup the sort function.\n\n#### 🛠️ Fixed\n\n- Fixed time unit in the `sleep` function.\n\n## April 2023\n\n### Week of 2023-04-24\n\n- 📢 The default behavior of nested functions has been changed. Mojo nested\n  functions that capture are by default are non-parametric, runtime closures,\n  meaning that:\n\n  ```mojo\n  def foo(x):\n      # This:\n      def bar(y): return x*y\n      # Is the same as:\n      let bar = lambda y: x*y\n  ```\n\n  These closures cannot have input or result parameters, because they are always\n  materialized as runtime values. Values captured in the closure (`x` in the\n  above example), are captured by copy: values with copy constructors cannot be\n  copied and captures are immutable in the closure.\n\n  Nested functions that don't capture anything are by default \"parametric\"\n  closures: they can have parameters and they can be used as parameter values.\n  To restore the previous behavior for capturing closures, \"parametric,\n  capture-by-unsafe-reference closures\", tag the nested function with the\n  `@parameter` decorator.\n\n- 📢 Mojo now has full support for \"runtime\" closures: nested functions that\n  capture state materialized as runtime values. This includes taking the address\n  of functions, indirect calls, and passing closures around through function\n  arguments. Note that capture-by-reference is still unsafe!\n\n  You can also take references to member functions with instances of that class\n  using `foo.member_function`, which creates a closure with `foo` bound to the\n  `self` argument.\n\n- 📢 Mojo now supports Python style `with` statements and context managers.\n\n  These things are very helpful for implementing things like our\n  trace region support and things like Runtime support.\n\n  A context manager in Mojo implements three methods:\n\n  ```mojo\n  fn __enter__(self) -> T:\n  fn __exit__(self):\n  fn __exit__(self, err: Error) -> Bool:\n  ```\n\n  The first is invoked when the context is entered, and returns a\n  value that may optionally be bound to a target for use in the with\n  body. If the with block exits normally, the second method is\n  invoked to clean it up. If an error is raised, the third method\n  is invoked with the Error value. If that method returns true, the\n  error is considered handled, if it returns false, the error is\n  re-thrown so propagation continues out of the 'with' block.\n\n- 📢 Mojo functions now support variable scopes! Explicit `var` and `let`\n  declarations inside functions can shadow declarations from higher \"scopes\",\n  where a scope is defined as any new indentation block. In addition, the\n  `for` loop iteration variable is now scoped to the loop body, so it is\n  finally possible to write\n\n  ```mojo\n  for i in range(1): pass\n  for i in range(2): pass\n  ```\n\n- 📢 Mojo now supports an `@value` decorator on structs to reduce boilerplate\n  and encourage best practices in value semantics.  The `@value` decorator looks\n  to see the struct has a memberwise initializer (which has arguments for each\n  field of the struct), a `__copyinit__` method, and a `__moveinit__` method,\n  and synthesizes the missing ones if possible.  For example, if you write:\n\n  ```mojo\n  @value\n  struct MyPet:\n    var name: String\n    var age: Int\n  ```\n\n  The `@value` decorator will synthesize the following members for you:\n\n  ```mojo\n    fn __init__(inout self, owned name: String, age: Int):\n       self.name = name^\n       self.age = age\n    fn __copyinit__(inout self, existing: Self):\n       self.name = existing.name\n       self.age = existing.age\n    fn __moveinit__(inout self, owned existing: Self):\n       self.name = existing.name^\n       self.age = existing.age\n  ```\n\n  This decorator can greatly reduce the boilerplate needed to define common\n  aggregates, and gives you best practices in ownership management\n  automatically.  The `@value` decorator can be used with types that need custom\n  copy constructors (your definition wins).  We can explore having the decorator\n  take arguments to further customize its behavior in the future.\n\n- 📚 Memcpy and memcmp now consistently use count as the byte count.\n\n- 📚 Add a variadic sting join on strings.\n\n- 📚 Introduce a `reduce_bit_count` method to count the number of 1 across all\n  elements in a SIMD vector.\n\n- 📚 Optimize the `pow` function if the exponent is integral.\n\n- 📚 Add a `len` function which dispatches to `__len__` across the different\n  structs that support it.\n\n### Week of 2023-04-17\n\n- 📢 Error messages have been significantly improved, thanks to prettier\n  printing for Mojo types in diagnostics.\n\n- 📢 Variadic values can now be indexed directly without wrapping them in a\n  `VariadicList`!\n\n- 📢 `let` declarations in a function can now be lazily initialized, and `var`\n  declarations that are never mutated get a warning suggesting they be converted\n  to a `let` declaration.  Lazy initialization allows more flexible patterns of\n  initialization than requiring the initializer be inline, e.g.:\n\n  ```mojo\n  let x : Int\n  if cond:\n      x = foo()\n  else:\n      x = bar()\n  use(x)\n  ```\n\n- 📢 Functions defined with `def` now return `object` by default, instead of\n  `None`. This means you can return values (convertible to `object`) inside\n  `def` functions without specifying a return type.\n\n- 📢 The `@raises` decorator has been removed. Raising `fn` should be declared\n  by specifying `raises` after the function argument list. The rationale is that\n  `raises` is part of the type system, instead of a function modifier.\n\n- 📢 The `BoolLiteral` type has been removed. Mojo now emits `True` and `False`\n  directly as `Bool`.\n\n- 📢 Syntax for function types has been added. You can now write function types\n  with `fn(Int) -> String` or `async def(&String, *Int) -> None`. No more\n  writing `!kgen.signature` types by hand!\n\n- 📢 Float literals are not emitted as `FloatLiteral` instead of an MLIR `f64`\n  type!\n\n- 📢 Automatic destructors are now supported by Mojo types, currently spelled\n  `fn __del___(owned self):` (the extra underscore will be dropped shortly).\n  These destructors work like Python object destructors and similar to C++\n  destructors, with the major difference being that they run \"as soon as\n  possible\" after the last use of a value.  This means they are not suitable\n  for use in C++-style RAII patterns (use the `with` statement for that, which\n  is currently unsupported).\n\n  These should be generally reliable for both memory-only and register-passable\n  types, with the caveat that closures are known to _not_ capture values\n  correctly.  Be very careful with interesting types in the vicinity of a\n  closure!\n\n- A new (extremely dangerous!) builtin function is available for low-level\n  ownership muckery.  The `__get_address_as_owned_value(x)` builtin takes a\n  low-level address value (of `!kgen.pointer` type) and returns an `owned` value\n  for the memory that is pointed to.  This value is assumed live at the\n  invocation of the builtin, but is \"owned\" so it needs to be consumed by the\n  caller, otherwise it will be automatically destroyed.  This is an effective\n  way to do a \"placement delete\" on a pointer.\n\n  ```mojo\n  # \"Placement delete\": destroy the initialized object begin pointed to.\n  _ = __get_address_as_owned_value(somePointer.value)\n\n  # Result value can be consumed by anything that takes it as an 'owned'\n  # argument as well.\n  consume(__get_address_as_owned_value(somePointer.value))\n  ```\n\n- Another magic operator, named `__get_address_as_uninit_lvalue(x)` joins\n  the magic LValue operator family.  This operator projects a pointer to\n  an LValue like `__get_address_as_lvalue(x)`.  The difference is that\n  `__get_address_as_uninit_lvalue(x)` tells the compiler that the pointee is\n  uninitialized on entry and initialized on exit, which means that you can use\n  it as a \"placement new\" in C++ sense.  `__get_address_as_lvalue(x)` tells the\n  compiler that the pointee is initialized already, so reassigning over it will\n  run the destructor.\n\n  ```mojo\n  # \"*Re*placement new\": destroy the existing SomeHeavy value in the memory,\n  # then initialize a new value into the slot.\n  __get_address_as_lvalue(somePointer.value) = SomeHeavy(4, 5)\n\n  # Ok to use an lvalue, convert to borrow etc.\n  use(__get_address_as_lvalue(somePointer.value))\n\n  # \"Placement new\": Initialize a new value into uninitialied memory.\n  __get_address_as_uninit_lvalue(somePointer.value) = SomeHeavy(4, 5)\n\n  # Error, cannot read from uninitialized memory.\n  use(__get_address_as_uninit_lvalue(somePointer.value))\n  ```\n\n  Note that `__get_address_as_lvalue` assumes that there is already a value at\n  the specified address, so the assignment above will run the `SomeHeavy`\n  destructor (if any) before reassigning over the value.\n\n- 📢 Implement full support for `__moveinit__` (aka move constructors)\n\n  This implements the ability for memory-only types to define two different\n  types of move ctors if they'd like:\n\n  1. `fn __moveinit__(inout self, owned existing: Self)`: Traditional Rust\n      style moving constructors that shuffles data around while taking\n      ownership of the source binding.\n  2. `fn __moveinit__(inout self, inout existing: Self):`: C++ style \"stealing\"\n     move constructors that can be used to take from an arbitrary LValue.\n\n  This gives us great expressive capability (better than Rust/C++/Swift)\n  and composes naturally into our lifetime tracking and value\n  categorization system.\n\n- The `__call__` method of a callable type has been relaxed to take `self` by\n  borrow, allow non-copyable callees to be called.\n\n- Implicit conversions are now invoked in `raise` statements properly, allowing\n  converting strings to `Error` type.\n\n- Automatic destructors are turned on for `__del__` instead of `__del___`.\n\n- 📚 Add the builtin FloatLiteral type.\n\n- 📚 Add integral `floordiv` and `mod` for the SIMD type that handle negative\n  values.\n\n- 📚 Add an F64 to String converter.\n\n- 📚 Make the `print` function take variadic inputs.\n\n### Week of 2023-04-10\n\n- 📢 Introduce consume operator `x^`\n\n  This introduces the postfix consume operator, which produces an RValue given\n  a lifetime tracked object (and, someday, a movable LValue).\n\n- Mojo now automatically synthesizes empty destructor methods for certain types\n  when needed.\n\n- The `object` type has been built out into a fully-dynamic type, with dynamic\n  function dispatch, with full error handling support.\n\n  ```mojo\n  def foo(a) -> object:\n      return (a + 3.45) < [1, 2, 3] # raises a TypeError\n  ```\n\n- 📢 The `@always_inline` decorator is no longer required for passing capturing\n  closures as parameters, for both the functions themselves as functions with\n  capturing closures in their parameters. These functions are still inlined but\n  it is an implementation detail of capturing parameter closures. Mojo now\n  distinguishes between capturing and non-capturing closures. Nested functions\n  are capturing by default and can be made non-capturing with the\n  `@noncapturing` decorator. A top-level function can be passed as a capturing\n  closure by marking it with the `@closure` decorator.\n\n- 📢 Support for list literals has been added. List literals `[1, 2, 3]`\n  generate a variadic heterogeneous list type.\n\n- Variadics have been extended to work with memory-primary types.\n\n- Slice syntax is now fully-supported with a new builtin `slice` object, added\n  to the compiler builtins. Slice indexing with `a[1:2:3]` now emits calls to\n  `__setitem__` and `__getitem__` with a slice object.\n\n- Call syntax has been wired up to `__call__`. You can now `f()` on custom\n  types!\n\n- Closures are now explicitly typed as capturing or non-capturing. If a\n  function intends to accept a capturing closure, it must specify the\n  `capturing` function effect.\n\n- 📚 Add a `Tile2D` function to enable generic `2D` tiling optimizations.\n\n- 📚 Add the `slice` struct to enable getting/setting spans of elements via\n  `getitem`/`setitem`.\n\n- 📚 Add syntax sugar to autotuning for both specifying the autotuned values,\n  searching, and declaring the evaluation function.\n\n### Week of 2023-04-03\n\n- The `AnyType` and `NoneType` aliases were added and auto-imported in all\n  files.\n\n- 📢 The Mojo VS Code extension has been improved with docstring validation. It\n  will now warn when a function's docstring has a wrong argument name, for\n  example.\n\n- 📢 A new built-in literal type `TupleLiteral` was added in `_CompilerBuiltin`.\n  It represents literal tuple values such as `(1, 2.0)` or `()`.\n\n- 📢 The `Int` type has been moved to a new `Builtin` module and is\n  auto-imported in all code. The type of integer literals has been changed from\n  the MLIR `index` type to the `Int` type.\n\n- Mojo now has a powerful flow-sensitive uninitialized variable checker.  This\n  means that you need to initialize values before using them, even if you\n  overwrite all subcomponents.  This enables the compiler to reason about the\n  true lifetime of values, which is an important stepping stone to getting\n  automatic value destruction in place.\n\n- 📢 Call syntax support has been added. Now you can directly call an object\n  that implements the `__call__` method, like `foo(5)`.\n\n- 📢 The name for copy constructors got renamed from `__copy__` to\n  `__copyinit__`.  Furthermore, non-`@register_passable` types now implement\n  it like they do an init method where you fill in a by-reference self, for\n  example:\n\n  ```mojo\n  fn __copyinit__(inout self, existing: Self):\n      self.first = existing.first\n      self.second = existing.second\n  ```\n\n  This makes copy construction work more similarly to initialization, and\n  still keeps copies `x = y` distinct from initialization `x = T(y)`.\n\n- 📢 Initializers for memory-primary types are now required to be in the form\n  `__init__(inout self, ...):` with a None result type, but for register primary\n  types, it remains in the form `__init__(...) -> Self:`. The `T{}` initializer\n  syntax has been removed for memory-primary types.\n\n- Mojo String literals now emit a builtin `StringLiteral` type! One less MLIR\n  type to worry about.\n\n- New `__getattr__` and `__setattr__` dunder methods were added. Mojo calls\n  these methods on a type when attempting member lookup of a non-static member.\n  This allows writing dynamic objects like `x.foo()` where `foo` is not a member\n  of `x`.\n\n- Early destructor support has been added. Types can now define a special\n  destructor method `__del___` (note three underscores). This is an early\n  feature and it is still being built out. There are many caveats, bugs,\n  and missing pieces. Stay tuned!\n\n- 📚 Integer division and mod have been corrected for rounding in the presence\n  of negative numbers.\n\n- 📚 Add scalar types (UI8, SI32, F32, F64, etc.) which are aliases to\n  `SIMD[1, type]`.\n\n## March 2023\n\n### Week of 2023-03-27\n\n- 📢 Parameter names are no longer load-bearing in function signatures. This\n   gives more flexibility in defining higher-order functions, because the\n   functions passed as parameters do not need their parameter names to match.\n\n   ```mojo\n   # Define a higher-order function...\n   fn generator[\n      func: __mlir_type[`!kgen.signature<`, Int, `>() -> !kgen.none`]\n   ]():\n      pass\n\n   # Int parameter is named \"foo\".\n   fn f0[foo: Int]():\n      pass\n\n   # Int parameter is named \"bar\".\n   fn f1[bar: Int]():\n      pass\n\n   fn main():\n      # Both can be used as `func`!\n      generator[f0]()\n      generator[f1]()\n   ```\n\n   Stay tuned for improved function type syntax...\n\n- 📢 Two magic operators, named `__get_lvalue_as_address(x)` and\n  `__get_address_as_lvalue` convert stored LValues to and from `!kgen.pointer`\n  types (respectively).  This is most useful when using the `Pointer[T]`\n  library type.  The `Pointer.address_of(lvalue)` method uses the first one\n  internally.  The second one must currently be used explicitly, and can be\n  used to project a pointer to a reference that you can pass around and use\n  as a self value, for example:\n\n  ```mojo\n  # \"Replacement new\" SomeHeavy value into the memory pointed to by a\n  # Pointer[SomeHeavy].\n  __get_address_as_lvalue(somePointer.value) = SomeHeavy(4, 5)\n  ```\n\n  Note that `__get_address_as_lvalue` assumes that there is already a value at\n  the specified address, so the assignment above will run the `SomeHeavy`\n  destructor (if any) before reassigning over the value.\n\n- The `(((x)))` syntax is __mlir_op has been removed in favor of\n  `__get_lvalue_as_address` which solves the same problem and is more general.\n\n- 📢 When using a mutable `self` argument to a struct `__init__` method, it\n  now must be declared with `&`, like any other mutable method.  This clarifies\n  the mutation model by making `__init__` consistent with other mutating\n  methods.\n\n- 📚 Add variadic string join function.\n\n- 📚 Default initialize values with 0 or null if possible.\n\n- 📚 Add compressed, aligned, and mask store intrinsics.\n\n### Week of 2023-03-20\n\n- Initial `String` type is added to the standard library with some very basic\n  methods.\n\n- Add `DimList` to remove the need to use an MLIR list type throughout the\n  standard library.\n\n- 📢 The `__clone__` method for copying a value is now named `__copy__` to\n  better follow Python term of art.\n\n- 📢 The `__copy__` method now takes its self argument as a \"borrowed\" value,\n  instead of taking it by reference.  This makes it easier to write, works for\n  `@register_passable` types, and exposes more optimization opportunities to\n  the early optimizer and dataflow analysis passes.\n\n  ```mojo\n  # Before:\n  fn __clone__(inout self) -> Self: ...\n\n  # After:\n  fn __copy__(self) -> Self: ...\n  ```\n\n- 📢 A new `@register_passable(\"trivial\")` may be applied to structs that\n  have no need for a custom `__copy__` or `__del__` method, and whose state is\n  only made up of `@register_passable(\"trivial\")` types.  This eliminates the\n  need to define `__copy__` boilerplate and reduces the amount of IR generated\n  by the compiler for trivial types like `Int`.\n\n- You can now write back to attributes of structs that are produced by a\n  computed lvalue expression.  For example `a[i].x = ..` works when `a[i]`\n  is produced with a `__getitem__`/`__setitem__` call.  This is implemented by\n  performing a read of `a[i]`, updating the temporary, then doing a writeback.\n\n- The remaining hurdles to using non-parametric, `@register_passable` types as\n  parameter values have been cleared. Types like `Int` should enjoy full use as\n  parameter values.\n\n- Parameter pack inference has been added to function calls. Calls to functions\n  with parameter packs can now elide the pack types:\n\n  ```mojo\n  fn foo[*Ts: AnyType](*args: *Ts): pass\n\n  foo(1, 1.2, True, \"hello\")\n  ```\n\n  Note that the syntax for parameter packs has been changed as well.\n\n- 📚 Add the runtime string type.\n\n- 📚 Introduce the DimList struct to remove the need to use low-level MLIR\n  operations.\n\n### Week of 2023-03-13\n\n- 📢 Initializers for structs now use `__init__` instead of `__new__`,\n  following standard practice in Python.  You can write them in one of two\n  styles, either traditional where you mutate self:\n\n  ```mojo\n  fn __init__(self, x: Int):\n      self.x = x\n  ```\n\n  or as a function that returns an instance:\n\n  ```mojo\n  fn __init__(x: Int) -> Self:\n      return Self {x: x}\n  ```\n\n  Note that `@register_passable` types must use the later style.\n\n- 📢 The default argument convention is now the `borrowed` convention.  A\n  \"borrowed\" argument is passed like a C++ `const&` so it doesn't need to\n  invoke the copy constructor (aka the `__clone__` method) when passing a value\n  to the function.  There are two differences from C++ `const&`:\n\n  1. A future borrow checker will make sure there are no mutable\n     aliases with an immutable borrow.\n  2. `@register_passable` values are passed directly in an SSA register (and\n     thus, usually in a machine register) instead of using an extra reference\n     wrapper.  This is more efficient and is the 'right default' for\n     `@register_passable` values like integers and pointers.\n\n  This also paves the way to remove the reference requirement from `__clone__`\n  method arguments, which will allow us to fill in more support for them.\n\n- Support for variadic pack arguments has been added to Mojo. You can now\n  write heterogeneous variadic packs like:\n\n  ```mojo\n  fn foo[*Ts: AnyType](args*: Ts): pass\n\n  foo[Int, F32, String, Bool](1, 1.5, \"hello\", True)\n  ```\n\n- The `owned` argument convention has been added. This argument convention\n  indicates that the function takes ownership of the argument and is responsible\n  for managing its lifetime.\n\n- The `borrowed` argument convention has been added. This convention signifies\n  the callee gets an immutable shared reference to a value in the caller's\n  context.\n\n- 📚 Add the `getenv` function to the `OS` module to enable getting environment\n  variables.\n\n- 📚 Enable the use of dynamic strides in `NDBuffer`.\n\n### Week of 2023-03-06\n\n- 📢 Support added for using capturing async functions as parameters.\n\n- 📢 Returning result parameters has been moved from `return` statements to a\n  new `param_return` statement. This allows returning result parameters from\n  throwing functions:\n\n  ```mojo\n  @raises\n  fn foo[() -> out: Int]():\n      param_return[42]\n      raise Error()\n  ```\n\n  And returning different parameters along `@parameter if` branches:\n\n  ```mojo\n  fn bar[in: Bool -> out: Int]():\n      @parameter\n      if in:\n          param_return[1]\n      else:\n          param_return[2]\n  ```\n\n- 📢 Mojo now supports omitting returns at the end of functions when they would\n  not reachable. For instance,\n\n  ```mojo\n  fn foo(cond: Bool) -> Int:\n      if cond:\n          return 0\n      else:\n          return 1\n\n  fn bar() -> Int:\n      while True:\n          pass\n  ```\n\n- String literals now support concatenation, so `\"hello \" \"world\"` is treated\n  the same as `\"hello world\"`.\n\n- Empty bodies on functions, structs, and control flow statements are no longer\n  allowed.  Please use `pass` in them to explicitly mark that they are empty,\n  just like in Python.\n\n- 📢 Structs in Mojo now default to living in memory instead of being passed\n  around in registers.  This is the right default for generality (large\n  structures, structures whose pointer identity matters, etc) and is a key\n  technology that enables the borrow model.  For simple types like `Int` and\n  `SIMD`, they can be marked as `@register_passable`.\n\n  Note that memory-only types currently have some limitations: they cannot be\n  used in generic algorithms that take and return a `!mlirtype` argument, and\n  they cannot be used in parameter expressions.  Because of this, a lot of\n  types have to be marked `@register_passable` just to work around the\n  limitations.  We expect to enable these use-cases over time.\n\n- 📢 Mojo now supports computed lvalues, which means you can finally assign to\n  subscript expressions instead of having to call `__setitem__` explicitly.\n\n  Some details on this: Mojo allows you to define multiple `__setitem__`\n  overloads, but will pick the one that matches your `__getitem__` type if\n  present.  It allows you to pass computed lvalues into inout arguments by\n  introducing a temporary copy of the value in question.\n\n- Mojo now has much better support for using register-primary struct types in\n  parameter expressions and as the types of parameter values. This will allow\n  migration of many standard library types away from using bare MLIR types like\n  `__mlir_type.index` and towards using `Int`. This moves us towards getting rid\n  of MLIR types everywhere and makes struct types first-class citizens in the\n  parameter system.\n\n- 📚 Add a `sort` function.\n\n- 📚 Add non-temporal store to enable cache bypass.\n\n## February 2023\n\n### Week of 2023-02-27\n\n- 📢 The `@interface`, `@implements`, and `@evaluator` trio of decorators have\n  been removed, replaced by the `@parameter if` and `@adaptive` features.\n\n- 📢 Parameter inference can now infer the type of variadic lists.\n\n- 📢 Memory primary types are now supported in function results. A result slot\n  is allocated in the caller, and the callee writes the result of the function\n  into that slow. This is more efficient for large types that don't fit into\n  registers neatly! And initializers for memory-primary types now initialize\n  the value in-place, instead of emitting a copy!\n\n- Support for `let` decls of memory primary types has been implemented. These\n  are constant, ready-only values of memory primary types but which are\n  allocated on the function stack.\n\n- Overload conversion resolution and parameter inference has been improved:\n\n  1. Inference now works with `let` decls in some scenarios that weren't\n     working before.\n  2. Parameter bindings can now infer types into parameter expressions. This\n     helps resolve higher-order functions in parameter expressions.\n\n- 📚 Optimize floor, ceil, and ldexp on X86 hardware.\n\n- 📚 Implement the log math function.\n\n### Week of 2023-02-20\n\n- 📢 A new `@__memory_primary` struct decorator has been introduced. Memory\n  primary types must always have an address. For instance, they are always\n  stack-allocated when declared in a function and their values are passed into\n  function calls by address instead of copy. This is in contract with register\n  primary types that may not have an address, and which are passed by value\n  in function calls. Memory-primary fields are not allowed inside\n  register-primary structs, because struct elements are stored in-line.\n\n- 📢 A new `_CompilerBuiltin` module was added. This module defines core types\n  and functions of the language that are referenced by the parser, and hence, is\n  auto-imported by all other modules. For example new types for literal values\n  like the boolean True/False will be included in `_CompilerBuiltin`.\n\n- 📢 A special `__adaptive_set` property can be accessed on a function reference\n  marked as `@adaptive`. The property returns the adaptive overload set of that\n  function. The return type is a `!kgen.variadic`. This feature is useful to\n  implement a generic `evaluate` function in the standard library.\n\n- 📢 A new built-in literal type `BoolLiteral` was added in `_CompilerBuiltin`.\n  It represents the literal boolean values `True` and `False`. This is the first\n  Mojo literal to be emitted as a standard library type!\n\n- 📚 Add the prefetch intrinsic to enable HW prefetching a cache line.\n\n- 📚 Add the InlinedFixedVector, which is optimized for small vectors and stores\n  values on both the stack and the heap.\n\n### Week of 2023-02-13\n\n- Unqualified lookups of struct members apply contextual parameters. This means\n  for instance that you can refer to static methods without binding the\n  struct parameters.\n\n  ```mojo\n  struct Foo[x: Int]:\n      @staticmethod\n      bar(): pass\n\n      foo(self):\n          bar()         # implicitly binds to Foo[x].bar()\n          Foo[2].bar()  # explicitly bind to another parameter\n  ```\n\n- 📢 A new `Self` type refers to the enclosing type with all parameters bound\n  to their current values.  This is useful when working with complex parametric\n  types, e.g.:\n\n  ```mojo\n  struct MyArray[size: Int, element_type: type]:\n     fn __new__() -> Self:\n         return Self {...}\n  ```\n\n  which is a lot nicer than having to say `MyArray[size, element_type]` over\n  and over again.\n\n- 📢 Mojo now supports an `@adaptive` decorator. This decorator will supersede\n  interfaces, and it represents an overloaded function that is allowed to\n  resolve to multiple valid candidates. In that case, the call is emitted as a\n  fork, resulting in multiple function candidates to search over.\n\n  ```mojo\n  @adaptive\n  fn sort(arr: ArraySlice[Int]):\n      bubble_sort(arr)\n\n  @adaptive\n  fn sort(arr: ArraySlice[Int]):\n      merge_sort(arr)\n\n  fn concat_and_sort(lhs: ArraySlice[Int], rhs: ArraySlice[Int]):\n      let arr = lhs + rhs\n      sort(arr) # this forks compilation, creating two instances\n                # of the surrounding function\n  ```\n\n- 📢 Mojo now requires that types implement the `__clone__` special member in\n  order to copy them.  This allows the safe definition of non-copyable types\n  like Atomic.  Note that Mojo still doesn't implement destructors, and (due to\n  the absence of non-mutable references) it doesn't actually invoke the\n  `__clone__` member when copying a let value. As such, this forces to you as\n  a Mojo user to write maximal boilerplate without getting much value out of it.\n\n  In the future, we will reduce the boilerplate with decorators, and we will\n  actually start using it. This will take some time to build out though.\n\n- 📢 A special `__mlir_region` statement was added to provide stronger\n  invariants around defining MLIR operation regions in Mojo. It similar syntax\n  to function declarations, except it there are no results and no input\n  conventions.\n\n- 📚 Implement the log math function.\n\n- 📚 Improve the DType struct to enable compile-time equality checks.\n\n- 📚 Add the Complex struct class.\n\n### Week of 2023-02-06\n\n- 📢 The `if` statement now supports a `@parameter` decorator, which requires\n  its condition to be a parameter expression, but which only emits the 'True'\n  side of the condition to the binary, providing a \"static if\" functionality.\n  This should eliminate many uses of `@interface` that are just used to provide\n  different constraint on the implementations.\n\n- 📢 `fn main():` is now automatically exported and directly runnable by the\n  command-line `mojo` tool. This is a stop-gap solution to enable script-like\n  use cases until we have more of the language built out.\n\n- 🪦 The `@nodebug_inline` feature has been removed, please use\n  `@alwaysinline(\"nodebug\")` for methods that must be inlined and that we don't\n  want to step into.\n\n- 📢 Python chained comparisons, ex. `a < b < c`, are now supported in Mojo.\n\n- 📢 Functions can now be defined with default argument values, such as\n  `def f(x: Int, y: Int = 5):`. The default argument value is used when callers\n  do not provide a value for that argument: `f(3)`, for example, uses the\n  default argument value of `y = 5`.\n\n- Unused coroutine results are now nicely diagnosed as \"missing await\" warnings.\n\n- 📚 Introduce a vectorized reduction operations to the SIMD type.\n\n## January 2023\n\n### Week of 2023-01-30\n\n- A basic Mojo language server has been added to the VS Code extension, which\n  parses your code as you write it, and provides warnings, errors, and fix-it\n  suggestions!\n\n- 💯 The Mojo standard library is now implicitly imported by default.\n\n- The coroutine lowering support was reworked and a new `Coroutine[T]` type was\n  implemented. Now, the result of a call to an async function MUST be wrapped in\n  a `Coroutine[T]`, or else memory will leak. In the future, when Mojo supports\n  destructors and library types as literal types, the results of async function\n  calls will automatically wrapped in a `Coroutine[T]`. But today, it must be\n  done manually. This type implements all the expected hooks, such as\n  `__await__`, and `get()` to retrieve the result. Typical usage:\n\n  ```mojo\n  async fn add_three(a: Int, b: Int, c: Int) -> Int:\n      return a + b + c\n\n  async fn call_it():\n      let task: Coroutine[Int] = add_three(1, 2, 3)\n      print(await task)\n  ```\n\n- ⭐️ We now diagnose unused expression values at statement context in `fn`\n  declarations (but not in `def`s). This catches bugs with unused values, e.g.\n  when you forget the parens to call a function.\n\n- 📢 An `@always_inline(\"nodebug\")` function decorator can be used on functions\n  that need to be force inlined, but when they should not have debug info in\n  the result.  This should be used on methods like `Int.__add__` which should\n  be treated as builtin.\n\n- 📢 The `@export` decorator now supports an explicit symbol name to export to,\n  for example:\n\n  ```mojo\n  @export(\"baz\") # exported as 'baz'\n  fn some_mojo_fn_name():\n  ```\n\n- 📢 🚧 Subscript syntax is now wired up to the `__getitem__` dunder method.\n\n  This allows type authors to implement the `__getitem__` method to enable\n  values to be subscripted.  This is an extended version of the Python semantics\n  (given we support overloading) that allows you to define N indices instead of\n  a single version that takes a tuple (also convenient because we don't have\n  tuples yet).\n\n  Note that this has a very, very important limitation: subscripts are NOT\n  wired up to `__setitem__` yet. This means that you can read values with\n  `.. = v[i]` but you cannot store to them with `v[i] = ..`.  For this, please\n  continue to call `__setitem__` directly.\n\n- 📢 Function calls support parameter inference.\n\n  For calls to functions that have an insufficient number of parameters\n  specified at the callsite, we can now infer them from the argument list. We\n  do this by matching up the parallel type structure to infer what the\n  parameters must be.\n\n  Note that this works left to right in the parameter list, applying explicitly\n  specified parameters before trying to infer new ones. This is similar to how\n  C++ does things, which means that you may want to reorder the list of\n  parameters with this in mind. For example, a `dyn_cast`-like function will be\n  more elegant when implemented as:\n\n  `fn dyn_cast[DstType: type, SrcType: type](src: SrcType) -> DstType:`\n\n  Than with the `SrcType`/`DstType` parameters flipped around.\n\n- 📚 Add the growable Dynamic vector struct.\n\n### Week of 2023-01-23\n\n- Inplace operations like `+=`/`__iadd__` may now take `self` by-val if they\n  want to, instead of requiring it to be by-ref.\n- ⭐️ Inplace operations are no longer allowed to return a non-None value.  The\n  corresponding syntax is a statement, not an expression.\n\n- A new `TaskGroup` type was added to the standard library. This type can be\n  used to schedule multiple tasks on a multi-threaded workqueue to be executed\n  in parallel. An async function can `await` all the tasks at once with the\n  taskgroup.\n\n- 📢 We now support for loops! A type that defines an `__iter__` method that\n  returns a type that defines `__next__` and `__len__` methods is eligible to\n  be used in the statement `for el in X()`. Control flow exits the loop when\n  the length is zero.\n\n  This means things like this now work:\n\n  ```mojo\n  for item in range(start, end, step):\n      print(item)\n  ```\n\n- Result parameters now have names. This is useful for referring to result\n  parameters in the return types of a function:\n\n  ```mojo\n  fn return_simd[() -> nelts: Int]() -> SIMD[f32, nelts]:\n  ```\n\n- 📢 We now support homogeneous variadics in value argument lists, using the\n  standard Python `fn thing(*args: Int):` syntax! Variadics also have support\n  in parameter lists:\n\n  ```mojo\n  fn variadic_params_and_args[*a: Int](*b: Int):\n      print(a[0])\n      print(b[1])\n  ```\n\n- 📚 Add the range struct to enable `for ... range(...)` loops.\n\n- 📚 Introduce the unroll generator to allow one to unroll loops via a library\n  function.\n\n### Week of 2023-01-16\n\n- 📢 Struct field references are now supported in parameter context, so you\n    can use `someInt.value` to get the underlying MLIR thing out of it. This\n    should allow using first-class types in parameters more widely.\n- 📢 We now support \"pretty\" initialization syntax for structs, e.g.:\n\n  ```mojo\n  struct Int:\n      var value: __mlir_type.index\n      fn __new__(value: __mlir_type.index) -> Int:\n          return Int {value: value}\n  ```\n\n  This eliminates the need to directly use the MLIR `lit.struct.create` op in\n  struct initializers.  This syntax may change in the future when ownership\n  comes in, because we will be able to support the standard `__init__` model\n  then.\n- 📢 It is now possible to attach regions to `__mlir_op` operations.  This is\n  done with a hack that allows an optional `_region` attribute that lists\n  references to the region bodies (max 1 region right now due to lack of list\n  `[]` literal).\n- Nested functions now parse, e.g.:\n\n  ```mojo\n  fn foo():\n      fn bar():\n          pass\n      bar()\n  ```\n\n- Python-style `async` functions should now work and the `await` expression\n  prefix is now supported.  This provides the joy of async/await syntactic\n  sugar when working with asynchronous functions.  This is still somewhat\n  dangerous to use because we don't have proper memory ownership support yet.\n\n- String literals are now supported.\n\n- Return processing is now handled by a dataflow pass inside the compiler, so\n  it is possible to return early out of if statements.\n\n- The parser now supports generating 'fixit' hints on diagnostics, and uses\n  them when a dictionary literal uses a colon instead of equal, e.g.:\n\n  ```log\n  x.mojo:8:48: error: expected ':' in subscript slice, not '='\n      return __mlir_op.`lit.struct.create`[value = 42]()\n                                                 ^\n                                                 :\n  ```\n\n- 📚 Add reduction methods which operate on buffers.\n\n- 📚 Add more math functions like sigmoid, sqrt, rsqrt, etc.\n\n- 📚 Add partial load / store which enable loads and stores that are predicated\n  on a condition.\n\n### Week of 2023-01-09\n\n- The `/` and `*` markers in function signatures are now parsed and their\n  invariants are checked.  We do not yet support keyword arguments yet though,\n  so they aren't very useful.\n- Functions now support a new `@nodebug_inline` decorator.\n  (Historical note: this was later replaced with `@alwaysinline(\"nodebug\")`).\n\n  Many of the things at the bottom level of the Mojo stack are trivial\n  zero-abstraction wrappers around MLIR things, for example, the `+`\n  operator on Int or the `__bool__` method on Bool itself.  These operators\n  need to be force inlined even at -O0, but they have some additional things\n  that we need to wrestle with:\n\n  1. In no case would a user actually want to step into the `__bool__` method on\n     Bool or the + method on Int.  This would be terrible debugger QoI for\n     unless you're debugging Int itself. We need something like\n     `__always_inline__, __nodebug__` attributes that clang uses in headers\n     like xmmintrin.h.\n\n  2. Similarly, these \"operators\" should be treated by users as primitives:\n     they don't want to know about MLIR or internal implementation details of\n     Int.\n\n  3. These trivial zero abstraction things should be eliminated early in the\n     compiler pipeline so they don't slow down the compiler, bloating out the\n     call graph with trivial leaves.  Such thing slows down the elaborator,\n     interferes with basic MLIR things like fold(), bloats out the IR, or\n     bloats out generated debug info.\n\n  4. In a parameter context, we want some of these things to get inlined so\n     they can be simplified by the attribute logic and play more nicely with\n     canonical types.  This is just a nice to have thing those of us who have\n     to stare at generated IR.\n\n  The solution to this is a new `@nodebug_inline` decorator. This decorator\n  causes the parser to force-inline the callee instead of generating a call to\n  it. While doing so, it gives the operations the location of the call itself\n  (that's the \"nodebug\" part) and strips out let decls that were part of the\n  internal implementation details.\n\n  This is a super-power-user-feature intended for those building the standard\n  library itself, so it is intentionally limited in power and scope: It can\n  only be used on small functions, it doesn't support regions, by-ref, throws,\n  async, etc.\n\n- Separately, we now support an `@alwaysInline` decorator on functions. This\n  is a general decorator that works on any function, and indicates that the\n  function must be inlined. Unlike `@nodebug_inline`, this kind of inlining is\n  performed later in the compilation pipeline.\n\n- The `__include` hack has been removed now that we have proper import support.\n\n- `__mlir_op` can now get address of l-value:\n\n  You can use magic `(((x)))` syntax in __mlir_op that forces the `x`\n  expression to be an lvalue, and yields its address.  This provides an escape\n  hatch (isolated off in `__mlir_op` land) that allows unsafe access to lvalue\n  addresses.\n\n- We now support `__rlshift__` and `__rtruediv__`.\n\n- 📢 The parser now resolves scoped alias references.  This allows us to support\n  things like `SomeType.someAlias`, forward substituting the value.  This\n  unblocks use of aliases in types like `DType`.  We'd like to eventually\n  preserve the reference in the AST, but this unblocks library development.\n\n- 📚 Add a `now` function and `Benchmark` struct to enable timing and\n  benchmarking.\n\n- 📚 Move more of the computation in NDBuffer from runtime to compile time if\n  possible (e.g. when the dimensions are known at compile time).\n\n### Week of 2023-01-02\n\n- 📚 Added the `print` function which works on Integers and SIMD values.\n\n- The frontend now has a new diagnostic subsystem used by the `kgen` tool (but\n  not by `kgen-translate` for tests) that supports source ranges on\n  diagnostics. Before we'd emit an error like:\n\n  ```log\n  x.mojo:13:3: error: invalid call to 'callee': in argument #0, value of type '$F32::F32' cannot be converted to expected type '$int::Int'\n    callee(1.0+F32(2.0))\n    ^\n  x.lit:4:1: note: function declared here\n  fn callee(a: Int):\n  ^\n  ```\n\n   now we produce:\n\n  ```log\n  x.mojo:13:3: error: invalid call to 'callee': in argument #0, value of type '$F32::F32' cannot be converted to expected type '$int::Int'\n    callee(1.0+F32(2.0))\n    ^      ~~~~~~~~~~~~\n  x.lit:4:1: note: function declared here\n  fn callee(a: Int):\n  ^\n  ```\n\n- 📢 Parameter results are now supported in a proper way. They are now forward\n  declared with an alias declaration and then bound in a call with an arrow,\n  e.g.:\n\n  ```mojo\n  alias a : __mlir_type.index\n  alias b : __mlir_type.index\n  idx_result_params[xyz*2 -> a, b]()\n  ```\n\n- Various minor issues with implicit conversions are fixed. For instances,\n  implicit conversions are now supported in parameter binding contexts and\n  `alias` declarations with explicit types.\n- Doc strings are allowed on functions and structs, but they are currently\n  discarded by the parser.\n\n- 📚 Add a `print` method!!!\n\n- 📚 Demonstrate a naive matmul in Mojo.\n\n- 📚 Initial work on functions that depend on types (e.g. FPUtils, nan, inf,\n  etc.)\n\n- 📚 Allow one to query hardware properties such as simd_width, os, etc. via\n  TargetInfo at compile time.\n\n## December 2022\n\n### Week of 2022-12-26\n\n- 📢 You can now call functions in a parameter context! Calling a function in\n  a parameter context will evaluate the function at compile time. The result\n  can then be used as parameter values. For example,\n\n  ```mojo\n  fn fma(x: Int, y: Int, z: Int) -> Int:\n      return a + b * c\n\n  fn parameter_call():\n      alias nelts = fma(32, 2, 16)\n      var x: SIMD[f32, nelts]\n  ```\n\n- You can now disable printing of types in an `__mlir_attr` substitution by\n   using unary `+` expression.\n\n- 📢 `let` declarations are now supported in functions.  `let` declarations are\n  local run-time constant values, which are always rvalues. They complement\n  'var' decls (which are mutable lvalues) and are the normal thing to use in\n  most cases.  They also generate less IR and are always in SSA form when\n  initialized.\n\n  We will want to extend this to support 'let' decls in structs at some point\n  and support lazy initialized 'let' declarations (using dataflow analysis) but\n  that isn't supported yet.\n\n- 📚 Add the NDBuffer struct.\n\n- Happy new year.\n\n### Week of 2022-12-19\n\n- 📚 Start of the Standard library:\n  1. Added Integer and SIMD structs to bootstrap the standard library.\n  2. Added very basic buffer data structure.\n\n- We have basic support for parsing parameter results in function calls! Result\n  parameters are an important Mojo metaprogramming feature. They allow functions\n  to return compile-time constants.\n\n  ```mojo\n  fn get_preferred_simdwidthof[() -> nelts: Int]():\n      return[2]\n\n  fn vectorized_function():\n      get_preferred_simdwidthof[() -> nelts]()\n      var x: SIMD[f32, nelts]\n  ```\n\n- Types can now be used as parameters of `!kgen.mlirtype` in many more cases.\n\n- MLIR operations with zero results don't need to specify `_type: []` anymore.\n\n- We support parsing triple quoted strings, for writing docstrings for your\n  functions and structs!\n\n- A new `__mlir_type[a,b,c]` syntax is available for substituting into MLIR\n   types and attributes is available, and the old placeholder approach is\n   removed.  This approach has a few advantages beyond what placeholders do:\n\n  1. It's simpler.\n  2. It doesn't form the intermediate result with placeholders, which\n     gets rejected by MLIR's semantic analysis, e.g. the complex case\n     couldn't be expressed before.\n  3. It provides a simple way to break long attrs/types across multiple\n     lines.\n\n- We now support an `@evaluator` decorator on functions for KGEN evaluators.\n  This enables specifying user-defined interface evaluators when performing\n  search during compilation.\n\n- 📢 `import` syntax is now supported!\n\n  This handles packaging imported modules into file ops, enables effective\n  isolation from the other decls. \"import\" into the desired context is just\n  aliasing decls, with the proper symbols references handle automatically during\n  IR generation. As a starting point, this doesn't handle any notion of packages\n  (as those haven't been sketched out enough).\n\n- 📢 Reversed binary operators (like `__radd__`) are now looked up and used if\n  the forward version (like `__add__`) doesn't work for some reason.\n\n- 📢 Implicit conversions are now generally available, e.g. in assign\n  statements, variable initializers etc. There are probably a few more places\n  they should work, but we can start eliminating all the extraneous explicit\n  casts from literals now.\n\n- Happy Holidays\n\n### Week of 2022-12-12\n\n- 📢 Function overloading now works. Call resolution filters candidate list\n  according to the actual parameter and value argument specified at the site of\n  the call, diagnosing an error if none of the candidates are viable or if\n  multiple are viable and ambiguous. We also consider implicit conversions in\n  overload look:\n\n  ```mojo\n  fn foo(x: Int): pass\n  fn foo(x: F64): pass\n\n  foo(Int(1)) # resolves to the first overload\n  foo(1.0)    # resolves to the second overload\n  foo(1)      # error: both candidates viable with 1 implicit conversion!\n  ```\n\n- The short circuiting binary `and` and `or` expressions are now supported.\n\n- Unary operator processing is a lot more robust, now handling the `not`\n  expression and `~x` on Bool.\n\n- 📢 The compiler now generates debug information for use with GDB/LLDB that\n  describes variables and functions.\n\n- The first version of the Mojo Visual Studio Code extension has been released!\n  It supports syntax highlighting for Mojo files.\n\n- The first version of the `Bool` type has landed in the new Mojo standard\n  library!\n\n- 📢 Implicit conversions are now supported in return statements.\n\n### Week of 2022-12-05\n\n- \"Discard\" patterns are now supported, e.g. `_ = foo()`\n\n- We now support implicit conversions in function call arguments, e.g.\n   converting an `index` value to `Int` automatically.  This eliminates a bunch\n   of casts, e.g. the need to say F32(1.0) everywhere.\n\n   This is limited for a few reasons that will be improved later:\n   1. We don't support overloading, so lots of types aren't convertible\n      from all the things they should be, e.g. you can't pass \"1\" to\n      something that expects F32, because F32 can't be created from index.\n   2. This doesn't \"check to see if we can invoke `__new__`\" it force applies\n      it on a mismatch, which leads to poor QoI.\n   3. This doesn't fix things that need radd.\n\n## November 2022\n\n### Week of 2022-11-28\n\n- 📢 We support the `True` and `False` keywords as expressions.\n\n- 📢 A new `alias` declaration is supported which allows defining local\n   parameter values.  This will eventually subsume type aliases and other\n   things as it gets built out.\n\n- 📢 We now have end-to-end execution of Mojo files using the `kgen` tool!\n  Functions exported with `@export` can be executed.\n\n- 📢 We have try-except-else and `raise` statements and implicit error\n  propagation! The error semantics are that `def` can raise by default, but `fn`\n  must explicitly declare raising with a `@raises` decorator. Stub out basic\n  `Error` type.\n\n- The `&` sigil for by-ref arguments is now specified after the identifier.\n  Postfix works better for ref and move operators on the expression\n  side because it chains an mentally associates correctly:\n  `thing.method().result^`. We don't do that yet, but align param\n  decl syntax to it so that things won't be odd looking when we do.\n  In practice this looks like:\n\n  ```mojo\n  def mutate_argument(a&: index):\n      a = 25\n  ```\n\n### Week of 2022-11-21\n\n- 📢 The magic `index` type is gone. Long live `__mlir_type.index`.\n\n- Implement parameter substitution into parametric `__mlir_type` decls. This\n  allows us to define parametric opaque MLIR types with exposed parameters using\n  a new \"placeholder\" attribute.  This allows us to expose the power of the KGEN\n  type parametric system directly into Mojo.\n\n- 📢 Fully-parametric custom types can now be defined and work in Mojo, bringing\n  together a lot of the recent work. We can write the SIMD type directly as a\n  wrapper around the KGEN type, for example:\n\n  ```mojo\n  struct SIMD[dt: __mlir_type.`!kgen.dtype`, nelts: __mlir_type.index]:\n      var value:\n        __mlir_type.`!pop.simd<#lit<placeholder index>,\n                               #lit<placeholder !kgen.dtype>>`[nelts, dt]\n\n      fn __add__(self, rhs: SIMD[dt, nelts]) -> SIMD[dt, nelts]:\n          return __mlir_op.`pop.add`(self.value, rhs.value)\n  ```\n\n### Week of 2022-11-14\n\n- 📢 Implement a magic `__mlir_type` declaration that can be used to access any\n  MLIR type. E.g. `__mlir_type.f64`.\n\n- 📢 Add an `fn` declaration. These are like `def` declarations, but are more\n  strict in a few ways: they require type annotations on arguments, don't allow\n  implicit variable declarations in their body, and make their arguments rvalues\n  instead of lvalues.\n\n- Implemented Swift-style backtick identifiers, which are useful for code\n  migration where names may collide with new keywords.\n\n- 📢 A new `__include` directive has been added that performs source-level\n  textual includes. This is temporary until we have an `import` model.\n\n- Implement IR generation for arithmetic operators like `+` and `*` in terms\n  of the `__add__` and `__mul__` methods.\n\n- 📢 Added support for `break` and `continue` statements, as well as early\n  returns inside loops and conditionals!\n\n- 📢 Implemented augmented assignment operators, like `+=` and `@=`.\n\n- 📢 Mojo now has access to generating any MLIR operations (without regions)\n  with a new `__mlir_op` magic declaration. We can start to build out the\n  language's builtin types with this:\n\n  ```mojo\n  struct Int:\n      var value: __mlir_type.index\n\n      fn __add__(self, rhs: Int) -> Int:\n          return __mlir_op.`index.add`(self.value, rhs.value)\n  ```\n\n  Attributes can be attached to the declaration with subscript `[]` syntax,\n  and an explicit result type can be specified with a special `_type` attribute\n  if it cannot be inferred. Attributes can be accessed via the `__mlir_attr`\n  magic decl:\n\n  ```mojo\n  __mlir_op.`index.cmp`[\n      _type: __mlir_type.i1,\n      pred: __mlir_attr.`#index<cmp_predicate slt>`\n  ](lhs, rhs)\n  ```\n\n- Improved diagnostics emissions with ranges! Now errors highlight the whole\n  section of code and not just the first character.\n\n### Week of 2022-11-07\n\n- Implemented the `@interface` and `@implements` decorators, which provide\n  access to KGEN generator interfaces. A function marked as an `@interface`\n  has no body, but it can be implemented by multiple other functions.\n\n  ```mojo\n  @interface\n  def add(lhs: index, rhs: index):\n\n  @implements(add)\n  def normal_add(lhs: index, rhs: index) -> index:\n      return lhs + rhs\n\n  @implements(add)\n  def slow_add(lhs: index, rhs: index) -> index:\n      wait(1000)\n      return normal_add(lhs, rhs)\n  ```\n\n- 📢 Support for static struct methods and initializer syntax has been added.\n  Initializing a struct with `Foo()` calls an implicitly static `__new__`\n  method. This method should be used instead of `__init__` inside structs.\n\n  ```mojo\n  struct Foo:\n      var value: index\n\n      def __new__() -> Foo:\n          var result: Foo\n          result.value = Foo.return_a_number() # static method!\n          return result\n\n      @staticmethod\n      def return_a_number() -> index:\n          return 42\n  ```\n\n- 📢 Full by-ref argument support. It's now possible to define in-place\n  operators like `__iadd__` and functions like `swap(x, y)` correctly.\n\n- 📢 Implemented support for field extract from rvalues, like `x.value` where\n  `x` is not an lvalue (`var` declaration or by-ref function argument).\n\n## October 2022\n\n### Week of 2022-10-31\n\n- Revised `return` handling so that a return statement with no expression is\n  syntax sugar for `return None`. This enables early exits in functions that\n  implicitly return `None` to be cleaner:\n\n  ```mojo\n  def just_return():\n      return\n  ```\n\n- Added support for parsing more expressions: if-else, bitwise operators,\n  shift operators, comparisons, floor division, remainder, and matmul.\n\n- 📢 The type of the `self` argument can now be omitted on member methods.\n\n### Week of 2022-10-24\n\n- Added parser support for right-associativity and unary ops, like the power\n  operator `a ** b ** c` and negation operator `-a`.\n\n- Add support for `&expr` in Mojo, which allows denoting a by-ref argument in\n  functions. This is required because the `self` type of a struct method is\n  implicitly a pointer.\n\n- Implemented support for parametric function declarations, such as:\n\n  ```mojo\n  struct SIMD[dt: DType, width: index]:\n      fn struct_method(self: &SIMD[dt, width]):\n          pass\n\n  def fancy_add[dt: DType, width: index](\n      lhs: SIMD[dt, width], rhs: SIMD[dt, width]) -> index:\n    return width\n  ```\n\n### Week of 2022-10-17\n\n- Added explicit variable declarations with `var`, for declaring variables both\n  inside functions and structs, with support for type references. Added `index`\n  as a temporary built-in type.\n\n  ```mojo\n  def foo(lhs: index, rhs: index) -> index:\n      var result: index = lhs + rhs\n      return result\n  ```\n\n- Implemented support for parsing struct declarations and references to type\n  declarations in functions! In `def`, the type can be omitted to signal an\n  object type.\n\n  ```mojo\n  struct Foo:\n      var member: index\n\n  def bar(x: Foo, obj) -> index:\n      return x.member\n  ```\n\n- Implemented parser support for `if` statements and `while` loops!\n\n  ```mojo\n  def if_stmt(c: index, a: index, b: index) -> index:\n      var result: index = 0\n      if c:\n          result = a\n      else:\n          result = b\n      return result\n\n  def while_stmt(init: index):\n      while init > 1:\n          init = init - 1\n  ```\n\n- Significantly improved error emission and handling, allowing the parser to\n  emit multiple errors while parsing a file.\n\n### Week of 2022-10-10\n\n- Added support for parsing integer, float, and string literals.\n\n- Implemented parser support for function input parameters and results. You can\n  now write parametric functions like,\n\n  ```mojo\n  def foo[param: Int](arg: Int) -> Int:\n      result = param + arg\n      return result\n  ```\n\n### Week of 2022-10-03\n\n- Added some basic parser scaffolding and initial parser productions, including\n  trivial expressions and assignment parser productions.\n- Implemented basic scope handling and function IR generation, with support for\n  forward declarations. Simple functions like,\n\n  ```mojo\n  def foo(x: Int):\n  ```\n\n  Now parse! But all argument types are hard-coded to the MLIR `index` type.\n\n- Added IR emission for simple arithmetic expressions on builtin types, like\n  `x + y`.\n\n## September 2022\n\n### Week of 2022-09-26\n\n- Mojo's first patch to add a lexer was Sep 27, 2022.\n\n- Settled on `[]` for Mojo generics instead of `<>`. Square brackets are\n  consistent with Python generics and don't have the less than ambiguity\n  other languages have.\n"
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/community.md",
        "content": "---\ntitle: Mojo🔥 community\nsidebar_label: Community\ndescription: Resources to share feedback, report issues, and chat.\nwebsite:\n  open-graph:\n    image: /static/images/mojo-social-card.png\n  twitter-card:\n    image: /static/images/mojo-social-card.png\n---\n\nMojo is still very young, but we believe an active community and a strong\nfeedback pipeline is key to its success.\n\nWe'd love to hear from you through the following community channels.\n\n<p><br/></p>\n\n<div class=\"quarto-listing quarto-listing-container-grid\">\n<div class=\"list grid quarto-listing-cols-3\">\n\n<div class=\"g-col-1\" data-index=\"1\"\ndata-listing-file-modified-sort=\"1683253897285\"\ndata-listing-reading-time-sort=\"11.335\" data-categories=\"null\"\ndata-listing-date-sort=\"null\">\n<a href=\"https://github.com/modularml/mojo/discussions\"\nclass=\"quarto-grid-link\">\n<div class=\"quarto-grid-item card h-100 card-left\">\n<div class=\"card-body post-contents\">\n<h5 class=\"no-anchor card-title listing-title\">\n<i class=\"bi bi-github\"></i> Ask a question\n</h5>\n<div class=\"card-text listing-description\">\nSee existing GitHub Discussion posts, ask new questions, and share your ideas.\n<br/><br/>\nThis is a forum for ideas and questions, moderated by the Modular team.\n</div>\n</div>\n</div>\n</a>\n</div>\n\n<div class=\"g-col-1\" data-index=\"0\"\ndata-listing-file-modified-sort=\"1683253897286\"\ndata-listing-reading-time-sort=\"21.275\" data-categories=\"null\"\ndata-listing-date-sort=\"null\">\n<a href=\"https://github.com/modularml/mojo/issues/new/choose\"\n   class=\"quarto-grid-link\">\n<div class=\"quarto-grid-item card h-100 card-left\">\n<div class=\"card-body post-contents\">\n<h5 class=\"no-anchor card-title listing-title\">\n<i class=\"bi bi-github\"></i> Report an issue\n</h5>\n<div class=\"card-text listing-description\">\nReport bugs or other issues with the Mojo SDK or Mojo Playground.\n<br/><br/>\nBefore reporting an issue, see the <a href=\"/mojo/roadmap.html\">Mojo\nroadmap & sharp edges</a>.\n</div>\n</div>\n</div>\n</a>\n</div>\n\n<div class=\"g-col-1\" data-index=\"1\"\ndata-listing-file-modified-sort=\"1683253897287\"\ndata-listing-reading-time-sort=\"11.335\" data-categories=\"null\"\ndata-listing-date-sort=\"null\">\n<a href=\"https://www.discord.gg/modular\" class=\"quarto-grid-link\">\n<div class=\"quarto-grid-item card h-100 card-left\">\n<div class=\"card-body post-contents\">\n<h5 class=\"no-anchor card-title listing-title\">\n<i class=\"bi bi-discord\"></i> Chat on Discord\n</h5>\n<div class=\"card-text listing-description\">\nJoin our realtime chat on Discord to discuss the Mojo language and tools with\nthe community.<br/><br/>\nThis is a community space where you can chat with\nother Mojo developers in realtime.\n</div>\n</div>\n</div>\n</a>\n</div>\n\n</div>\n<div class=\"listing-no-matching d-none\">\n&nbsp;\n</div>\n</div>\n"
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/faq.md",
        "content": "---\ntitle: Mojo🔥 FAQ\nsidebar_label: FAQ\ndescription: Answers to questions we expect about Mojo.\nwebsite:\n  open-graph:\n    image: /static/images/mojo-social-card.png\n  twitter-card:\n    image: /static/images/mojo-social-card.png\n---\n\n<style>\n    .content h3 {\n        font-size: 1rem;\n        font-weight: bold;\n    }\n</style>\n\nWe tried to anticipate your questions about Mojo on this page. If this page\ndoesn't answer all your questions, also check out our [Mojo community\nchannels](/mojo/community.html).\n\n## Motivation\n\n### Why did you build Mojo?\n\nWe built Mojo to solve an internal challenge at Modular, and we are using it\nextensively in our systems such as our [AI\nEngine](/engine). As a result, we are extremely committed to\nits long term success and are investing heavily in it. Our overall mission is\nto unify AI software and we can’t do that without a unified language that can\nscale across the AI infrastructure stack. That said, we don’t plan to stop at\nAI—the north star is for Mojo to support the whole gamut of general-purpose\nprogramming over time. For a longer answer, read [Why\nMojo](/mojo/why-mojo.html).\n\n### Why is it called Mojo?\n\nMojo means “a magical charm” or “magical powers.” We thought this was a fitting\nname for a language that brings magical powers to Python, including unlocking\nan innovative programming model for accelerators and other heterogeneous\nsystems pervasive in AI today.\n\n### Why does mojo have the 🔥 file extension?\n\nWe paired Mojo with fire emoji 🔥 as a fun visual way to impart onto users that\nMojo empowers them to get their Mojo on—to develop faster and more efficiently\nthan ever before. We also believe that the world can handle a unicode extension\nat this point, but you can also just use the `.mojo` extension. :)\n\n### What problems does Mojo solve that no other language can?\n\nMojo combines the usability of Python with the systems programming features\nit’s missing. We are guided more by pragmatism than novelty, but Mojo’s use of\n[MLIR](https://mlir.llvm.org/) allows it to scale to new exotic hardware types\nand domains in a way that other languages haven’t demonstrated (for an example\nof Mojo talking directly to MLIR, see our [low-level IR in Mojo\nnotebook](/mojo/notebooks/BoolMLIR.html)). It also\nincludes autotuning, and has caching and distributed compilation built into its\ncore. We also believe Mojo has a good chance of unifying hybrid packages in the\nbroader Python community.\n\n### What kind of developers will benefit the most from Mojo?\n\nMojo’s initial focus is to bring programmability back to AI, enabling AI\ndevelopers to customize and get the most out of their hardware. As such, Mojo\nwill primarily benefit researchers and other engineers looking to write\nhigh-performance AI operations. Over time, Mojo will become much more\ninteresting to the general Python community as it grows to be a superset of\nPython. We hope this will help lift the vast Python library ecosystem and\nempower more traditional systems developers that use C, C++, Rust, etc.\n\n### Why build upon Python?\n\nEffectively, all AI research and model development happens in Python today, and\nthere’s a good reason for this! Python is a powerful high-level language with\nclean, simple syntax and a massive ecosystem of libraries. It’s also one of the\nworld's [most popular programming\nlanguages](https://www.tiobe.com/tiobe-index/), and we want to help it become\neven better. At Modular, one of our core principles is meeting customers where\nthey are—our goal is not to further fragment the AI landscape but to unify and\nsimplify AI development workflows.\n\n### Why not enhance CPython (the major Python implementation) instead?\n\nWe’re thrilled to see a big push to improve\n[CPython](https://en.wikipedia.org/wiki/CPython) by the existing community, but\nour goals for Mojo (such as to deploy onto GPUs and other accelerators) need a\nfundamentally different architecture and compiler approach underlying it.\nCPython is a significant part of our compatibility approach and powers our\nPython interoperability.\n\n### Why not enhance another Python implementation (like Codon, PyPy, etc)?\n\nCodon and PyPy aim to improve performance compared to CPython, but Mojo’s goals\nare much deeper than this. Our objective isn’t just to create “a faster\nPython,” but to enable a whole new layer of systems programming that includes\ndirect access to accelerated hardware, as outlined in [Why\nMojo](/mojo/why-mojo.html). Our technical implementation\napproach is also very different, for example, we are not relying on heroic\ncompiler and JIT technologies to “devirtualize” Python.\n\nFurthermore, solving big challenges for the computing industry is hard and\nrequires a fundamental rethinking of the compiler and runtime infrastructure.\nThis drove us to build an entirely new approach and we’re willing to put in the\ntime required to do it properly (see our blog post about [building a\nnext-generation AI\nplatform](https://www.modular.com/blog/the-case-for-a-next-generation-ai-developer-platform)),\nrather than tweaking an existing system that would only solve a small part of\nthe problem.\n\n### Why not make Julia better?\n\nWe think [Julia](https://julialang.org/) is a great language and it has a\nwonderful community, but Mojo is completely different. While Julia and Mojo\nmight share some goals and look similar as an easy-to-use and high-performance\nalternative to Python, we’re taking a completely different approach to building\nMojo. Notably, Mojo is Python-first and doesn't require existing Python\ndevelopers to learn a new syntax.\n\nMojo also has a bunch of technical advancements compared to Julia, simply\nbecause Mojo is newer and we’ve been able to learn from Julia (and from Swift,\nRust, C++ and many others that came before us). For example, Mojo takes a\ndifferent approach to memory ownership and memory management, it scales down to\nsmaller envelopes, and is designed with AI and MLIR-first principles (though\nMojo is not only for AI).\n\nThat said, we also believe there’s plenty of room for many languages and this\nisn’t an OR proposition. If you use and love Julia, that's great! We’d love for\nyou to try Mojo and if you find it useful, then that's great too.\n\n## Functionality\n\n### Where can I learn more about Mojo’s features?\n\nThe best place to start is the [Mojo Manual](/mojo/manual). And if you want to\nsee what features are coming in the future, take a look at [the\nroadmap](/mojo/roadmap.html).\n\n### What does it mean that Mojo is designed for MLIR?\n\n[MLIR](https://mlir.llvm.org/) provides a flexible infrastructure for building\ncompilers. It’s based upon layers of intermediate representations (IRs) that\nallow for progressive lowering of any code for any hardware, and it has been\nwidely adopted by the hardware accelerator industry since [its first\nrelease](https://blog.google/technology/ai/mlir-accelerating-ai-open-source-infrastructure/).\nAlthough you can use MLIR to create a flexible and powerful compiler for any\nprogramming language, Mojo is the world’s first language to be built from the\nground up with MLIR design principles. This means that Mojo not only offers\nhigh-performance compilation for heterogeneous hardware, but it also provides\ndirect programming support for the MLIR intermediate representations. For a\nsimple example of Mojo talking directly to MLIR, see our [low-level IR in Mojo\nnotebook](/mojo/notebooks/BoolMLIR.html).\n\n### Is Mojo only for AI or can it be used for other stuff?\n\nMojo is a general purpose programming language. We use Mojo at Modular to\ndevelop AI algorithms, but as we grow Mojo into a superset of Python, you can\nuse it for other things like HPC, data transformations, writing pre/post\nprocessing operations, and much more. For examples of how Mojo can be used for\nother general programming tasks, see our [Mojo\nexamples](https://github.com/modularml/mojo/tree/main/examples).\n\n### Is Mojo interpreted or compiled?\n\nMojo supports both just-in-time (JIT) and ahead-of-time (AOT) compilation. In\neither a REPL environment or Jupyter notebook, Mojo is JIT’d. However, for AI\ndeployment, it’s important that Mojo also supports AOT compilation instead of\nhaving to JIT compile everything. You can compile your Mojo programs using the\n[`mojo` CLI](/mojo/cli/).\n\n### How does Mojo compare to Triton Lang?\n\n[Triton Lang](https://triton-lang.org/main/index.html) is a specialized\nprogramming model for one type of accelerator, whereas Mojo is a more general\nlanguage that will support more architectures over time and includes a\ndebugger, a full tool suite, etc. For more about embedded domain-specific\nlanguages (EDSLs) like Triton, read the “Embedded DSLs in Python” section of\n[Why\nMojo](/mojo/why-mojo.html#embedded-dsls-in-python).\n\n### How does Mojo help with PyTorch and TensorFlow acceleration?\n\nMojo is a general purpose programming language, so it has no specific\nimplementations for ML training or serving, although we use Mojo as part of the\noverall Modular AI stack. The [Modular AI\nEngine](/engine), for example, supports deployment of PyTorch\nand TensorFlow models, while Mojo is the language we use to write the engine’s\nin-house kernels.\n\n### Does Mojo support distributed execution?\n\nNot alone. You will need to leverage the [Modular AI\nEngine](/engine) for that. Mojo is one component of the\nModular stack that makes it easier for you to author highly performant,\nportable kernels, but you’ll also need a runtime (or “OS”) that supports graph\nlevel transformations and heterogeneous compute.\n\n### Will Mojo support web deployment (such as Wasm or WebGPU)?\n\nWe haven’t prioritized this functionality yet, but there’s no reason Mojo can’t\nsupport it.\n\n### How do I convert Python programs or libraries to Mojo?\n\nMojo is still early and not yet a Python superset, so only simple programs can\nbe brought over as-is with no code changes. We will continue investing in this\nand build migration tools as the language matures.\n\n### What about interoperability with other languages like C/C++?\n\nYes, we want to enable developers to port code from languages other than Python\nto Mojo as well. We expect that due to Mojo’s similarity to the C/C++ type\nsystems, migrating code from C/C++ should work well and it’s in [our\nroadmap](/mojo/roadmap.html#cc-interop).\n\n### How does Mojo support hardware lowering?\n\nMojo leverages LLVM-level dialects for the hardware targets it supports, and it\nuses other MLIR-based code-generation backends where applicable. This also\nmeans that Mojo is easily extensible to any hardware backend. For more\ninformation, read about our vision for [pluggable\nhardware](https://www.modular.com/hardware).\n\n### How does Mojo autotuning work?\n\nFor details about what autotuning capabilities we support so far, check out\nthe Mojo Manual section on [metaprogramming](/mojo/manual/parameters/).\nBut stay tuned for more details!\n\n### Who writes the software to add more hardware support for Mojo?\n\nMojo provides all the language functionality necessary for anyone to extend\nhardware support. As such, we expect hardware vendors and community members\nwill contribute additional hardware support in the future. We’ll share more\ndetails about opening access to Mojo in the future, but in the meantime, you\ncan read more about our [hardware extensibility\nvision](https://www.modular.com/hardware).\n\n### How does Mojo provide a 35,000x speed-up over Python?\n\nModern CPUs are surprisingly complex and diverse, but Mojo enables\nsystems-level optimizations and flexibility that unlock the features of any\ndevice in a way that Python cannot. So the hardware matters for this sort of\nbenchmark, and for the Mandelbrot benchmarks we show in our [launch\nkeynote](https://www.youtube.com/watch?v=-3Kf2ZZU-dg&t=1543s), we ran them on\nan [AWS r7iz.metal-16xl](https://aws.amazon.com/ec2/instance-types/r7iz/)\nmachine.\n\nFor lots more information, check out our 3-part blog post series about\n[how Mojo gets a 35,000x speedup over\nPython](https://www.modular.com/blog/how-mojo-gets-a-35-000x-speedup-over-python-part-1).\n\nBy the way, all the kernels that power the [Modular AI\nEngine](/engine) are written in Mojo. We also compared our\nmatrix multiplication implementation to other state-of-the-art implementations\nthat are usually written in assembly. To see the results, see [our blog post\nabout unified matrix\nmultiplication](https://www.modular.com/blog/the-worlds-fastest-unified-matrix-multiplication).\n\n## Performance\n\n### Mojo’s matmul performance in the notebook doesn’t seem that great. What’s going on?\n\nThe [Mojo Matmul\nnotebook](https://github.com/modularml/mojo/blob/main/examples/notebooks/Matmul.ipynb)\nuses matrix multiplication to show off some Mojo features in a scenario that\nyou would never attempt in pure Python. So that implementation is like a “toy”\nmatmul implementation and it doesn’t measure up to the state of the art.\n\nPlus, if you're using the [Mojo Playground](https://playground.modular.com),\nthat VM environment is not set up for stable performance evaluation. Modular\nhas a separate matmul implementation written in Mojo (and used by the [Modular\nAI Engine](/engine)) that is not available with this release, but you can read\nabout it in [this blog\npost](https://www.modular.com/blog/the-worlds-fastest-unified-matrix-multiplication).\n\n### Are there any AI related performance benchmarks for Mojo?\n\nIt’s important to remember that Mojo is a general-purpose programming language,\nand any AI-related benchmarks will rely heavily upon other framework\ncomponents. For example, our in-house kernels for the [Modular AI\nEngine](/engine) are all written in Mojo and you can learn more\nabout our kernel performance in our [matrix multiplication blog\npost](https://www.modular.com/blog/the-worlds-fastest-unified-matrix-multiplication).\nFor details about our end-to-end model performance relative to the latest\nreleases of TensorFlow and PyTorch, check out our [performance\ndashboard](https://performance.modular.com).\n\n## Mojo SDK\n\n### How can I get access to the SDK?\n\nYou can [get the Mojo SDK here](https://developer.modular.com/download)!\n\n### Is the Mojo Playground still available?\n\nYes, you can [get access today](https://www.modular.com/get-started)\nto the Mojo Playground, a hosted set of Mojo-supported Jupyter notebooks.\n\n### What are the license terms for the SDK?\n\nPlease read the [Mojo SDK License Terms](https://www.modular.com/legal/mojo).\n\n### What does the Mojo SDK ship with?\n\nThe Mojo SDK includes the Mojo standard library and `mojo` command-line tool,\nwhich provides a REPL similar to the `python` command, along with `build`,\n`run`, `package`, `doc` and `format` commands. We've also published a [Mojo\nlanguage extension for VS\nCode](https://marketplace.visualstudio.com/items?itemName=modular-mojotools.vscode-mojo).\n\n### What operating systems are supported?\n\nCurrently, we support Ubuntu Linux 20.04/22.04 (64-bit x86) and macOS (Apple\nsilicon). Support for Windows will follow. Until then, you have several options:\n\n- Windows users can use\n  [Windows Subsystem for Linux version 2 (WSL 2)](https://learn.microsoft.com/en-us/windows/wsl/install)\n  running a supported Linix distribution.\n- Intel Mac users can use a [Docker](https://www.docker.com/) container running\n  a supported Linux distribution.\n- Users on any system can install the SDK on a remote machine running a\n  supported Linux distribution.\n\n### Is there IDE Integration?\n\nYes, we've published an official [Mojo language extension](https://marketplace.visualstudio.com/items?itemName=modular-mojotools.vscode-mojo)\nfor VS Code.\n\nThe extension supports various features including syntax highlighting, code\ncompletion, formatting, hover, etc. It works seamlessly with remote-ssh and dev\ncontainers to enable remote development in Mojo.\n\n### Does the Mojo SDK collect telemetry?\n\nYes, in combination with the Modular CLI tool, the Mojo SDK collects some basic\nsystem information and crash reports that enable us to identify, analyze, and\nprioritize Mojo issues.\n\nMojo is still in its early days, and this telemetry is crucial to help us\nquickly identify problems and improve Mojo. Without this telemetry, we would\nhave to rely on user-submitted bug reports, and in our decades of building\ndeveloper products, we know that most people don’t bother. Plus, a lot of\nproduct issues are not easily identified by users or quantifiable with\nindividual bug reports. The telemetry provides us the insights we need to build\nMojo into a premier developer product.\n\nOf course, if you don't want to share this information with us, you can easily\nopt-out of all telemetry, using the [`modular` CLI](/cli). To stop sharing\nsystem information, run this:\n\n`modular config-set telemetry.enabled=false`\n\nTo stop sharing crash reports, run this:\n\n`modular config-set crash_reporting.enabled=false`\n\n## Versioning & compatibility\n\n### What’s the Mojo versioning strategy?\n\nMojo is still in early development and not at a 1.0 version yet. It’s\nstill missing many foundational features, but please take a look at our\n[roadmap](/mojo/roadmap.html) to understand where things are headed. As such,\nthe language is evolving rapidly and source stability is not guaranteed.\n\n### How often will you be releasing new versions of Mojo?\n\nMojo development is moving fast and we are regularly releasing updates.\nPlease join the [Mojo Discord channel](http://discord.gg/modular) for\nnotifications and [sign up for our newsletter](https://www.modular.com/newsletter)\nfor more coarse-grain updates.\n\n## Mojo Playground {#mojo-playground}\n\n### What sort of computer is backing each instance in the Mojo Playground?\n\nThe Mojo Playground runs on a fleet of [AWS EC2\nC6i](https://aws.amazon.com/ec2/instance-types/c6i/) (c6i.8xlarge) instances\nthat is divided among active users. Due to the shared nature of the system, the\nnumber of vCPU cores provided to your session may vary. We guarantee 1 vCPU\ncore per session, but that may increase when the total number of active users is\nlow.\n\nEach user also has a dedicated volume in which you can save your own files that\npersist across sessions.\n\n## Open Source\n\n### Will Mojo be open-sourced?\n\nOver time we expect to open-source core parts of Mojo, such as the standard\nlibrary. However, Mojo is still young, so we will continue to incubate it within\nModular until more of its internal architecture is fleshed out. We don’t have an\nestablished plan for open-sourcing yet.\n\n### Why not develop Mojo in the open from the beginning?\n\nMojo is a big project and has several architectural differences from previous\nlanguages. We believe a tight-knit group of engineers with a common vision can\nmove faster than a community effort. This development approach is also\nwell-established from other projects that are now open source (such as LLVM,\nClang, Swift, MLIR, etc.).\n\n## Community\n\n### Where can I ask more questions or share feedback?\n\nIf you have questions about upcoming features or have suggestions\nfor the language, be sure you first read the [Mojo roadmap](roadmap.html), which\nprovides important information about our current priorities and links to\nour GitHub channels where you can report issues and discuss new features.\n\nTo get in touch with the Mojo team and developer community, use the resources\non our [Mojo community page](/mojo/community.html).\n\n### Can I share Mojo code from the Mojo Playground?\n\nYes! You’re welcome and encouraged to share your Mojo code any way you like.\nWe've added a feature in the Mojo Playground to make this easier, and you can\nlearn more in the Mojo Playground by opening the `help` directory in the file\nbrowser.\n\nHowever, the [Mojo SDK is also now available](/mojo/manual/get-started/), so\nyou can also share `.mojo` source files and `.ipynb` notebooks to run locally!\n"
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/index.md",
        "content": "---\ntitle: Mojo🔥\nsidebar_label: Overview\ndescription: A programming language that bridges the gap between AI research\n  and production, unlocking speed and usability.\nimage: /static/images/max-mojo-logo.png\nwebsite:\n  open-graph:\n    image: /static/images/mojo-social-card.png\n  twitter-card:\n    image: /static/images/mojo-social-card.png\ntoc: false\nanchor-sections: false\nlisting:\n  - id: docs\n    contents:\n      - manual/get-started/index.md\n      - why-mojo.md\n      - manual/basics.ipynb\n      - lib.md\n      - notebooks/index.md\n      - changelog.md\n      - cli/index.md\n      - ../cli/index.md\n      - roadmap.md\n      - faq.md\n      - community.md\n    type: grid\n    grid-columns: 2\n    sort: \"false\"\n    fields: [title, description]\n---\n\nMojo is a new programming language that bridges the gap between research and\nproduction by combining the best of Python syntax with systems programming and\nmetaprogramming. With Mojo, you can write portable code that's faster than C\nand seamlessly inter-op with the Python ecosystem.\n\nThe Mojo SDK is available for Linux and macOS! 🔥\n\n<p><a class=\"modLink\" href=\"https://developer.modular.com/download\">Get the Mojo\nSDK</a></p>\n\n<p><a class=\"modLink\" href=\"/mojo/community.html\">Join our community</a></p>\n\n:::{#docs}\n:::\n"
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/lib.md",
        "content": "---\ntitle: Mojo🔥 modules\nsidebar_label: Module index\ntoc: false\ndescription: A list of all modules in the Mojo standard library.\nwebsite:\n  open-graph:\n    image: /static/images/mojo-social-card.png\n  twitter-card:\n    image: /static/images/mojo-social-card.png\nlisting:\n  - id: stdlib\n    contents: \"stdlib/**\"\n    type: grid\n    page-size: 99\n---\n\nThese are all the modules in the Mojo standard library.\n\n:::{#stdlib}\n:::\n"
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/manual/basics.ipynb",
        "content": "--- cell type: markdown ---\nAt this point, you should have already set up the [Mojo\nSDK](/mojo/manual/get-started/) and run [\"Hello\nworld\"](/mojo/manual/get-started/hello-world.html). Now let's talk about how\nto write Mojo code.\n\nYou probably already know that Mojo is designed as a superset of Python. So if\nyou know Python, then a lot of Mojo code will look familiar. However, Mojo\nis—first and foremost—designed for high-performance systems programming, with\nfeatures like strong type checking, memory safety, next-generation compiler\ntechnologies, and more. As such, Mojo also has a lot in common with languages\nlike C++ and Rust.\n\nYet, we've designed Mojo to be flexible, so you can incrementally adopt\nsystems-programming features like strong type checking as you see fit—Mojo does\nnot *require* strong type checking.\n\nOn this page, we'll introduce the essential Mojo syntax, so you can start\ncoding quickly and understand other Mojo code you encounter. Subsequent\nsections in the Mojo Manual dive deeper into these topics, and links are\nprovided below as appropriate.\n\nLet's get started! 🔥\n\n:::{.callout-note}\n\n**Note:** Mojo is a young language and there are many [features still\nmissing](/mojo/roadmap.html). As such, Mojo is currently **not** meant for\nbeginners. Even this basics section assumes some programming experience.\nHowever, throughout the Mojo Manual, we try not assume experience with any\nparticular language.\n\n:::\n--- cell type: markdown ---\n## Functions\n--- cell type: markdown ---\nMojo functions can be declared with either `fn` or `def`.\n\nThe `fn` declaration enforces type-checking and memory-safe behaviors (Rust\nstyle), while `def` allows no type declarations and dynamic behaviors (Python\nstyle).\n\nFor example, this `def` function doesn't require declaration of argument types\nor the return type:\n--- cell type: code ---\ndef greet(name):\n    return \"Hello, \" + name + \"!\"\n--- cell type: markdown ---\nWhile the same thing as an `fn` function requires that you specify the\nargument type and the return type like this:\n--- cell type: code ---\nfn greet2(name: String) -> String:\n    return \"Hello, \" + name + \"!\"\n--- cell type: markdown ---\nBoth functions have the same result, but the `fn` function provides\ncompile-time checks to ensure the function receives and returns the correct\ntypes. Whereas, the `def` function might fail at runtime if it receives the\nwrong type.\n\nCurrently, Mojo doesn't support top-level code in a `.mojo` (or `.🔥`) file, so\nevery program must include a function named `main()` as the entry point.\nYou can declare it with either `def` or `fn`:\n--- cell type: code ---\ndef main():\n   print(\"Hello, world!\")\n--- cell type: markdown ---\n:::{.callout-note}\n\n**Note:** You don't need a `main()` function when coding in the\n[REPL](/mojo/manual/get-started/hello-world.html#run-code-in-the-repl) or in a\n[Jupyter\nnotebook](https://github.com/modularml/mojo/tree/main/examples/notebooks#readme).\n\n:::\n--- cell type: markdown ---\nFor more details, see the page about\n[functions](/mojo/manual/functions.html).\n--- cell type: markdown ---\n### Value ownership and argument mutability\n--- cell type: markdown ---\nIf you're wondering whether function arguments are passed by value or\npassed by reference, the short answer is: `def` functions receive arguments\n\"by value\" and `fn` functions receive arguments \"by immutable reference.\"\n\nThe longer short answer is that Mojo allows you to specify for each argument\nwhether it should be passed by value (as `owned`), or whether it should be\npassed by reference (as `borrowed` for an immutable reference, or as `inout`\nfor a mutable reference).\n\nThis feature is entwined with Mojo's value ownership model, which protects you\nfrom memory errors by ensuring that only one variable \"owns\" a value at any\ngiven time (but allowing other variables to receive a reference to it).\nOwnership then ensures that the value is destroyed when the lifetime of the\nowner ends (and there are no outstanding references).\n\nBut that's still a short answer, because going much further is a slippery slope\ninto complexity that is out of scope for this section. For the complete\nanswer, see the section about [value ownership](/mojo/manual/values/).\n\n--- cell type: markdown ---\n## Variables\n--- cell type: markdown ---\nYou can declare variables with `var` to create a mutable value, or with `let`\nto create an immutable value. Or, if your code is in a `def` function, you can\nomit both and the variable defaults to `var` (in an `fn` function, you must\ndeclare mutability).\n\nFor example:\n--- cell type: code ---\ndef do_math(x):\n    var y = x + x # y is mutable\n    y = y * y\n    let z = y + x # z is immutable\n    print(z)\n--- cell type: markdown ---\nOptionally, you can also declare a variable type like this:\n--- cell type: code ---\ndef add_one(x):\n    let y: Int = 1\n    print(x + y)\n--- cell type: markdown ---\nEven in an `fn` function, declaring the variable type is optional\n(only the argument and return types must be declared in `fn` functions).\n\nFor more details, see the page about\n[variables](/mojo/manual/variables.html).\n--- cell type: markdown ---\n## Structs\n--- cell type: markdown ---\nYou can build high-level abstractions for types (or \"objects\") as a `struct`. \n\nA `struct` in Mojo is similar to a `class` in Python: they both support\nmethods, fields, operator overloading, decorators for metaprogramming, and so\non. However, Mojo structs are completely static—they are bound at compile-time,\nso they do not allow dynamic dispatch or any runtime changes to the structure.\n(Mojo will also support Python-style classes in the future.)\n\nFor example, here's a basic struct:\n--- cell type: code ---\nstruct MyPair:\n    var first: Int\n    var second: Int\n\n    fn __init__(inout self, first: Int, second: Int):\n        self.first = first\n        self.second = second\n\n    fn dump(self):\n        print(self.first, self.second)\n--- cell type: markdown ---\nAnd here's how you can use it:\n--- cell type: code ---\nfn use_mypair():\n    let mine = MyPair(2, 4)\n    mine.dump()\n--- cell type: markdown ---\nFor more details, see the page about\n[structs](/mojo/manual/structs.html).\n--- cell type: markdown ---\n### Traits\n\nA trait is like a template of characteristics for a struct. If you want to\ncreate a struct with the characteristics defined in a trait, you must implement\neach characteristic (such as each method). Each characteristic in a trait is a\n\"requirement\" for the struct, and when your struct implements each requirement,\nit's said to \"conform\" to the trait.\n\nCurrently, the only characteristics that traits can define are method signatures. Also, traits\ncurrently cannot implement default behaviors for methods.\n\nUsing traits allows you to write generic functions that can accept any type\nthat conforms to a trait, rather than accept only specific types.\n\nFor example, here's how you can create a trait (notice the function is not\nimplemented):\n--- cell type: code ---\ntrait SomeTrait:\n    fn required_method(self, x: Int): ...\n--- cell type: markdown ---\nAnd here's how to create a struct that conforms to the trait:\n--- cell type: code ---\nstruct SomeStruct(SomeTrait):\n    fn required_method(self, x: Int):\n        print(\"hello traits\", x)\n--- cell type: markdown ---\nThen, here's a function that uses the trait as an argument type (instead of the\nstruct type):\n--- cell type: code ---\nfn fun_with_traits[T: SomeTrait](x: T):\n    x.required_method(42)\n\nfn use_trait_function():\n    var thing = SomeStruct()\n    fun_with_traits(thing)\n--- cell type: markdown ---\n:::{.callout-note}\n\nYou're probably wondering about the square brackets on `fun_with_traits()`.\nThese aren't function _arguments_ (which go in parentheses); these are function\n_parameters_, which we'll explain next.\n\n:::\n\nWithout traits, the `x` argument in `fun_with_traits()` would have to declare a\nspecific type that implements `required_method()`, such as `SomeStruct`\n(but then the function would accept only that type). With traits, the function\ncan accept any type for `x` as long as it conforms to (it \"implements\")\n`SomeTrait`. Thus, `fun_with_traits()` is known as a \"generic function\" because\nit accepts a _generalized_ type instead of a specific type.\n\nFor more details, see the page about [traits](/mojo/manual/traits.html).\n--- cell type: markdown ---\n## Parameterization\n--- cell type: markdown ---\nIn Mojo, a parameter is a compile-time variable that becomes a runtime\nconstant, and it's declared in square brackets on a function or struct.\nParameters allow for compile-time metaprogramming, which means you can generate\nor modify code at compile time.\n\nMany other languages use \"parameter\" and \"argument\" interchangeably, so be\naware that when we say things like \"parameter\" and \"parametric function,\" we're\ntalking about these compile-time parameters. Whereas, a function \"argument\" is\na runtime value that's declared in parentheses.\n\nParameterization is a complex topic that's covered in much more detail in the\n[Metaprogramming](/mojo/manual/parameters/) section, but we want to break the\nice just a little bit here. To get you started, let's look at a parametric\nfunction:\n--- cell type: code ---\nfn repeat[count: Int](msg: String):\n    for i in range(count):\n        print(msg)\n--- cell type: markdown ---\nThis function has one parameter of type `Int` and one argument of type\n`String`. To call the function, you need to specify both the parameter and the\nargument:\n--- cell type: code ---\nfn call_repeat():\n    repeat[3](\"Hello\")\n    # Prints \"Hello\" 3 times\n--- cell type: markdown ---\nBy specifying `count` as a parameter, the Mojo compiler is able to optimize the\nfunction because this value is guaranteed to not change at runtime. The\ncompiler effectively generates a unique version of the `repeat()` function that\nrepeats the message only 3 times. This makes the code more performant because\nthere's less to compute at runtime.\n\nSimilarly, you can define a struct with parameters, which effectively allows\nyou to define variants of that type at compile-time, depending on the parameter\nvalues.\n\nFor more detail on parameters, see the section on\n[Metaprogramming](/mojo/manual/parameters/).\n--- cell type: markdown ---\n## Blocks and statements\n--- cell type: markdown ---\nCode blocks such as functions, conditions, and loops are defined\nwith a colon followed by indented lines. For example:\n--- cell type: code ---\ndef loop():\n    for x in range(5):\n        if x % 2 == 0:\n            print(x)\n--- cell type: markdown ---\nYou can use any number of spaces or tabs for your indentation (we prefer 4\nspaces).\n\nAll code statements in Mojo end with a newline. However, statements can span\nmultiple lines if you indent the following lines. For example, this long string\nspans two lines:\n--- cell type: code ---\ndef print_line():\n    long_text = \"This is a long line of text that is a lot easier to read if\"\n                \" it is broken up across two lines instead of one long line.\"\n    print(long_text)\n--- cell type: markdown ---\nAnd you can chain function calls across lines:\n--- cell type: code ---\ndef print_hello():\n    text = String(\",\")\n          .join(\"Hello\", \" world!\")\n    print(text)\n--- cell type: markdown ---\n## Code comments\n\nYou can create a one-line comment using the hash `#` symbol:\n--- cell type: code ---\n# This is a comment. The Mojo compiler ignores this line.\n--- cell type: markdown ---\nComments may also follow some code:\n--- cell type: code ---\nlet message = \"Hello, World!\" # This is also a valid comment\n--- cell type: markdown ---\nYou can instead write longer comments across many lines using triple quotes:\n--- cell type: code ---\n\"\"\"\nThis is also a comment, but it's easier to write across\nmany lines, because each line doesn't need the # symbol.\n\"\"\"\n--- cell type: markdown ---\nTriple quotes is the preferred method of writing API documentation. For example:\n\n```mojo\nfn print(x: String):\n    \"\"\"Prints a string.\n\n    Args:\n        x: The string to print.\n    \"\"\"\n    ...\n```\n--- cell type: markdown ---\nDocumenting your code with these kinds of comments (known as \"docstrings\")\nis a topic we've yet to fully specify, but you can generate an API reference\nfrom docstrings using the [`mojo doc` command](/mojo/cli/doc.html).\n--- cell type: markdown ---\n## Python integration\n--- cell type: markdown ---\nMojo is not yet a full superset of Python, but we've built a mechanism to import\nPython modules as-is, so you can leverage existing Python code right away.\n\nFor example, here's how you can import and use NumPy (you must have Python\n`numpy` installed):\n--- cell type: code ---\nfrom python import Python\n\nfn use_numpy() raises:\n    let np = Python.import_module(\"numpy\")\n    let ar = np.arange(15).reshape(3, 5)\n    print(ar)\n    print(ar.shape)\n--- cell type: markdown ---\n:::{.callout-note}\n\n**Note:** You must have the Python module (such as `numpy`) installed already.\n\n:::\n--- cell type: markdown ---\nFor more details, see the page about\n[Python integration](/mojo/manual/python/).\n--- cell type: markdown ---\n## Next steps\n--- cell type: markdown ---\nHopefully this page has given you enough information to start experimenting with\nMojo, but this is only touching the surface of what's available in Mojo.\n\nIf you're in the mood to read more, continue through each page of this\nMojo Manual using the buttons at the bottom of each page—the next page from\nhere is [Functions](/mojo/manual/functions.html).\n\nOtherwise, here are some other resources to check out:\n\n- If you want to experiment with some code, clone [the Mojo\nrepo](https://github.com/modularml/mojo/) to try our code examples:\n\n  ```sh\n  git clone https://github.com/modularml/mojo.git\n  ```\n\n  In addition to several `.mojo` examples, the repo includes [Jupyter\n  notebooks](https://github.com/modularml/mojo/tree/main/examples/notebooks#readme)\n  that teach advanced Mojo features.\n\n- To see all the available Mojo APIs, check out the [Mojo standard library\n  reference](/mojo/lib.html)."
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/manual/decorators/always-inline.ipynb",
        "content": "--- cell type: markdown ---\nYou can add the `@always_inline` decorator on any function to make the Mojo\ncompiler \"inline\" the body of the function (copy it) directly into the body of\nthe calling function.\n\nThis eliminates potential performance costs associated with function calls\njumping to a new point in code. Normally, the compiler will do this\nautomatically where it can improve performance, but this decorator forces it to\ndo so. The downside is that it can increase the binary size by duplicating the\nfunction at every call site.\n\nFor example:\n--- cell type: code ---\n@always_inline\nfn add(a: Int, b: Int) -> Int:\n    return a + b\n\nprint(add(1, 2))\n--- cell type: markdown ---\nBecause `add()` is decorated with `@always_inline`, Mojo compiles this program\nwithout adding the `add()` function to the call stack, and it instead performs\nthe addition directly at the `print()` call site, as if it were written like\nthis:\n--- cell type: code ---\nprint(1 + 2)\n--- cell type: markdown ---\n## `@always_inline(\"nodebug\")`\n\nYou can also use the decorator with the `\"nodebug\"` argument, which has the\nsame effect to inline the function, but without debug information. This means\nyou can't step into the function when debugging, but it reduces the debug build\nbinary size."
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/manual/decorators/index.md",
        "content": "---\ntitle: Mojo decorators\nsidebar_label: Decorators\nsidebar_position: 1\ndescription: A reference of Mojo's built-in decorators\ntoc: false\ncss: /static/styles/page-navigation.css\nwebsite:\n  open-graph:\n    image: /static/images/mojo-social-card.png\n  twitter-card:\n    image: /static/images/mojo-social-card.png\nlisting:\n  - id: docs\n    contents:\n      - always-inline.ipynb\n      - noncapturing.ipynb\n      - nonmaterializable.ipynb\n      - parameter.ipynb\n      - register-passable.ipynb\n      - unroll.ipynb\n      - value.ipynb\n    type: grid\n    page-size: 99\n---\n\nA Mojo decorator is a [higher-order\nfunction](https://en.wikipedia.org/wiki/Higher-order_function) that modifies or\nextends the behavior of a struct, a function, or some other code. Instead of\nactually calling the higher-order function, you simply add the decorator (such\nas the `@value` decorator) above your code (such as a struct). The Mojo\ncompiler then uses the decorator function to modify your code at compile time.\n\nThe following pages describe each built-in decorator with examples.\n"
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/manual/decorators/noncapturing.ipynb",
        "content": "--- cell type: markdown ---\nYou can add the `@noncapturing` decorator on a nested function to tell Mojo\nthat the function does not capture variables from the outer scope.\n\nBy default, Mojo assumes that an inner function passed as an argument is a\ncapturing closure, so it requires that you declare the argument in the\nhigher-order function as `capturing`. If your function argument does _not_\ncapture outer variables, then you can declare it as `@noncapturing` and then\nyou don't need the `capturing` declaration on the higher-order function.\n\nTo clarify, let's look at a closure function that _does_ capture an outer-scope\nvariable:\n--- cell type: code ---\n# This higher-order function must declare the `func` argument as `capturing`\nfn outer(func: fn() capturing -> String):\n    print(func())\n\nfn call_it():\n    let a = \"Hello\"\n    # This is a capturing function, because it uses the outer-scope `a` variable\n    fn inner() -> String:\n        return a\n\n    outer(inner)\n\ncall_it()\n--- cell type: markdown ---\nHowever, if your inner function does not capture anything, then you can drop\nthe `capturing` declaration, but _only if_ you declare the inner function with\nthe `@noncapturing` decorator:\n--- cell type: code ---\nfn outer(func: fn() -> None):\n    func()\n\nfn call_it():\n    @noncapturing\n    fn inner():\n        print(\"Holla\")\n\n    outer(inner)\n\ncall_it()\n--- cell type: markdown ---\nIf you remove `@noncapturing` from this code, you'll get a compiler error."
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/manual/decorators/nonmaterializable.ipynb",
        "content": "--- cell type: markdown ---\nYou can add the `@nonmaterializable` decorator on a struct to declare that the\ntype can exist only in the parameter domain (it can be used for metaprogramming\nonly, and not as a runtime type). And, if an instance of this type does\ntransition into the runtime domain, this decorator declares what type it\nbecomes there.\n\nTo use it, declare your type with `@nonmaterializable(TargetType)`, where\n`TargetType` is the type that the object should convert to if it becomes a\nruntime value (you must declare the `TargetType`). For example, if a struct is\nmarked as `@nonmaterializable(Foo)`, then anywhere that it goes from a\nparameter value to a runtime value, it automatically converts into the `Foo`\ntype.\n\nFor example, the following `NmStruct` type can be used in the parameter domain,\nbut the `convertedToHasBool` instance of it is converted to `HasBool` when it's\nmaterialized as a runtime value:\n--- cell type: code ---\n@value\n@register_passable(\"trivial\")\nstruct HasBool:\n    var x: Bool\n\n    fn __init__(x: Bool) -> Self:\n        return Self {x: x}\n\n    @always_inline(\"nodebug\")\n    fn __init__(nms: NmStruct) -> Self:\n        return Self {x: True if (nms.x == 77) else False}\n\n@value\n@nonmaterializable(HasBool)\n@register_passable(\"trivial\")\nstruct NmStruct:\n    var x: Int\n\n    @always_inline(\"nodebug\")\n    fn __add__(self: Self, rhs: Self) -> Self:\n        return NmStruct(self.x + rhs.x)\n\nalias stillNmStruct = NmStruct(1) + NmStruct(2)\n# When materializing to a run-time variable, it is automatically converted,\n# even without a type annotation.\nlet convertedToHasBool = stillNmStruct\n--- cell type: markdown ---\n:::{.callout-note}\n\n**Note:** A non-materializable struct must have all of its methods annotated\nas `@always_inline`, and it must be computable in the parameter domain.\n\n:::\n--- cell type: markdown ---\n<CommentService />"
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/manual/decorators/parameter.ipynb",
        "content": "--- cell type: markdown ---\nYou can add the `@parameter` decorator on an `if` statement or on a nested\nfunction to run that code at compile time.\n\n## Parametric if statement\n\nYou can add `@parameter` to any `if` condition that's based on a valid\nparameter expression (it's an expression that evaluates at compile time). This\nensures that only the live branch of the `if` statement is compiled into the\nprogram, which can reduce your final binary size. For example:\n--- cell type: code ---\n@parameter\nif True:\n    print(\"this will be included in the binary\")\nelse:\n    print(\"this will be eliminated at compile time\")\n--- cell type: markdown ---\n## Parametric closure\n\nYou can add `@parameter` on a nested function to create a “parametric”\ncapturing closure. This means you to create a closure function that captures\nvalues from the outer scope (regardless of whether they are variables or\nparameters), and then use that closure as a parameter. For example:\n--- cell type: code ---\nfn use_closure[func: fn(Int) capturing -> Int](num: Int) -> Int:\n    return func(num)\n\nfn create_closure():\n    var x = 1\n\n    @parameter\n    fn add(i: Int) -> Int:\n        return x + i\n\n    let y = use_closure[add](2)\n    print(y)\n\ncreate_closure()\n--- cell type: markdown ---\nWithout the `@parameter` decorator, you'll get a compiler error that says you\n\"cannot use a dynamic value in call parameter\"—referring to the\n`use_closure[add](2)` call—because the `add()` closure would still be dynamic.\n--- cell type: markdown ---\n\n:::{.callout-caution}\n\nThis is an unsafe feature because we currently do not model the lifetimes of\ncapture-by-reference.\n\n:::\n--- cell type: markdown ---\n<CommentService />"
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/manual/decorators/register-passable.ipynb",
        "content": "--- cell type: markdown ---\nYou can add the `@register_passable` decorator on a struct to tell Mojo that\nthe type should be passed in machine registers (such as a CPU register; subject\nto the details of the underlying architecture). For tiny data types like an\ninteger or floating-point number, this is much more efficient than storing\nvalues in stack memory. This means the type is always passed by value and\ncannot be passed by reference.\n\nThe basic `@register_passable` decorator does not change the fundamental\nbehavior of a type: it still needs an `__init__()` and `__copyinit__()` method\nto be copyable (and it may have a `__del__()` method, if necessary). However,\nthese methods must be declared a little differently for a `@register_passable`\ntype: The `__init__` and `__copyinit__` methods are static and must\nreturn results by-value instead of using an `inout self` argument. For example:\n--- cell type: code ---\n@register_passable\nstruct Pair:\n    var a: Int\n    var b: Int\n\n    fn __init__(one: Int, two: Int) -> Self:\n        return Self{a: one, b: two}\n\n    fn __copyinit__(existing) -> Self:\n        return Self{a: existing.a, b: existing.b}\n\nfn test_pair():\n    let x = Pair(5, 10)\n    var y = x\n\n    print(y.a, y.b)\n    y.a = 10\n    y.b = 20\n    print(y.a, y.b)\n--- cell type: code ---\ntest_pair()\n--- cell type: markdown ---\nThis behavior is what we expect from `Pair`, with or without the decorator, but\nit's important to notice the signatures for `__init__()` and\n`__copyinit__()` don't have [the usual `inout self`\nargument](/mojo/manual/lifecycle/life.html#copy-constructor). The compiler\nwon't allow you to declare them that way; likewise, you can't use the\nstatic signatures above _without_ the `@register_passable` decorator.\n--- cell type: markdown ---\nYou should be aware of a few other observable effects:\n\n1. `@register_passable` types cannot hold instances of types\nthat are not also `@register_passable`.\n\n1. `@register_passable` types do not have a predictable identity,\nand so the `self` pointer is not stable/predictable (e.g. in hash tables). This\nis why the `__init__()` method above is implicitly static, and must return the\nconstructed instance by value.\n\n1. `@register_passable` arguments and result are exposed to C and C++ directly,\ninstead of being passed by-pointer.\n\n1. `@register_passable` types cannot have a [`__moveinit__()`\nconstructor](/mojo/manual/lifecycle/life.html#move-constructors), because\nvalues passed in a register cannot be passed by reference.\n\n--- cell type: markdown ---\n## `@register_passable(\"trivial\")`\n--- cell type: markdown ---\nMost types that use `@register_passable` are just \"bags of bits,\" which we call\n\"trivial\" types. These trivial types are simple and should be copied, moved,\nand destroyed without any custom constructors or a destructor. For these types,\nyou can add the `\"trivial\"` argument, and Mojo synthesizes all the lifecycle\nmethods as appropriate for a trivial register-passable type:\n--- cell type: code ---\n@register_passable(\"trivial\")\nstruct Pair:\n    var a: Int\n    var b: Int\n--- cell type: markdown ---\nThis is similar to the [`@value`](/mojo/manual/decorators/value.html) decorator,\nexcept when using `@register_passable(\"trivial\")` the only lifecycle method\nyou're allowed to define is the `__init__()` constructor (but you don't have\nto)—you _cannot_ define any copy or move constructors or a destructor.\n\nExamples of trivial types include:\n\n- Arithmetic types such as `Int`, `Bool`, `Float64` etc.\n- Pointers (the address value is trivial, not the data being pointed to).\n- Arrays of other trivial types, including SIMD.\n--- cell type: markdown ---\nFor more information about lifecycle methods (constructors and destructors)\nsee the section about [Value lifecycle](/mojo/manual/lifecycle/).\n--- cell type: markdown ---\n:::{.callout-note}\n\nTODO: This decorator is due for reconsideration. Lack of custom\ncopy/move/destroy logic and \"passability in a register\" are orthogonal concerns\nand should be split. This former logic should be subsumed into a more general\n[`@value(\"trivial\")`](/mojo/manual/decorators/value.html) decorator, which is\northogonal from `@register_passable`.\n\n:::\n--- cell type: markdown ---\n<CommentService />"
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/manual/decorators/unroll.ipynb",
        "content": "--- cell type: markdown ---\nYou can add the `@unroll` decorator on any loop (such as `for` and `while`) to\nmake the Mojo compiler [unroll the\nloop](https://en.wikipedia.org/wiki/Loop_unrolling), either fully or with a\ngiven unroll factor.\n\nFor example, the compiler will unroll all 10 iterations of the following loop\ninto 10 consecutive calls to `print()` (removing the `for` loop entirely):\n--- cell type: code ---\n@unroll\nfor i in range(10):\n    print(i)\n--- cell type: markdown ---\nThe decorator also accepts an \"unroll factor\" argument, which specifies how\nmany iterations to unroll at once. For example, the unroll above is equivalent\nto `@unroll(10)` because it unrolls all iterations of the loop. So if you pass\na number smaller than the loop bounds, the compiler creates multiple unrolls.\nFor example:\n--- cell type: code ---\n# Unroll every 2 iterations, leaving a loop with 5 iterations.\n@unroll(2)\nfor i in range (10):\n    print(i)\n--- cell type: markdown ---\nThe result is equivalent to this:\n--- cell type: code ---\nfor i in range(0, 10, 2):\n    print(i)\n    print(i+1)\n--- cell type: markdown ---\nHowever, the compiler can unroll a loop only when the following statements are\ntrue:\n\n- The loop's lower bound, upper bound, and induction step size are compile-time\nconstants (they do not vary at runtime). For example, in the above code\n`range(0, 10, 2)`, `0` is the lower bound, `10` is the upper bound, and `2`\nis the induction step size—these could instead be defined with variable names,\nbut the values cannot vary at runtime.\n\n- Likewise, there are no early exits in the loop that make the loop count\nvariable at runtime.\n--- cell type: markdown ---\n## Compared to `unroll()`\n--- cell type: markdown ---\nThe Mojo standard library also includes a function called\n[`unroll()`](/mojo/stdlib/algorithm/functional.html#unroll) that unrolls a\ngiven function that you want to call repeatedly, but has some important\ndifferences when compared to the `@unroll` decorator:\n\n- The `@unroll` decorator operates on loop expressions only, not on functions\n  like the `unroll()` function does.\n\n- The `@unroll` decorator determines how to unroll the loop based on the\n  induction variable (`i`), the value of which _is not_ known when compilation\n  begins. Whereas, the `unroll()` function calls upon your looping function\n  (`func`) with the `Int` loop index parameter that _is_ known at compile time.\n\n  This means two things:\n\n  - Within a loop using the `@unroll` decorator, the `i` induction variable is \n    still a runtime variable, so you _cannot_ use it as a parameter value (such\n    as for `SIMD[Int8, i]`). Whereas, within the `func` callback used with the\n    `unroll()` function, the `Int` loop index is known at compile time, so you\n    _can_ use it as a parameter value.\n\n  - The `unroll()` function unrolls at the beginning of compilation, which\n    might explode the program size that still needs to be compiled, depending\n    on the amount of code that's unrolled. Whereas, the `@unroll` decorator\n    performs unrolling later in the compilation, after the compiler is able to\n    evaluate the induction variable (`i`), which avoids early explosion of the\n    program size that still needs compilation.\n--- cell type: markdown ---\n"
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/manual/decorators/value.ipynb",
        "content": "--- cell type: markdown ---\nYou can add the `@value` decorator on a struct to generate boilerplate\nlifecycle methods, including the member-wise `__init__()` constructor,\n`__copyinit__()` copy constructor, and `__moveinit__()` move constructor.\n\nFor example, consider a simple struct like this:\n--- cell type: code ---\n@value\nstruct MyPet:\n    var name: String\n    var age: Int\n--- cell type: markdown ---\nMojo sees the `@value` decorator and notices that you don't have any constructors\nand it synthesizes them for you, the result being as if you had actually\nwritten this:\n--- cell type: code ---\nstruct MyPet:\n    var name: String\n    var age: Int\n\n    fn __init__(inout self, owned name: String, age: Int):\n        self.name = name^\n        self.age = age\n\n    fn __copyinit__(inout self, existing: Self):\n        self.name = existing.name\n        self.age = existing.age\n\n    fn __moveinit__(inout self, owned existing: Self):\n        self.name = existing.name^\n        self.age = existing.age\n--- cell type: markdown ---\nMojo synthesizes each lifecycle method only when it doesn't exist, so\nyou can use `@value` and still define your own versions to override the default\nbehavior. For example, it is fairly common to use the default member-wise and\nmove constructor, but create a custom copy constructor.\n--- cell type: markdown ---\nFor more information about these lifecycle methods, read\n[Life of a value](/mojo/manual/lifecycle/life.html)."
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/manual/functions.ipynb",
        "content": "--- cell type: markdown ---\nAs mentioned in [Language basics](/mojo/manual/basics/), Mojo supports two\ntypes of functions: `def` and `fn` functions. You can use either declaration\nwith any function, including the `main()` function, but they have different\ndefault behaviors, as described on this page.\n\nWe believe both `def` and `fn` have good use cases and don't consider either to\nbe better than the other. Deciding which to use is a matter personal taste as\nto which style best fits a given task.\n\nWe believe Mojo's flexibility in this regard is a superpower that allows you to\nwrite code in the manner that's best for your project.\n\n:::{.callout-note}\n\n**Note:** Functions declared inside a\n[`struct`](/mojo/manual/structs.html) are called \"methods,\" but they\nhave all the same qualities as \"functions\" described here.\n\n:::\n--- cell type: markdown ---\n## `def` functions\n\nThe `def` function provides the same dynamism and flexibility as a Python\n`def` function. For example, this function works the same in Python and Mojo:\n--- cell type: code ---\ndef greet(name):\n    greeting = \"Hello, \" + name + \"!\"\n    return greeting\n--- cell type: markdown ---\nIn Mojo, you also have the option to specify the argument type, return type,\nand variable mutability like this:\n--- cell type: code ---\ndef greet(name: String) -> String:\n    let greeting = \"Hello, \" + name + \"!\"\n    return greeting\n--- cell type: markdown ---\nThis way, the compiler ensures that `name` is a string, the return type is a\nstring, and the `greeting` variable cannot mutate.\n\nHere's everything to know about `def`:\n\n- Arguments don't require a declared type.\n\n  Undeclared arguments are actually passed as an `object`, which allows the\n  function to receive any type (Mojo infers the type at runtime).\n\n- Return types don't need to be declared and also default to `object`.\n\n- Arguments are mutable (usually passed by value, using the `owned` [argument\n  convention](/mojo/manual/values/ownership.html#argument-conventions)).\n\n  If an argument is an `object` type, it's received as a reference, following\n  [object reference\n  semantics](/mojo/manual/values/value-semantics.html#python-style-reference-semantics).\n  \n  If an argument is any other declared type, it's received as a value (using\n  the `owned` [argument\n  convention](/mojo/manual/values/ownership.html#argument-conventions)).\n\n- [Variables](/mojo/manual/variables.html) don't need to be declared as\n  mutable (`var`) or immutable (`let`); they default to mutable.\n--- cell type: markdown ---\n### The `object` type\n\nIf you don't declare the type for an argument or return value in a `def`, it\nbecomes an [`object`](/mojo/stdlib/builtin/object.html#object), which is unlike\nany other type in the standard library.\n\nThe `object` type allows for dynamic typing because it can actually represent\nany type in the Mojo standard library, and the actual type is inferred at\nruntime. (Actually, there's still more to do before it can represent all Mojo\ntypes.) This is great for compatibility with Python and all of the flexibility\nthat it provides with dynamic types. However, this lack of type enforcement can\nlead to runtime errors when a function receives or returns an unexpected type.\n\nFor compatibility with Python, `object` values are passed using [object\nreference\nsemantics](/mojo/manual/values/value-semantics.html#python-style-reference-semantics).\nAs such, the `object` type is not compatible with the [argument\nconventions](/mojo/manual/values/ownership.html#argument-conventions) that\nenforce value semantics. So, be careful if using `object` values alongside other\nstrongly-typed values—their behavior might be inconsistent because `object` is \nthe only type in the standard library that does not conform to [full value\nsemantics](/mojo/manual/values/value-semantics.html#full-value-semantics).\n--- cell type: markdown ---\n## `fn` functions\n\nThe `fn` function provides strict type checking and additional memory safety.\nIt basically forces you to write the optional things in `def`, and it ensures\nthat you don't accidentally mutate received arguments. For example, here's the\nsame function from above using `fn`:\n--- cell type: code ---\nfn greet(name: String) -> String:\n    let greeting = \"Hello, \" + name + \"!\"\n    return greeting\n--- cell type: markdown ---\nAs far as a function caller is concerned, `def` and `fn` functions are\ninterchangeable. That is, there's nothing a `def` can do that an `fn` can't\n(and vice versa). The difference is that, compared to a `def` function, an `fn`\nfunction is more strict on the inside.\n\nHere's everything to know about `fn`:\n\n- Arguments must specify a type (except for the\n  `self` argument in [struct methods](/mojo/manual/structs.html)).\n\n- Return values must specify a type, unless the function doesn't return a value.\n  \n  If you don't specify a return type, it defaults to `None` (meaning no return\n  value).\n\n- By default, arguments are received as an immutable reference (values are\n  read-only, using the `borrowed` [argument\n  convention](/mojo/manual/values/ownership.html#argument-conventions)).\n  \n  This prevents accidental mutations, and permits the use of non-copyable types\n  as arguments.\n  \n  If you want a local copy, you can simply assign the value to a local\n  variable. Or, you can get a mutable reference to the value by declaring the\n  `inout` [argument\n  convention](/mojo/manual/values/ownership.html#argument-conventions)).\n\n- [Variables](/mojo/manual/variables.html) must be declared as mutable\n  (`var`) or immutable (`let`).\n\n- If the function raises an exception, it must be explicitly declared with the\n  `raises` keyword. (A `def` function does not need to declare exceptions.)\n\nBy enforcing these type checks, using the `fn` function helps avoid a variety\nof runtime errors. It also improves performance compared to the dynamic typing\nin a `def` function, because there's no overhead processing required to figure\nout what data types to use at runtime—the types are fixed at compile time.\n--- cell type: markdown ---\n## Optional arguments\n\nAn optional argument is one that includes a default value, such as the `exp`\nargument here:\n--- cell type: code ---\nfn pow(base: Int, exp: Int = 2) -> Int:\n    return base ** exp\n\nfn use_defaults():\n    # Uses the default value for `exp`\n    let z = pow(3)\n    print(z)\n--- cell type: markdown ---\nHowever, you cannot define a default value for an argument that's declared as\n[`inout`](/mojo/manual/values/ownership.html#mutable-arguments-inout).\n--- cell type: markdown ---\n## Keyword arguments\n\nYou can also specify argument values using the argument names:\n--- cell type: code ---\nfn pow(base: Int, exp: Int = 2) -> Int:\n    return base ** exp\n\nfn use_keywords():\n    # Uses keyword argument names (with order reversed)\n    let z = pow(exp=3, base=2)\n    print(z)\n--- cell type: markdown ---\n::: {.callout-note}\n\n**Note:** Mojo currently includes only partial support for keyword arguments, so\nsome features such as keyword-only arguments and variadic keyword arguments (e.g. `**kwargs`)\nare not supported yet.\n\n:::\n--- cell type: markdown ---\n## Overloaded functions\n\nIf a `def` function does not specify argument types, then it can accept any\ndata type and decide how to handle each type internally. This is nice when you\nwant expressive APIs that just work by accepting arbitrary inputs, so there's\nusually no need to write function overloads for a `def` function.\n\nOn the other hand, all `fn` functions must specify argument types, so if you\nwant a function to work with different data types, you need to implement\nseparate versions of the function that each specify different argument types.\nThis is called \"overloading\" a function.\n\nFor example, here's an overloaded `add()` function that can accept either\n`Int` or `String` types:\n--- cell type: code ---\nfn add(x: Int, y: Int) -> Int:\n    return x + y\n\nfn add(x: String, y: String) -> String:\n    return x + y\n--- cell type: markdown ---\nIf you pass anything other than `Int` or `String` to the `add()` function,\nyou'll get a compiler error. That is, unless `Int` or `String` can implicitly\ncast the type into their own type. For example, `String` includes an overloaded\nversion of its constructor (`__init__()`) that accepts a `StringLiteral` value.\nThus, you can also pass a `StringLiteral` to a function that expects a `String`.\n\nWhen resolving an overloaded function call, the Mojo compiler tries each\ncandidate function and uses the one that works (if only one version works), or\nit picks the closest match (if it can determine a close match), or it reports\nthat the call is ambiguous (if it can’t figure out which one to pick).\n\nIf the compiler can't figure out which function to use, you can resolve the\nambiguity by explicitly casting your value to a supported argument type. For\nexample, in the following code, we want to call the overloaded `foo()`\nfunction, but both implementations accept an argument that supports [implicit\nconversion](/mojo/manual/variables.html#implicit-type-conversion) from\n`StringLiteral`. So, the call to `foo(string)` is ambiguous and creates a\ncompiler error. We can fix it by casting the value to the type we really want:\n--- cell type: code ---\n@value\nstruct MyString:\n    fn __init__(inout self, string: StringLiteral):\n        pass\n\nfn foo(name: String):\n    print(\"String\")\n\nfn foo(name: MyString):\n    print(\"MyString\")\n\nfn call_foo():\n    let string = \"Hello\"\n    # foo(string) # This call is ambiguous because two `foo` functions match it\n    foo(MyString(string))\n--- cell type: markdown ---\n\n\nWhen resolving an overloaded function, Mojo does not consider the return type\nor other contextual information at the call site—only the argument types affect\nwhich function is selected.\n\nOverloading also works with combinations of both `fn` and `def` functions.\nFor example, you could define multiple `fn` function overloads and then one\nor more `def` versions that don't specify all argument types, as a fallback.\n\n:::{.callout-note}\n\n**Note:** Although we haven't discussed\n[parameters](/mojo/manual/metaprogramming/parameters.html) yet (they're\ndifferent from function arguments, and used for compile-time metaprogramming),\nyou can also overload functions based on parameter types.\n\n:::"
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/manual/get-started/hello-world.md",
        "content": "---\ntitle: Hello, world!\nsidebar_position: 2\ndescription: Learn to run your first Mojo program.\ncss: /static/styles/page-navigation.css\nwebsite:\n  open-graph:\n    image: /static/images/mojo-social-card.png\n  twitter-card:\n    image: /static/images/mojo-social-card.png\n---\n\nAfter you [install Mojo](/mojo/manual/get-started/setup.html), you can use the\n[Mojo CLI](/mojo/cli/) to build and run Mojo programs. So let's create the\nclassic starter program that prints \"Hello, world!\", in three different ways.\n\n:::{.callout-note}\n\n**Before you start:**\n\nYou must set the `MODULAR_HOME` and `PATH` environment variables, as described\nin the output when you ran `modular install mojo`. For example, if you're using\nbash or zsh, add the following lines to your configuration file\n(`.bash_profile`, `.bashrc`, or `.zshrc`):\n\n```sh\nexport MODULAR_HOME=\"$HOME/.modular\"\nexport PATH=\"$MODULAR_HOME/pkg/packages.modular.com_mojo/bin:$PATH\"\n```\n\nThen source the file you just updated, for example:\n\n```sh\nsource ~/.bash_profile\n```\n\nIf you have other issues during install, check our [known\nissues](/mojo/roadmap.html#mojo-sdk-known-issues).\n\n:::\n\n## 1. Run code in the REPL\n\nFirst, let's use the Mojo\n[REPL](https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop),\nwhich allows you to write and run Mojo code in a command prompt:\n\n1. To start a REPL session, type `mojo` in your terminal and press\n   <kbd>Enter</kbd>.\n\n2. Then type `print(\"Hello, world!\")` and press <kbd>Enter</kbd> twice\n(a blank line is required to indicate the end of an expression).\n\nThat's it! For example:\n\n```text\n$ mojo\nWelcome to Mojo! 🔥\n\nExpressions are delimited by a blank line.\nType `:quit` to exit the REPL and `:mojo help` for further assistance.\n\n1> print(\"Hello, world!\")\n2.\nHello, world!\n```\n\nYou can write as much code as you want in the REPL. You can press\n<kbd>Enter</kbd> to start a new line and continue writing code, and when you\nwant Mojo to evaluate the code, press <kbd>Enter</kbd> twice. If there's\nsomething to print, Mojo prints it and then returns the prompt to you.\n\nThe REPL is primarily useful for short experiments because the code isn't\nsaved. So when you want to write a real program, you need to write the code in\na `.mojo` source file.\n\n## 2. Run a Mojo file\n\nNow let's write the code in a Mojo source file and run it with the\n[`mojo`](/mojo/cli/) command:\n\n1. Create a file named `hello.mojo` (or `hello.🔥`) and add the following code:\n\n   ```mojo\n   fn main():\n      print(\"Hello, world!\")\n   ```\n\n   That's all you need. Save the file and return to your terminal.\n\n2. Now run it with the `mojo` command:\n\n    ```sh\n    mojo hello.mojo\n    ```\n\n    It should immediately print the message:\n\n    ```text\n    Hello, world!\n    ```\n\nIf this didn't work for you, double-check your code looks exactly like the code\nin step 1, and make sure you correctly [installed\nMojo](/mojo/manual/get-started/#install-mojo).\n\n## 3. Build an executable binary\n\nFinally, let's build and run that same code as an executable:\n\n1. Create an executable file with the [`build`](/mojo/cli/build.html) command:\n\n    ```sh\n    mojo build hello.mojo\n    ```\n\n    The executable file uses the same name as the `.mojo` file, but\n    you can change that with the `-o` option.\n\n2. Then run the executable:\n\n    ```sh\n    ./hello\n    ```\n\nThis creates a statically compiled binary file, so it contains all the code and\nlibraries it needs to run.\n\n## Next steps\n\n- If you're new to Mojo, we suggest you continue to the next section about\n  [language basics](/mojo/manual/basics.html).\n\n- If you want to experiment with some code, clone [the Mojo\nrepo](https://github.com/modularml/mojo/) to try our code examples:\n\n  ```sh\n  git clone https://github.com/modularml/mojo.git\n  ```\n\n  In addition to several `.mojo` examples, the repo includes [Jupyter\n  notebooks](https://github.com/modularml/mojo/tree/main/examples/notebooks#readme)\n  that teach advanced Mojo features.\n\n- To see all the available Mojo APIs, check out the [Mojo standard library\n  reference](/mojo/lib.html).\n"
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/manual/get-started/index.md",
        "content": "---\ntitle: Get started with Mojo🔥\nsidebar_label: Get Mojo\nsidebar_position: 1\ndescription: Get the Mojo SDK or try coding in the Mojo Playground.\ncss: /static/styles/page-navigation.css\naliases:\n  - /mojo/get-started.html\n  - /mojo/manual/get-started/setup.html\nwebsite:\n  open-graph:\n    image: /static/images/mojo-social-card.png\n  twitter-card:\n    image: /static/images/mojo-social-card.png\n---\n\n\nMojo is now available for local development!\n\n<a href=\"https://developer.modular.com/download\"\nclass=\"button-purple download\">\n  Download Now\n</a>\n\nThe Mojo SDK is currently available for Ubuntu Linux systems and macOS\nsystems running on Apple silicon. Support for Windows is\ncoming soon. You can also develop from Windows or Intel macOS using a container\nor remote Linux system. Alternatively, you can also experiment with Mojo using\nour web-based [Mojo Playground](#develop-in-the-mojo-playground).\n\n## Get the Mojo SDK\n\nThe Mojo SDK includes everything you need for local Mojo development, including\nthe Mojo standard library and the [Mojo command-line interface](/mojo/cli/)\n(CLI). The Mojo CLI can start a REPL programming environment, compile and run\nMojo source files, format source files, and more.\n\nWe've also published a [Mojo extension for Visual Studio\nCode](https://marketplace.visualstudio.com/items?itemName=modular-mojotools.vscode-mojo)\nto provide a first-class developer experience with features like code\ncompletion, quick fixes, and hover help for Mojo APIs.\n\n![](/static/images/mojo/mojo-vscode.png)\n\n### System requirements\n\nTo use the Mojo SDK, you need a system that meets these specifications:\n\nLinux:\n\n- Ubuntu 20.04/22.04 LTS\n- x86-64 CPU (with [SSE4.2 or\n  newer](https://www.intel.com/content/www/us/en/support/articles/000057621/processors.html))\n  and a minimum of 8 GiB memory\n- Python 3.8 - 3.11\n- g++ or clang++ C++ compiler\n\nMac:\n\n- Apple silicon (M1 or M2 processor)\n- macOS Monterey (12) or later\n- Python 3.8 - 3.11\n- Command-line tools for Xcode, or Xcode\n\nSupport for Windows will be added in a future release.\n\n### Install Mojo\n\nThe Mojo SDK is available through the [Modular CLI tool](/cli/), which works\nlike a package manager to install and update Mojo. Use the following link to\nlog into the Modular developer console, where you can get the Modular CLI\nand then install Mojo:\n\n<a href=\"https://developer.modular.com/download\"\nclass=\"button-purple download\">\n  Download Now\n</a>\n\nThen get started with **[Hello, world!](hello-world.html)**\n\n:::{.callout-note}\n\n**Note:** To help us improve Mojo, we collect some basic system information and\ncrash reports. [Learn\nmore](/mojo/faq.html#does-the-mojo-sdk-collect-telemetry).\n\n:::\n\n### Update Mojo\n\nMojo is a work in progress and we will release regular updates to the\nMojo language and SDK tools. For information about each release, see the\n[Mojo changelog](/mojo/changelog.html).\n\nTo check your current Mojo version, use the `--version` option:\n\n```sh\nmojo --version\n```\n\nTo update to the latest Mojo version, use the `modular update` command:\n\n```sh\nmodular update mojo\n```\n\n### Update the Modular CLI\n\nWe may also release updates to the `modular` tool. Run the following\ncommands to update the CLI on your system.\n\nLinux:\n\n```sh\nsudo apt update\n\nsudo apt install modular\n```\n\nMac:\n\n```sh\nbrew update\n\nbrew upgrade modular\n```\n\n## Develop in the Mojo Playground\n\nInstead of downloading the Mojo SDK, you can also experiment with Mojo in our\nhosted Jupyter notebook environment called Mojo Playground. This is a hosted\nversion of [JupyterLab](https://jupyterlab.readthedocs.io/en/latest/) that's\nrunning our latest Mojo kernel.\n\nTo get access, just [log in to the Mojo Playground\nhere](https://playground.modular.com).\n\n![](/static/images/mojo/mojo-playground.png)\n\n### What to expect\n\n- The Mojo Playground is a [JupyterHub](https://jupyter.org/hub) environment in\nwhich you get a private volume associated with your account, so you can create\nyour own notebooks and they'll be saved across sessions.\n\n- We've included a handful of notebooks to show you Mojo basics and demonstrate\nits capabilities.\n\n- The number of vCPU cores available in your cloud instance may vary, so\nbaseline performance is not representative of the language. However, as you\nwill see in the included `Matmul.ipynb` notebook, Mojo's\nrelative performance over Python is significant.\n\n- There might be some bugs. Please [report issues and feedback on\nGitHub](https://github.com/modularml/mojo/issues/new/choose).\n\n### Tips\n\n- If you want to keep any edits to the included notebooks, **rename the notebook\nfiles**. These files will reset upon any server refresh or update, sorry. So if\nyou rename the files, your changes will be safe.\n\n- You can use `%%python` at the top of a notebook cell and write normal Python\ncode. Variables, functions, and imports defined in a Python cell are available\nfor access in subsequent Mojo cells.\n\n### Caveats\n\n- Did we mention that the included notebooks will lose your changes?<br/>\n**Rename the files if you want to save your changes.**\n\n- The Mojo environment does not have network access, so you cannot install\nother tools or Python packages. However, we've included a variety of popular\nPython packages, such as `numpy`, `pandas`, and `matplotlib` (see how to\n[import Python modules](/mojo/manual/python/)).\n\n- Redefining implicit variables is not supported (variables without a `let` or\n`var` in front). If you’d like to redefine a variable across notebook cells,\nyou must introduce the variable with  `var` (`let` variables are immutable).\n\n- You can’t use global variables inside functions—they’re only visible to\nother global variables.\n\n- For a longer list of things that don't work yet or have pain-points, see the\n[Mojo roadmap and sharp edges](/mojo/roadmap.html).\n"
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/manual/index.md",
        "content": "---\ntitle: \"Mojo Manual\"\nsidebar_label: Introduction\ndescription: A comprehensive guide to the Mojo programming language.\ncss: /static/styles/page-navigation.css\nwebsite:\n  open-graph:\n    image: /static/images/mojo-social-card.png\n  twitter-card:\n    image: /static/images/mojo-social-card.png\n---\n\nWelcome to the Mojo Manual, a complete guide to the Mojo🔥 programming language!\n\nMojo is designed to solve a variety of AI development challenges that no other\nlanguage can, because Mojo is the first programming language built from the\nground-up with [MLIR](https://mlir.llvm.org/) (a compiler infrastructure that's\nideal for heterogeneous hardware, from CPUs and GPUs, to various AI ASICs). We\nalso designed Mojo as a superset of the Python because we love Python and its\ncommunity, but we couldn't realistically enhance Python to do all the things we\nwanted. For a longer discussion on this topic, read [Why\nMojo](/mojo/why-mojo.html).\n\nBeware that Mojo is still a very young language, so there's a lot that hasn't\nbeen built yet. Likewise, there's a lot of documentation that hasn't been\nwritten yet. But we're excited to share Mojo with you and [get your\nfeedback](/mojo/community.html).\n\n## Contents\n\n- **Get started**\n\n  - [Get started with Mojo](get-started/index.html)\n  - [Hello World!](get-started/hello-world.html)\n\n- **Basics**\n\n  - [Language basics](basics.html)\n  - [Functions](functions.html)\n  - [Variables](variables.html)\n  - [Structs](structs.html)\n  - [Traits](traits.html)\n\n- **Value ownership**\n\n  - [Intro to value ownership](values/index.html)\n  - [Value semantics](values/value-semantics.html)\n  - [Ownership and borrowing](values/ownership.html)\n\n- **Value lifecycle**\n\n  - [Intro to value lifecycle](lifecycle/index.html)\n  - [Life of a value](lifecycle/life.html)\n  - [Death of a value](lifecycle/death.html)\n\n- **Metaprogramming**\n\n  - [Parameterization: compile-time metaprogramming](parameters/index.html)\n\n- **Python**\n\n  - [Python integration](python/index.html)\n  - [Python types](python/types.html)\n\n- **Decorators**\n\n  - [Mojo decorators](decorators/index.html)\n  - [@always_inline](decorators/always-inline.html)\n  - [@noncapturing](decorators/noncapturing.html)\n  - [@nonmaterializable](decorators/nonmaterializable.html)\n  - [@parameter](decorators/parameter.html)\n  - [@register_passable](decorators/register-passable.html)\n  - [@unroll](decorators/unroll.html)\n  - [@value](decorators/value.html)\n\n- [Modules and packages](packages.html)\n"
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/manual/lifecycle/death.ipynb",
        "content": "--- cell type: markdown ---\nAs soon as a value/object is no longer used, Mojo destroys it. Mojo does _not_\nwait until the end of a code block—or even until the end of an expression—to\ndestroy an unused value. It destroys values using an “as soon as possible”\n(ASAP) destruction policy that runs after every sub-expression. Even within an\nexpression like `a+b+c+d`, Mojo destroys the intermediate values as soon as\nthey're no longer needed.\n\nMojo uses static compiler analysis to find the point where a value is last used.\nThen, Mojo immediately ends the value's lifetime and calls the `__del__()`\ndestructor to perform any necessary cleanup for the type. However, you don't\nalways need to define the `__del__()` destructor. If your struct is\ncomposed of fields that are all trivial or destructible types, Mojo\nautomatically destroys each one when it is last used. (All types defined in the\nMojo standard library are destructible, except for pointers in the\n[`unsafe`](/mojo/stdlib/memory/unsafe.html) module.)\n\nFor example, notice when the `__del__()` destructor is called for each instance\nof `MyPet`:\n--- cell type: code ---\n@value\nstruct MyPet:\n    var name: String\n    var age: Int\n\n    fn __del__(owned self):\n        print(\"Destruct\", self.name)\n\nfn pets():\n    var a = MyPet(\"Loki\", 4)\n    let b = MyPet(\"Sylvie\", 2)\n    print(a.name)\n    # a.__del__() runs here for \"Loki\"\n\n    a = MyPet(\"Charlie\", 8)\n    # a.__del__() runs immediately because \"Charlie\" is never used\n\n    print(b.name)\n    # b.__del__() runs here\n\npets()\n--- cell type: markdown ---\nNotice that each initialization of a value is matched with a call to the\ndestructor, and `a` is actually destroyed multiple times—once for each time it receives\na new value.\n\nAlso notice that this `__del__()` implementation doesn't actually do\nanything—Mojo can destroy an instance of `MyPet` without any special\ninstructions because it knows how to destruct `String` and `Int` types.\n--- cell type: markdown ---\n### Benefits of ASAP destruction\n\nSimilar to other languages, Mojo follows the principle that objects/values\nacquire resources in a constructor (`__init__()`) and release resources in a\ndestructor (`__del__()`). However, Mojo's ASAP destruction has some advantages\nover scope-based destruction (such as the C++ [RAII\npattern](https://en.cppreference.com/w/cpp/language/raii), which waits until\nthe end of the code scope to destroy values):\n\n- Destroying values immediately at last-use composes nicely with the \"move\"\n  optimization, which transforms a \"copy+del\" pair into a \"move\" operation.\n\n- Destroying values at end-of-scope in C++ is problematic for some common\n  patterns like tail recursion, because the destructor call happens after the\n  tail call. This can be a significant performance and memory problem for\n  certain functional programming patterns, which is not a problem in Mojo,\n  because the destructor call always happens before the tail call.\n\nAdditionally, Mojo's ASAP destruction works great within Python-style `def`\nfunctions. That's because Python doesn’t really provide scopes beyond a\nfunction scope, so the Python garbage collector cleans up resources more often\nthan a scope-based destruction policy would. However, Mojo does not use a\ngarbage collector, so the ASAP destruction policy provides destruction\nguarantees that are even more fine-grained than in Python.\n\nThe Mojo destruction policy is more similar to how Rust and Swift work, because\nthey both have strong value ownership tracking and provide memory safety. One\ndifference is that Rust and Swift require the use of a [dynamic \"drop\nflag\"](https://doc.rust-lang.org/nomicon/drop-flags.html)—they maintain hidden\nshadow variables to keep track of the state of your values to provide safety.\nThese are often optimized away, but the Mojo approach eliminates this overhead\nentirely, making the generated code faster and avoiding ambiguity.\n--- cell type: markdown ---\n## Destructor\n\nAny struct can have a destructor (the `__del__()` method), which Mojo calls when\nthe value's lifetime ends (typically the point at which the value is last used).\n\nYou should define the `__del__()` method to perform any kind of cleanup the\ntype requires. Usually, that includes freeing memory for any fields that are\nnot trivial or destructible, and closing any long-lived resources such as file\nhandles.\n\nHowever, any struct that is just a collection of other destructible types does\nnot need to implement the destructor, because Mojo destroys each of those\nfields automatically. All types in the Mojo standard library (such as\n[`Int`](/mojo/stdlib/builtin/int.html#int),\n[`String`](/mojo/stdlib/builtin/string.html#string), and\n[`SIMD`](/mojo/stdlib/builtin/simd.html#simd)) are either trivial or\ndestructible, except for pointers from the\n[`unsafe`](/mojo/stdlib/memory/unsafe.html) module.\n\nFor example, consider this simple struct:\n--- cell type: code ---\nstruct MyPet:\n    var name: String\n    var age: Int\n\n    fn __init__(inout self, name: String, age: Int):\n        self.name = name\n        self.age = age\n--- cell type: markdown ---\nThere's no need to define the `__del__()` destructor for this, because `String`\nand `Int` are destructible, and Mojo destroys them as soon as they're no longer\nused. `Int` is actually a little different because it is a [trivial\ntype](/mojo/manual/lifecycle/life.html#trivial-types) that's usually stored in\nCPU registers, so it doesn't exactly follow the same lifecycle\nevents—nevertheless, Mojo needs no help destroying the value.\n\nWhereas, the following struct must define the `__del__()` method to free the\nmemory allocated for its [`Pointer`](/mojo/stdlib/memory/unsafe.html#pointer):\n--- cell type: code ---\nstruct HeapArray:\n    var data: Pointer[Int]\n    var size: Int\n\n    fn __init__(inout self, size: Int, val: Int):\n        self.size = size\n        self.data = Pointer[Int].alloc(self.size)\n        for i in range(self.size):\n            self.data.store(i, val)\n\n    fn __del__(owned self):\n        self.data.free()\n--- cell type: markdown ---\nIt's important to notice that the `__del__()` method is an \"extra\" cleanup\nevent, and your implementation does not override any default destruction\nbehaviors. For example, Mojo still destroys all the fields in `MyPet` even\nif you implement `__del__()` to do nothing:\n--- cell type: code ---\nstruct MyPet:\n    var name: String\n    var age: Int\n\n    fn __init__(inout self, name: String, age: Int):\n        self.name = name\n        self.age = age\n\n    fn __del__(owned self):\n        # Mojo destroys all the fields when they're last used\n        pass\n--- cell type: markdown ---\nHowever, the `self` value inside the `__del__()` destructor is still whole (so\nall fields are still usable) until the destructor returns, as we'll discuss\nmore in the following section.\n--- cell type: markdown ---\n## Field lifetimes\n\nIn addition to tracking the lifetime of all objects in a program, Mojo also\ntracks each field of a structure independently. That is, Mojo keeps track of\nwhether a \"whole object\" is fully or partially initialized/destroyed, and it\ndestroys each field independently with its ASAP destruction policy.\n\nFor example, consider this code that changes the value of a field:\n--- cell type: code ---\n@value\nstruct MyPet:\n    var name: String\n    var age: Int\n\nfn use_two_strings():\n    var pet = MyPet(\"Po\", 8)\n    print(pet.name)\n    # pet.name.__del__() runs here, because this instance is\n    # no longer used; it's replaced below\n\n    pet.name = String(\"Lola\") # Overwrite pet.name\n    print(pet.name)\n    # pet.__del__() runs here\n--- cell type: markdown ---\nThe `pet.name` field is destroyed after the first `print()`, because Mojo knows\nthat it will be overwritten below. You can also see this behavior when using the\ntransfer operator:\n--- cell type: code ---\nfn consume(owned arg: String):\n    pass\n\nfn use(arg: MyPet):\n    print(arg.name)\n\nfn consume_and_use():\n    var pet = MyPet(\"Selma\", 5)\n    consume(pet.name^)\n    # pet.name.__moveinit__() runs here, which destroys pet.name\n    # Now pet is only partially initialized\n\n    # use(pet)  # This fails because pet.name is uninitialized\n\n    pet.name = String(\"Jasper\")  # All together now\n    use(pet)                     # This is ok\n    # pet.__del__() runs here (and only if the object is whole)\n--- cell type: markdown ---\nNotice that the code transfers ownership of the `name` field to `consume()`.\nFor a period of time after that, the `name` field is uninitialized.\nThen `name` is reinitialized before it is passed to the `use()` function. If you\ntry calling `use()` before `name` is re-initialized, Mojo rejects the code\nwith an uninitialized field error.\n\nAlso, if you don't re-initialize the name by the end of the `pet` lifetime, the\ncompiler complains because it's unable to destroy a partially initialized\nobject.\n\nMojo's policy here is powerful and intentionally straight-forward: fields can\nbe temporarily transferred, but the \"whole object\" must be constructed with the\naggregate type’s initializer and destroyed with the aggregate destructor. This\nmeans it's impossible to create an object by initializing only its fields, and\nit's likewise impossible to destroy an object by destroying only its fields.\n--- cell type: markdown ---\n### Field lifetimes during destruct and move\n\nThe consuming-move constructor and destructor face an interesting situation\nwith field lifetimes, because, unlike other lifecycle methods, they both take\nan instance of their own type as an `owned` argument, which is about to be\ndestroyed. You don't really need to worry about this detail when implementing\nthese methods, but it might help you better understand field lifetimes.\n\nJust to recap, the consuming-move constructor and destructor method signatures\nlook like this:\n\n```mojo\nstruct TwoStrings:\n    fn __moveinit__(inout self, owned existing: Self):\n        # Initializes a new `self` by consuming the contents of `existing`\n    fn __del__(owned self):\n        # Destroys all resources in `self`\n```\n\n::: {.callout-note}\n\n**Note:** There are two kinds of \"self\" here: capitalized `Self` is an alias\nfor the current type name (used as a type specifier for the `existing`\nargument), whereas lowercase `self` is the argument name for the\nimplicitly-passed reference to the current instance (also called \"this\" in\nother languages, and also implicitly a `Self` type).\n\n:::\n\nBoth of these methods face an interesting but obscure problem: they both must\ndismantle the `existing`/`self` value that's `owned`. That is, `__moveinit__()`\nimplicitly destroys sub-elements of `existing` in order to transfer ownership\nto a new instance (read more about the [consuming-move\nconstructor](/mojo/manual/lifecycle/life.html#consuming-move-constructor)),\nwhile `__del__()` implements the deletion logic for its `self`. As such, they\nboth need to own and transform elements of the `owned` value, and they\ndefinitely don’t want the original `owned` value's destructor to also run—that\ncould result in a double-free error, and in the case of the `__del__()` method,\nit would become an infinite loop.\n\nTo solve this problem, Mojo handles these two methods specially by assuming\nthat their whole values are destroyed upon reaching any return from the method.\nThis means that the whole object may be used as usual, up until the field\nvalues are transferred or the method returns.\n\nFor example, the following code works as you would expect (within the\ndestructor, we can still pass ownership of a field value to another function,\nand there's no infinite loop to destroy `self`):\n--- cell type: code ---\nfn consume(owned str: String):\n    print('Consumed', str)\n\nstruct TwoStrings:\n    var str1: String\n    var str2: String\n\n    fn __init__(inout self, one: String):\n        self.str1 = one\n        self.str2 = String(\"bar\")\n\n    fn __moveinit__(inout self, owned existing: Self):\n        self.str1 = existing.str1\n        self.str2 = existing.str2\n\n    fn __del__(owned self):\n        self.dump() # Self is still whole here\n        # Mojo calls self.str2.__del__() since str2 isn't used anymore\n\n        consume(self.str1^)\n        # self.str1 has been transferred so it is also destroyed now;\n        # `self.__del__()` is not called (avoiding an infinite loop).\n\n    fn dump(inout self):\n        print('str1:', self.str1)\n        print('str2:', self.str2)\n\nfn use_two_strings():\n    let two_strings = TwoStrings(\"foo\")\n--- cell type: markdown ---\n## Explicit lifetimes\n\nSo far, we've described how Mojo destroys a value at the point it's last used,\nand this works great in almost all situations. However, there are very rare\nsituations in which Mojo simply cannot predict this correctly and will destroy\na value that is still referenced through some other means.\n\nFor instance, perhaps you're building a type with a field that carries a pointer\nto another field. The Mojo compiler won't be able to reason about the pointer,\nso it might destroy a field (`obj1`) when that field technically no longer\nused, even though another field (`obj2`) still holds a pointer to part of it.\nSo, you might need to keep `obj1` alive until you can execute some special\nlogic in the destructor or move initializer.\n\nYou can force Mojo to keep a value alive up to a certain point by assigning the\nvalue to the `_` \"discard\" pattern at the point where it's okay to destroy it.\nFor example:\n\n```mojo\nfn __del__(owned self):\n    self.dump() # Self is still whole here\n\n    consume(self.obj2^)\n    _ = self.obj1\n    # Mojo keeps `obj1` alive until here, after its \"last use\"\n```\n\nIn this case, if `consume()` refers to some value in `obj1` somehow, this\nensures that Mojo does not destroy `obj1` until after the call to `consume()`,\nbecause assignment to the discard variable `_` is actually the last use.\n\nFor other situations, you can also scope the lifetime of a value using the\nPython-style [`with`\nstatement](https://docs.python.org/3/reference/compound_stmts.html#the-with-statement).\nThat is, for any value defined at the entrance to a `with` statement, Mojo will\nkeep that value alive until the end of the `with` statement. For example:\n\n```mojo\nwith open(\"my_file.txt\", \"r\") as file:\n    print(file.read())\n\n    # Other stuff happens here (whether using `file` or not)...\n    foo()\n    # `file` is alive up to the end of the `with` statement.\n\n# `file` is destroyed when the statement ends.\nbar()\n```"
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/manual/lifecycle/index.ipynb",
        "content": "--- cell type: markdown ---\nSo far, we've explained how Mojo allows you to build high-performance code that\nis memory safe _without_ manually managing memory, using Mojo's [ownership\nmodel](/mojo/manual/values/ownership.html). However, Mojo is designed for\n[systems programming](https://en.wikipedia.org/wiki/Systems_programming), which\noften requires manual memory management for custom data types. So, Mojo lets\nyou do that as you see fit. To be clear, Mojo has no reference counter and no\ngarbage collector.\n\nMojo also has no built-in data types with special privileges. All data types\nin the standard library (such as [`Bool`](/mojo/stdlib/builtin/bool.html#bool),\n[`Int`](/mojo/stdlib/builtin/int.html#int), and\n[`String`](/mojo/stdlib/builtin/string.html#string)) are implemented as\n[structs](/mojo/manual/structs.html). You can actually write your own\nreplacements for these types by using low-level primitives provided by\n[MLIR dialects](/mojo/notebooks/BoolMLIR.html).\n\nWhat's great about the Mojo language is that it provides you these low-level\ntools for systems programming, but within a framework that helps you build\nthings that are safe and easy to use from higher-level programs. That is, you\ncan get under the hood and write all the \"unsafe\" code you want, but as long as\nyou do so in accordance to Mojo's [value\nsemantics](/mojo/manual/values/value-semantics), the programmer instantiating\nyour type/object doesn't need to think about memory management at all, and the\nbehavior will be safe and predictable, thanks to [value\nownership](/mojo/manual/values/ownership.html).\n\nIn summary, it's the responsibility of the type author to manage the memory and\nresources for each value type, by implementing specific lifecycle methods, such\nas the constructor, copy construct, move constructor, and destructor, as\nnecessary. Mojo doesn't create any of these by default.\n\nIn the following pages, we'll explain exactly how to define these lifecycle\nmethods in accordance to value semantics so your types play nicely with value\nownership.\n--- cell type: markdown ---\n## Lifecycles and lifetimes\n\nFirst, let's clarify some terminology:\n\n- The \"lifecycle\" of a value is defined by various [dunder\nmethods](/mojo/manual/structs.html#special-methods) in a struct.\nEach lifecycle event is handled by a different method,\nsuch as the constructor (`__init__()`), the destructor (`__del__()`), the copy\nconstructor (`__copyinit__()`), and the move constructor (`__moveinit__()`).\nAll values that are declared with the same type have the same lifecycle.\n\n- The \"lifetime\" of a value is defined by the span of time during program\nexecution in which each value is considered valid. The life of a value begins\nwhen it is initialized and ends when it is destroyed, which generally (but not\nalways) spans from `__init__()` to `__del__()`. No two values have the exact\nsame lifetime, because every value is created and destroyed at a different\npoint in time (even if the difference is imperceivable).\n\nThe life of a value in Mojo begins when a variable is initialized and continues\nup until the value is last used, at which point Mojo destroys it. Mojo destroys\nevery value/object as soon as it's no longer used, using an “as soon as\npossible” (ASAP) destruction policy that runs after every sub-expression.\n\nAs you might imagine, keeping track of a value's lifetime can be difficult if a\nvalue is shared across functions many times during the life of a program.\nHowever, Mojo makes this predictable partly through its [value\nsemantics](/mojo/manual/values/value-semantics.html) and [value\nownership](/mojo/manual/values/ownership.html) (both prerequisite readings for\nthe following sections). The final piece of the puzzle for lifetime management\nis the value lifecycle: every value (defined in a struct) needs to implement\nkey lifecycle methods that define how a value is created and destroyed."
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/manual/lifecycle/life.ipynb",
        "content": "--- cell type: markdown ---\nThe life of a value in Mojo begins when a variable is initialized and continues\nup until the value is last used, at which point Mojo destroys it. This page\ndescribes how every value in Mojo is created, copied, and moved. (The next\npage describes [how values are\ndestroyed](/mojo/manual/lifecycle/death.html).)\n\nAll data types in Mojo—including basic types in the standard library such as\n[`Bool`](/mojo/stdlib/builtin/bool.html#bool),\n[`Int`](/mojo/stdlib/builtin/int.html#int), and\n[`String`](/mojo/stdlib/builtin/string.html#string), up to complex types such\nas [`SIMD`](/mojo/stdlib/builtin/simd.html#simd) and\n[`object`](/mojo/stdlib/builtin/object.html#object)—are all defined as a\n[struct](/mojo/manual/structs.html). This means the creation and\ndestruction of any piece of data follows the same lifecycle rules, and you can\ndefine your own data types that work exactly the same way.\n\nMojo structs don't get any default lifecycle methods, such as a\nconstructor, copy constructor, or move constructor. That means you can create\na struct without a constructor, but then you can't instantiate it, and it\nwould be useful only as a sort of namespace for static methods. For example:\n--- cell type: code ---\nstruct NoInstances:\n    var state: Int\n\n    @staticmethod\n    fn print_hello():\n        print(\"Hello world!\")\n--- cell type: markdown ---\nWithout a constructor, this cannot be instantiated, so it has no lifecycle. The\n`state` field is also useless because it cannot be initialized (Mojo structs do\nnot support default field values—you must initialize them in a constructor).\n\nSo the only thing you can do is call on the static method:\n--- cell type: code ---\nNoInstances.print_hello()\n--- cell type: markdown ---\n## Constructor\n\nTo create an instance of a Mojo type, it needs the `__init__()` constructor\nmethod. The main responsibility of the constructor is to initialize all fields.\nFor example:\n--- cell type: code ---\nstruct MyPet:\n    var name: String\n    var age: Int\n\n    fn __init__(inout self, name: String, age: Int):\n        self.name = name\n        self.age = age\n--- cell type: markdown ---\nNow we can create an instance:\n--- cell type: code ---\nlet mine = MyPet(\"Loki\", 4)\n--- cell type: markdown ---\nAn instance of `MyPet` can also be\n[borrowed](/mojo/manual/values/ownership.html#immutable-arguments-borrowed)\nand destroyed, but it currently can't be copied or moved.\n\nWe believe this is a good default starting point, because there are no built-in\nlifecycle events and no surprise behaviors. You—the type author—must\nexplicitly decide whether and how the type can be copied or moved, by\nimplementing the copy and move constructors.\n\n:::{.callout-note}\n\n**Note:** Mojo does not require a destructor to destroy an object. As long as\nall fields in the struct are destructible (every type in the standard library\nis destructible, except for\n[pointers](/mojo/stdlib/memory/unsafe.html)), then Mojo knows how to destroy\nthe type when its lifetime ends. We'll discuss that more in [Death of a\nvalue](/mojo/manual/lifecycle/death.html).\n\n:::\n--- cell type: markdown ---\n### Overloading the constructor\n\nLike any other function/method, you can\n[overload](/mojo/manual/functions.html#overloaded-functions) the\n`__init__()` constructor to initialize the object with different arguments. For\nexample, you might want a default constructor that sets some default values and\ntakes no arguments, and then additional constructors that accept more arguments.\n\nJust beware that, in order to modify any fields, each constructor must\ndeclare the `self` argument with the [`inout`\nconvention](/mojo/manual/values/ownership.html#mutable-arguments-inout). If you\nwant to call one constructor from another, you simply call upon that\nconstructor as you would externally (you don't need to pass `self`).\n\nFor example, here's how you can delegate work from an overloaded constructor:\n--- cell type: code ---\nstruct MyPet:\n    var name: String\n    var age: Int\n\n    fn __init__(inout self):\n        self.name = \"\"\n        self.age = 0\n\n    fn __init__(inout self, name: String):\n        self = MyPet()\n        self.name = name\n--- cell type: markdown ---\n### Field initialization\n\nNotice in the previous example that, by the end of each constructor, all fields\nmust be initialized. That's the only requirement in the constructor.\n\nIn fact, the `__init__()` constructor is smart enough to treat the `self`\nobject as fully initialized even before the constructor is finished, as long\nas all fields are initialized. For example, this constructor can pass around\n`self` as soon as all fields are initialized:\n--- cell type: code ---\nfn use(arg: MyPet):\n    pass\n\nstruct MyPet:\n    var name: String\n    var age: Int\n\n    fn __init__(inout self, name: String, age: Int, cond: Bool):\n        self.name = name\n        if cond:\n            self.age = age\n            use(self)  # Safe to use immediately!\n\n        self.age = age\n        use(self)  # Safe to use immediately!\n--- cell type: markdown ---\n## Copy constructor\n\nBecause Mojo is built upon [value\nsemantics](/mojo/manual/values/value-semantics.html), Mojo makes a copy of any\nvalue given to the assignment operator (`=`), by default. Also recall that\narguments sent to a [`def`\nfunction](/mojo/manual/functions.html#def-functions) are copied by\ndefault. However, copying a value is possible only if the type implements the\n`__copyinit__()` method.\n\nFor example, the `MyPet` type above does not have a copy constructor,\nso this code fails to compile:\n\n```mojo\nlet mine = MyPet(\"Loki\", 4)\nlet yours = mine  # This requires a copy, but MyPet has no copy constructor\n```\n\nTo make it work, we need to add the copy constructor, like\nthis:\n--- cell type: code ---\nstruct MyPet:\n    var name: String\n    var age: Int\n\n    fn __init__(inout self, name: String, age: Int):\n        self.name = name\n        self.age = age\n\n    fn __copyinit__(inout self, existing: Self):\n        self.name = existing.name\n        self.age = existing.age\n--- cell type: markdown ---\n:::{.callout-note}\n\n**Note:** `Self` (capital \"S\") is an alias for the current type name\n(`MyPet`, in this example). Using this alias is a best practice to avoid any\nmistakes when referring to the current struct name.\n\nAlso, notice that the `existing` argument in `__copyinit__()` is immutable\nbecause the default [argument\nconvention](/mojo/manual/values/ownership.html#argument-conventions) in an `fn`\nfunction is `borrowed`—this is a good thing because this function should not\nmodify the contents of the value being copied.\n\n:::\n--- cell type: markdown ---\nNow this code works to make a copy:\n--- cell type: code ---\nlet mine = MyPet(\"Loki\", 4)\nlet yours = mine\n--- cell type: markdown ---\nWhat makes Mojo's copy behavior different, compared to other languages, is that\n`__copyinit__()` is designed to perform a deep copy of all fields in the type\n(as per [value semantics](/mojo/manual/values/value-semantics.html)). That is,\nit copies heap-allocated values, rather than just copying the pointer.\n\nHowever, the Mojo compiler doesn't enforce this, so it's the type author's\nresponsibility to implement `__copyinit__()` with value semantics. For example,\nhere's a new `HeapArray` type that performs a deep copy in the copy constructor:\n--- cell type: code ---\nstruct HeapArray:\n    var data: Pointer[Int]\n    var size: Int\n    var cap: Int\n\n    fn __init__(inout self, size: Int, val: Int):\n        self.size = size\n        self.cap = size * 2\n        self.data = Pointer[Int].alloc(self.cap)\n        for i in range(self.size):\n            self.data.store(i, val)\n\n    fn __copyinit__(inout self, existing: Self):\n        # Deep-copy the existing value\n        self.size = existing.size\n        self.cap = existing.cap\n        self.data = Pointer[Int].alloc(self.size)\n        for i in range(self.size):\n            self.data.store(i, existing.data.load(i))\n        # The lifetime of `existing` continues unchanged\n\n    fn __del__(owned self):\n        # We must free the heap-allocated data, but\n        # Mojo knows how to destroy the other fields\n        self.data.free()\n\n    fn append(inout self, val: Int):\n        # Update the array for demo purposes\n        if self.size < self.cap:\n            self.data.store(self.size, val)\n            self.size += 1\n        else:\n            print(\"Out of bounds\")\n\n    fn dump(self):\n        # Print the array contents for demo purposes\n        print_no_newline(\"[\")\n        for i in range(self.size):\n            if i > 0:\n                print_no_newline(\", \")\n            print_no_newline(self.data.load(i))\n        print(\"]\")\n--- cell type: markdown ---\nNotice that `__copyinit__()` does not copy the `Pointer` value (doing so would\nmake the copied value refer to the same `data` memory address as the original\nvalue, which is a shallow copy). Instead, we initialize a new `Pointer` to\nallocate a new block of memory, and then copy over all the heap-allocated\nvalues (this is a deep copy).\n\nThus, when we copy an instance of `HeapArray`, each copy has its own value on\nthe heap, so changes to one value do not affect the other, as shown here:\n--- cell type: code ---\nfn copies():\n    let a = HeapArray(2, 1)\n    var b = a    # Calls the copy constructor\n    a.dump()     # Prints [1, 1]\n    b.dump()     # Prints [1, 1]\n\n    b.append(2)  # Changes the copied data\n    b.dump()     # Prints [1, 1, 2]\n    a.dump()     # Prints [1, 1] (the original did not change)\n--- cell type: markdown ---\n:::{.callout-note}\n\n**Note:** In `HeapArray`, we must use the `__del__()` destructor to free the\nheap-allocated data when the `HeapArray` lifetime ends, but Mojo automatically\ndestroys all other fields when their respective lifetimes end. We'll discuss\nthis destructor more in [Death of a value](/mojo/manual/lifecycle/death.html).\n\n:::\n--- cell type: markdown ---\nIf your type doesn't use any pointers for heap-allocated data, then writing the\nconstructor and copy constructor is all boilerplate code that you shouldn't\nhave to write. So, if all your fields use destructible data types (such as\n`Int`, `Bool`, `String`, etc.), you can just add the [`@value`\ndecorator](/mojo/manual/decorators/value.html) to your struct definition and\nMojo will synthesize the `__init__()`, `__copyinit__()`, and `__moveinit__()`\nmethods.\n--- cell type: markdown ---\n## Move constructors\n\nAlthough copying values provides predictable behavior that matches Mojo's\n[value semantics](/mojo/manual/values/value-semantics.html), copying some data\ntypes can be a significant hit on performance. If you're familiar with\nreference semantics, then the solution here might seem clear: instead of making\na copy when passing a value, share the value as a reference. And if the\noriginal variable is no longer needed, nullify the original to avoid any\ndouble-free or use-after-free errors. That's generally known as a move\noperation: the memory block holding the data remains the same (the memory does\nnot actually move), but the pointer to that memory moves to a new variable in\nthe call stack.\n\nHowever, \"move\" can mean something different depending on whether you're more\nexperienced with C++ or Rust, which each offer their own version of move\nsemantics that avoid copying heap-allocated values. Each approach has its\nbenefits, so Mojo supports them both with a separate constructor:\n\n- `__moveinit__()` is invoked to perform a \"consuming\" move, which\n  fully transfers ownership of a value without copying heap-allocated data.\n  Mojo ends the lifetime of the original value (the variable becomes invalid)\n  to avoid double-free and use-after-free errors. (This is a Rust-style move;\n  also called a \"destructive move.\")\n\n- `__takeinit__()` is invoked to perform a \"taking\" move, which is\n  similar in that it moves ownership of a value without copying heap-allocated\n  data, except it does _not_ end the lifetime of the original value. As the type\n  author, it's your responsibility to update the original variable with a \"null\n  state.\" (This is a C++-style move; also called a \"stealing move\" or a\n  \"non-destructive move.\")\n\nThe difference between these two—especially how they are each invoked—might be\na bit confusing now, but it should become more clear in the following sections.\nAlso, it's safe to say that you generally don't need to worry about using\n`__takeinit__()` unless you already know that this is necessary for your\nproblem, as it is generally useful only in rare circumstances.\n--- cell type: markdown ---\n:::{.callout-note}\n\n**Note:** A move constructor is **not required** to transfer ownership of a\nvalue. Unlike in Rust, transferring ownership is not always a move operation;\nthe move constructors are only part of the implementation for how Mojo\ntransfers ownership of a value. You can learn more in the section about\n[ownership\ntransfer](/mojo/manual/values/ownership.html#transfer-arguments-owned-and).\n\n:::\n--- cell type: markdown ---\n### Consuming-move constructor\n\nThe `__moveinit__()` method performs a consuming-move: it transfers ownership\nof a value from one variable to another when the original variable's lifetime\nends (also called a \"destructive move\").\n\nFor most situations, this is the behavior you want when you [transfer\nownership](/mojo/manual/values/ownership.html#transfer-arguments-owned-and),\nbecause Mojo invokes `__moveinit__()` to transfer ownership only when Mojo can\nguarantee that the lifetime of the original value is ending (usually indicated\nby the `^` transfer operator). (However, Mojo can transfer ownership in some\nsituations even without this constructor.)\n\nWhen a consuming-move occurs, Mojo immediately invalidates the original\nvariable, preventing any access to it and disabling its destructor. Invalidating\nthe original variable is important to avoid memory errors on heap-allocated\ndata, such as use-after-free and double-free errors.\n\nHere's how to add the consuming-move constructor to the `HeapArray` example:\n--- cell type: code ---\nstruct HeapArray:\n    var data: Pointer[Int]\n    var size: Int\n\n    fn __init__(inout self, size: Int, val: Int):\n        self.size = size\n        self.data = Pointer[Int].alloc(self.size)\n        for i in range(self.size):\n            self.data.store(i, val)\n\n    fn __copyinit__(inout self, existing: Self):\n        # Deep-copy the existing value\n        self.size = existing.size\n        self.data = Pointer[Int].alloc(self.size)\n        for i in range(self.size):\n            self.data.store(i, existing.data.load(i))\n\n    fn __moveinit__(inout self, owned existing: Self):\n        print(\"move\")\n        # Shallow copy the existing value\n        self.size = existing.size\n        self.data = existing.data\n        # Then the lifetime of `existing` ends here, but\n        # Mojo does NOT call its destructor\n\n    fn __del__(owned self):\n        self.data.free()\n\n    fn dump(self):\n        print_no_newline(\"[\")\n        for i in range(self.size):\n            if i > 0:\n                print_no_newline(\", \")\n            print_no_newline(self.data.load(i))\n        print(\"]\")\n--- cell type: markdown ---\nThe critical feature of `__moveinit__()` is that it takes the incoming value as\n`owned`, meaning this method gets unique ownership of the value. Moreover,\nbecause this is a dunder method that Mojo calls only when performing a\nconsuming-move (during ownership transfer), the `existing` argument is\nguaranteed to be a mutable reference to the original value, _not a copy_\n(unlike other methods that may declare an argument as `owned`, but might\nreceive the value as a copy if the method is called without the [`^` transfer\noperator](/mojo/manual/values/ownership.html#transfer-arguments-owned-and)).\nThat is, Mojo calls this move constructor _only_ when the original variable's\nlifetime actually ends at the point of transfer.\n\nHere's an example showing how to invoke the move constructor for `HeapArray`:\n--- cell type: code ---\nfn moves():\n    let a = HeapArray(3, 1)\n\n    a.dump()   # Prints [1, 1, 1]\n\n    let b = a^ # Prints \"move\"; the lifetime of `a` ends here\n\n    b.dump()   # Prints [1, 1, 1]\n    #a.dump()  # ERROR: use of uninitialized value 'a'\n--- cell type: markdown ---\nNotice that `__moveinit__()` performs a shallow copy of the\nexisting field values (it copies the pointer, instead of allocating new memory\non the heap), which is what makes it useful for types with heap-allocated\nvalues that are expensive to copy.\n\nTo go further and ensure your type can never be copied, you can make it\n\"move-only\" by implementing `__moveinit__()` and _excluding_ `__copyinit__()`.\nA move-only type can be passed to other variables and passed into functions\nwith any argument convention (`borrowed`, `inout`, and `owned`)—the only catch\nis that you must use the `^` transfer operator to end the lifetime of a\nmove-only type when assigning it to a new variable or when passing it as an\n`owned` argument.\n--- cell type: markdown ---\n:::{.callout-note}\n\n**Note:** For types without heap-allocated fields, you get no real benefit from\nthe move constructor. Making copies of simple data types on the stack, like\nintegers, floats, and booleans, is very cheap. Yet, if you allow your type to\nbe copied, then there's generally no reason to disallow moves, so you can\nsynthesize both constructors by adding the [`@value`\ndecorator](/mojo/manual/decorators/value.html).\n\n:::\n--- cell type: markdown ---\n### Taking-move constructor\n\nAlthough `__moveinit__()` provides a mechanism to provide predictable ownership\ntransfers for your types, it enforces move semantics that are problematic in\n(rare) situations where you don't want the lifetime of the original value to\nend. In such situations, you might prefer to implement `__takeinit__()`, which\nperforms a \"taking move\" (also known as a \"stealing move\" or \"non-destructive\nmove\").\n\nThe `__takeinit__()` constructor has a similar effect as the `__moveinit__()`\nconstructor, but it does not end the lifetime of the original value. This is\nuseful for situations in which it's necessary that the original variable remain\nvalid (but in a \"null state\"), so that its destructor is still allowed to run\n(but only upon a nullified value to avoid a double-free).\n\nGenerally, you'll know it if you need to use this; if `__moveinit__()` makes\nsense and that behavior doesn't worry you, then you don't need\n`__takeinit__()`.\n\n:::{.callout-caution}\n\n**Caution:** Currently, this documentation about `__takeinit__()` describes our\ndesign intentions, and the lifetime behaviors required to invoke\n`__takeinit__()` when a value is passed to a function that takes ownership is\nnot fully implemented. There are several TODOs we must finish before this is\nfully functional, such as the ability for code to [return\nreferences](/mojo/roadmap.html#ownership-and-lifetimes).\n\n:::\n\nFor example, let's say you create an array of `HeapArray` values. If you\ntransfer ownership of just one item in that array using `__moveinit__()`, you\nmight encounter problems using that array later, because the array will contain\nan invalid variable that cannot be read or destroyed. To solve for this\nusecase, you might want to implement `__takeinit__()` instead of\n`__moveinit__()` so that all array items remain valid.\n\nHowever, because this move operation leaves the original value valid, it allows\nfor potential double-free and use-after-free errors. So, it's very important\nthat you hollow-out the original value in your `__takeinit__()` implementation,\nby replacing the original value contents with some type of \"null state\" or\nsentinel value that tells the destructor to treat it differently.\n\nFor example, here's how we can implement `HeapArray` to allow a taking-move:\n--- cell type: code ---\nstruct HeapArray:\n    var data: Pointer[Int]\n    var size: Int\n\n    fn __init__(inout self, size: Int, val: Int):\n        self.size = size\n        self.data = Pointer[Int].alloc(self.size)\n        for i in range(self.size):\n            self.data.store(i, val)\n\n    fn __takeinit__(inout self, inout existing: Self):\n        # Shallow-copy the existing value\n        self.size = existing.size\n        self.data = existing.data\n        # The lifetime for `existing` does not end here, so we\n        # must update its value to no longer refer to moved data,\n        # in order to avoid double-free and use-after-free errors,\n        # but in a way that still allows the destructor to run.\n        existing.size = 0\n        existing.data = Pointer[Int].get_null()\n\n    fn __del__(owned self):\n        # Free the data only if the Pointer is not null\n        if (self.data):\n            self.data.free()\n\n    fn dump(self):\n        print_no_newline(\"[\")\n        for i in range(self.size):\n            if i > 0:\n                print_no_newline(\", \")\n            print_no_newline(self.data.load(i))\n        print(\"]\")\n--- cell type: markdown ---\nThis technique has tradeoffs and is not the best for every type. However, we\nbelieve that you, the library authors, understand your domain problems better\nthan we, the language designers do. So we prefer to provide full control over\nthese behaviors. As such you can choose to (but don’t have to) make your types\nparticipate in this taking-move constructor.\n--- cell type: markdown ---\n:::{.callout-note}\n\n**Note:** Because `__takeinit__()` uses `inout` for the `existing` argument,\nthe value you want to move with the taking-move operation must be mutable.\n\n:::\n--- cell type: markdown ---\n## Simple value types {#value-decorator}\n\nBecause copy and move constructors are opt-in, Mojo provides great control for\nexotic usecases (such as for atomic values that should never be copied or\nmoved), but most structs are simple aggregations of other types that should be\neasily copied and moved, and we don't want to write a lot of boilerplate\nconstructors for those simple value types.\n\nTo solve this, Mojo provides the [`@value`\ndecorator](/mojo/manual/decorators/value.html), which synthesizes the\nboilerplate code for the `__init__()`, `__copyinit__()`, and `__moveinit__()`\nmethods.\n\nFor example, consider a simple struct like this:\n--- cell type: code ---\n@value\nstruct MyPet:\n    var name: String\n    var age: Int\n--- cell type: markdown ---\nMojo sees the `@value` decorator and notices that you don't have a member-wise\ninitializer (a constructor with arguments for each field), a copy constructor,\nor a move constructor, so it synthesizes them for you. The result is as if you\nhad actually written this:\n--- cell type: code ---\nstruct MyPet:\n    var name: String\n    var age: Int\n\n    fn __init__(inout self, owned name: String, age: Int):\n        self.name = name^\n        self.age = age\n\n    fn __copyinit__(inout self, existing: Self):\n        self.name = existing.name\n        self.age = existing.age\n\n    fn __moveinit__(inout self, owned existing: Self):\n        self.name = existing.name^\n        self.age = existing.age\n--- cell type: markdown ---\nMojo synthesizes each lifecycle method only when it doesn't exist, so\nyou can use `@value` and still define your own versions to override the default\nbehavior. For example, it is fairly common to use the default member-wise and\nmove constructor, but create a custom copy constructor.\n\nSomething you can see in this code that we didn't mention yet is that the\n`__init__()` method takes all arguments as `owned`, because the constructor\nmust take ownership to store each value. This is a useful micro-optimization\nand enables the use of move-only types. Trivial types like `Int` are also\npassed as `owned`, but because ownership doesn't mean anything for integers, we\ncan elide that declaration and the transfer operator (`^`) for simplicity. The\ntransfer operator is also just a formality in this case, because, even if it's\nnot used with `self.name = name^`, the Mojo compiler will notice that `name` is\nlast used here and convert this assignment into a move, instead of a\ncopy+delete.\n\n:::{.callout-note}\n\n**Note:** If your type contains any move-only fields, Mojo will not generate\nthe copy constructor because it cannot copy those fields. Further, the `@value`\ndecorator won't work at all if any of your members are neither copyable nor\nmovable. For example, if you have something like `Atomic` in your struct, then\nit probably isn't a true value type, and you don't want the copy/move\nconstructors anyway.\n\nAlso notice that the `MyPet` struct above doesn't include the `__del__()`\ndestructor (the `@value` decorator does not synthesize this), because Mojo\ndoesn't need it to destroy fields, as discussed in [Death of a\nvalue](/mojo/manual/lifecycle/death.html)\n\n:::\n--- cell type: markdown ---\n## Trivial types\n\nSo far, we've talked about values that live in memory, which means they have an\nidentity (an address) that can be passed around among functions (passed \"by\nreference\"). This is great for most types, and it's a safe default for large\nobjects with expensive copy operations. However, it's inefficient for tiny\nthings like a single integer or floating point number. We call these types\n\"trivial\" because they are just \"bags of bits\" that should be copied, moved,\nand destroyed without invoking any custom lifecycle methods.\n\nTrivial types are the most common types that surround us, and from a language\nperspective, Mojo doesn’t need special support for these written in a struct.\nUsually, these values are so tiny that they should be passed around in CPU\nregisters, not indirectly through memory.\n\nAs such, Mojo provides a struct decorator to declare these types of values:\n`@register_passable(\"trivial\")`. This decorator tells Mojo that the type should\nbe copyable and movable but that it has no user-defined logic (no lifecycle\nmethods) for doing this. It also tells Mojo to pass the value in CPU registers\nwhenever possible, which has clear performance benefits.\n\nYou'll see this decorator on types like `Int` in the standard library:\n\n```mojo\n@register_passable(\"trivial\")\nstruct Int:\n    var value: __mlir_type.index\n\n    fn __init__(value: __mlir_type.index) -> Int:\n        return Self {value: value}\n    ...\n```\n\nWe expect to use this decorator pervasively on Mojo standard library types, but\nit is safe to ignore for general application-level code.\n\nFor more information, see the [`@register_passable`\ndocumentation](/mojo/manual/decorators/register_passable.html).\n\n:::{.callout-note}\n\nTODO: This decorator is due for reconsideration.  Lack of custom\ncopy/move/destroy logic and \"passability in a register\" are orthogonal concerns\nand should be split.  This former logic should be subsumed into a more general\n`@value(\"trivial\")` decorator, which is orthogonal from `@register_passable`.\n\n:::"
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/manual/packages.md",
        "content": "---\ntitle: Modules and packages\norder: 5\nsidebar_position: 5\nsidebar_label: Modules and packages\ndescription: Learn how to package Mojo code for distribution and importing.\ncss: /static/styles/page-navigation.css\naliases:\n  - /mojo/manual/get-started/packages.html\nwebsite:\n  open-graph:\n    image: /static/images/mojo-social-card.png\n  twitter-card:\n    image: /static/images/mojo-social-card.png\n---\n\nMojo provides a packaging system that allows you to organize and compile code\nlibraries into importables files. This page introduces the necessary concepts\nabout how to organize your code into modules and packages (which is a lot\nlike Python), and shows you how to create a packaged binary with the [`mojo\npackage`](/mojo/cli/package.html) command.\n\n## Mojo modules\n\nTo understand Mojo packages, you first need to understand Mojo modules. A\nMojo module is a single Mojo source file that includes code suitable for use\nby other files that import it. For example, you can create a module\nto define a struct such as this one:\n\n```{.mojo filename=\"mymodule.mojo\"}\nstruct MyPair:\n    var first: Int\n    var second: Int\n\n    fn __init__(inout self, first: Int, second: Int):\n        self.first = first\n        self.second = second\n\n    fn dump(self):\n        print(self.first, self.second)\n```\n\nNotice that this code has no `main()` function, so you can't execute\n`mymodule.mojo`. However, you can import this into another file with a\n`main()` function and use it there.\n\nFor example, here's how you can import `MyPair` into a file named `main.mojo`\nthat's in the same directory as `mymodule.mojo`:\n\n```{.mojo filename=\"main.mojo\"}\nfrom mymodule import MyPair\n\nfn main():\n    let mine = MyPair(2, 4)\n    mine.dump()\n```\n\nAlternatively, you can import the whole module and then access its members\nthrough the module name. For example:\n\n```{.mojo filename=\"main.mojo\"}\nimport mymodule\n\nfn main():\n    let mine = mymodule.MyPair(2, 4)\n    mine.dump()\n```\n\nYou can also create an alias for an imported member with `as`, like this:\n\n```{.mojo filename=\"main.mojo\"}\nimport mymodule as my\n\nfn main():\n    let mine = my.MyPair(2, 4)\n    mine.dump()\n```\n\nIn this example, it only works when `mymodule.mojo` is in the same directory as\n`main.mojo`. Currently, you can't import `.mojo` files as modules if they\nreside in other directories. That is, unless you treat the directory as a Mojo\npackage, as described in the next section.\n\n:::{.callout-note}\n\n**Note:** A Mojo module may include a `main()` function and may also be\nexecutable, but that's generally not the practice and modules typically include\nAPIs to be imported and used in other Mojo programs.\n\n:::\n\n## Mojo packages\n\nA Mojo package is just a collection of Mojo modules in a directory that\nincludes an `__init__.mojo` file. By organizing modules together in a\ndirectory, you can then import all the modules together or individually.\nOptionally, you can also compile the package into a `.mojopkg` or `.📦` file\nthat's easier to share.\n\nYou can import a package and its modules either directly from source files or\nfrom a compiled `.mojopkg`/`.📦` file. It makes no real difference to Mojo\nwhich way you import a package. When importing from source files, the directory\nname works as the package name, whereas when importing from a compiled package,\nthe filename is the package name (which you specify with the [`mojo\npackage`](/mojo/cli/package.html) command—it can differ from the directory\nname).\n\nFor example, consider a project with these files:\n\n```ini\nmain.mojo\nmypackage/\n    __init__.mojo\n    mymodule.mojo\n```\n\n`mymodule.mojo` is the same code from examples above (with the `MyPair`\nstruct) and `__init__.mojo` is empty.\n\nIn this case, the `main.mojo` file can now import `MyPair` through the package\nname like this:\n\n```{.mojo filename=\"main.mojo\"}\nfrom mypackage.mymodule import MyPair\n\nfn main():\n    let mine = MyPair(2, 4)\n    mine.dump()\n```\n\nNotice that the `__init__.mojo` is crucial here. If you delete it, then Mojo\ndoesn't recognize the directory as a package and it cannot import `mymodule`.\n\nThen, let's say you don't want the `mypackage` source code in the same location\nas `main.mojo`. So, you can compile it into a package file like this:\n\n```sh\nmojo package mypackage -o mypack.mojopkg\n```\n\nThen the `mypackage` source can be moved somewhere else, and the project\nfiles now look like this:\n\n```ini\nmain.mojo\nmypack.mojopkg\n```\n\nBecause we named the package file different from the directory, we need to fix\nthe import statement and it all works the same:\n\n```{.mojo filename=\"main.mojo\"}\nfrom mypack.mymodule import MyPair\n```\n\n:::{.callout-note}\n\n**Note:** If you want to rename your package, you cannot simply edit the\n`.mojopkg` or `.📦` filename, because the package name is encoded in the file.\nYou must instead run `mojo package` again to specify a new name.\n\n:::\n\n### The `__init__` file\n\nAs mentioned above, the `__init__.mojo` file is required to indicate that a\ndirectory should be treated as a Mojo package, and it can be empty.\n\nCurrently, top-level code is not supported in `.mojo` files, so unlike Python,\nyou can't write code in `__init__.mojo` that executes upon import. You can,\nhowever, add structs and functions, which you can then import from the package\nname.\n\nHowever, instead of adding APIs in the `__init__.mojo` file, you can import\nmodule members, which has the same effect by making your APIs accessible from\nthe package name, instead of requiring the `<package_name>.<module_name>`\nnotation.\n\nFor example, again let's say you have these files:\n\n```ini\nmain.mojo\nmypackage/\n    __init__.mojo\n    mymodule.mojo\n```\n\nLet's now add the following line in `__init__.mojo`:\n\n```{.mojo filename=\"__init__.mojo\"}\nfrom .mymodule import MyPair\n```\n\nThat's all that's in there. Now, we can simplify the import statement in\n`main.mojo` like this:\n\n```{.mojo filename=\"main.mojo\"}\nfrom mypackage import MyPair\n```\n\nThis feature explains why some members in the Mojo standard library can be\nimported from their package name, while others required the\n`<package_name>.<module_name>` notation. For example, the\n[`functional`](/mojo/stdlib/algorithm/functional.html) module resides in the\n`algorithm` package, so you can import members of that module (such as the\n`map()` function) like this:\n\n```mojo\nfrom algorithm.functional import map\n```\n\nHowever, the `algorithm/__init__.mojo` file also includes these lines:\n\n```{.mojo filename=\"algorithm/__init__.mojo\"}\nfrom .functional import *\nfrom .reduction import *\n```\n\nSo you can actually import anything from `functional` or `reduction` simply by\nnaming the package. That is, you can drop the `functional` name from the import\nstatement, and it also works:\n\n```mojo\nfrom algorithm import map\n```\n\n:::{.callout-note}\n\n**Note:** Which modules in the standard library are imported to the package\nscope varies, and is subject to change. Refer to the [documentation for each\nmodule](/mojo/lib.html) to see how you can import its members.\n\n:::\n"
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/manual/parameters/index.ipynb",
        "content": "--- cell type: markdown ---\nMany languages have facilities for _metaprogramming_: that is, for writing code that generates or modifies code. Python has facilities for dynamic metaprogramming: features like decorators, metaclassess, and many more. These features make Python very flexible and productive, but since they're dynamic, they come with runtime overhead. Other languages have static or compile-time metaprogramming features, like C preprocessor macros and C++ templates. These can be limiting and hard to use.\n\nTo support Modular's work in AI, Mojo aims to provide powerful, easy-to-use metaprogramming with zero runtime cost. This compile-time metaprogramming uses the same language as runtime programs, so you don't have to learn a new language—just a few new features.\n\nThe main new feature is _parameters_. You can think of a parameter as a compile-time variable that becomes a runtime constant. This usage of \"parameter\" is probably different from what you're used to from other languages, where \"parameter\" and \"argument\" are often used interchangeably. In Mojo, \"parameter\" and \"parameter expression\" refer to compile-time values, and \"argument\" and \"expression\" refer to runtime values. \n\nIn Mojo, you can add parameters to a struct or function. You can also define \nnamed parameter expressions—aliases—that you can use as runtime constants.\n--- cell type: markdown ---\n## Parameterized functions\n\nTo define a _parameterized function_, add parameters in square brackets ahead\nof the argument list. Each parameter is formatted just like an argument: a \nparameter name, followed by a colon and a type (which is required). In the\nfollowing example, the function has a single parameter, `count` of type `Int`. \n--- cell type: code ---\nfn repeat[count: Int](msg: String):\n    @unroll\n    for i in range(count):\n        print(msg)\n--- cell type: markdown ---\n(The [`@unroll`](/mojo/manual/decorators/unroll.html) directive shown here \nunrolls loops at compile time. The directive only works if the loop limits are\ncompile-time constants.)\n\nCalling a parameterized function, you provide values for the parameters, just like function arguments: \n--- cell type: code ---\nrepeat[3](\"Hello\")\n--- cell type: markdown ---\n \n The compiler resolves the parameter values during compilation, and creates a\n concrete version of the `repeat[]()` function for each unique parameter value.\n After resolving the parameter values and unrolling the loop, the `repeat[3]()`\n function would be roughly equivalent to this:\n\n```mojo\nfn repeat_3(msg: String):\n    print(msg)\n    print(msg)\n    print(msg)\n```\n\n:::{.callout-note}\n\n**Note:** This doesn't represent actual code generated by the compiler. By the\ntime parameters are resolved, Mojo code has already been transformed to an\nintermediate representation in [MLIR](https://mlir.llvm.org/).\n\n:::\n\nIf the compiler can't resolve all parameter values to constant values, \ncompilation fails.\n--- cell type: markdown ---\n\n## Parameterized structs\n\nYou can also add parameters to structs. You can use parameterized structs to\nbuild generic containers. For example, a generic array type might include\ncode like this:\n--- cell type: code ---\nstruct GenericArray[T: AnyRegType]:\n    var data: Pointer[T]\n    var size: Int\n\n    fn __init__(inout self, *elements: T):\n        self.size = len(elements)\n        self.data = Pointer[T].alloc(self.size)\n        for i in range(self.size):\n            self.data.store(i, elements[i])\n\n    fn __del__(owned self):\n        self.data.free()\n\n    fn __getitem__(self, i: Int) raises -> T:\n        if (i < self.size):\n            return self.data.load(i)\n        else:\n            raise Error(\"Out of bounds\")\n--- cell type: markdown ---\nThis struct has a single parameter, `T`, which is a placeholder for the data\ntype you want to store in the array, sometimes called a _type parameter_. `T` is\ntyped as [`AnyRegType`](/mojo/stdlib/builtin/type_aliases.html), which is a \n_metatype_ representing any \n[register-passable type](/mojo/manual/decorators/register-passable.html). This\nmeans our `GenericArray` can hold fixed-size data types like integers and \nfloating-point numbers that can be passed in a machine register, but not \ndynamically allocated data like strings or vectors.\n\n:::{.callout-note}\n\nUsing a capital `T` as the parameter doesn't have any special significance to\nthe compiler, but it's a convention in a number of languages to use a short name\nfor a type parameter, frequently defaulting to `T` (for \"type\"). \n\n:::\n\nAs with parameterized functions, you need to pass in parameter values when you\nuse a parameterized struct. In this case, when you create an instance of \n`GenericArray`, you need to specify the type you want to store, like `Int`, or\n`Float64`. (This is a little confusing, because the _parameter value_ you're\npassing in this case is a _type_. That's OK: a Mojo type is a valid compile-time\nvalue.)\n\nYou'll see that `T` is used throughout the struct where you'd usually see a \ntype name. For example, as the formal type for the `elements` in the \nconstructor, and the return type of the `__getitem__()` method.\n\nAt the moment, this code only works with register-passable types, which is why\nthe type parameter `T` is limited to `AnyRegType`. There's also an\n[`AnyType`](/mojo/stdlib/builtin/type_aliases.html) metatype, which includes \n**all** Mojo types.\n\nHere's an example of using `GenericArray`:\n--- cell type: code ---\nvar array = GenericArray[Int](1, 2, 3, 4)\nfor i in range(array.size):\n    print_no_newline(array[i], \" \")\n--- cell type: markdown ---\nA parameterized struct can use the `Self` type to represent a concrete instance\nof the struct (that is, with all its parameters specified). For example, you\ncould add a static factory method to `GenericArray` with the following\nsignature:\n\n```mojo\nstruct GenericArray[T: AnyRegType]:\n    ...\n\n    @staticmethod\n    splat(count: Int, value: T) -> Self:\n        # Create a new array with count instances of the given value\n```\n\nHere, `Self` is equivalent to writing `GenericArray[T]`. That is, you can call\nthe `splat()` method like this:\n\n```mojo\nGenericArray[Float64].splat(8, 0)\n```\n\nThe method returns an instance of `GenericArray[Float64]`.\n--- cell type: markdown ---\n### Fully-bound, partially-bound, and unbound types\n\nA parametric type with its parameters specified is said to be _fully-bound_. \nThat is, all of its parameters are bound to values. As mentioned before, you can\nonly instantiate a fully-bound type (sometimes called a _concrete type_).\n\nHowever, parametric types can be _unbound_ or _partially bound_ in some\ncontexts. For example, given the following type:\n--- cell type: code ---\nstruct MyType[s: String, i: Int]:\n    pass\n--- cell type: markdown ---\nIt can appear in code in the following forms:\n\n- _Fully bound_, with all of its parameters specified. For example,\n  `MyType[\"Hello\", 3]`.\n- _Partially bound_, with *some but not all* of its parameters specified. For \n   example, `MyType[\"Hola\"]`.\n- _Unbound_, with no parameters specified. For example, `MyType`.\n\nPartially-bound and unbound parametric types can be used in some contexts where\nthe missing (unbound) parameters can be supplied later—such as in \n[function arguments](#automatic-parameterization-of-functions).\n--- cell type: markdown ---\n### Case study: the SIMD type\n\nFor a real-world example of a parameterized type, let's look at the \n[`SIMD`](/mojo/stdlib/builtin/simd.html) type from Mojo's standard library.\n\n[Single instruction, multiple data (SIMD)](https://en.wikipediv1.org/wiki/Single_instruction,_multiple_data) is a parallel processing technology built into many modern CPUs,\nGPUs, and custom accelerators. SIMD allows you to perform a single operation on\nmultiple pieces of data at once. For example, if you want to take the square \nroot of each element in array, you can use SIMD to parallelize the work. \n\nProcessors implement SIMD using low-level vector registers in hardware that hold\nmultiple instances of a scalar data-type. In order to use the SIMD instructions\non these processors, the data must be shaped into the proper SIMD width\n(data type) and length (vector size). Processors may support 512-bit or\nlonger SIMD vectors, and support many data types from 8-bit integers to 64-bit \nfloating point numbers, so it's not practical to define all of the possible SIMD\nvariations. \n\nMojo's [`SIMD`](/mojo/stdlib/builtin/simd.html) type (defined as a struct)\nexposes the common SIMD operations in its methods, and makes the SIMD data type\nand size values parametric. This allows you to directly map your data to the \nSIMD vectors on any hardware.\n\nHere's a cut-down (non-functional) version of Mojo's `SIMD` type definition:\n\n```mojo\nstruct SIMD[type: DType, size: Int]:\n    var value: … # Some low-level MLIR stuff here\n\n    # Create a new SIMD from a number of scalars\n    fn __init__(inout self, *elems: SIMD[type, 1]):  ...\n\n    # Fill a SIMD with a duplicated scalar value.\n    @staticmethod\n    fn splat(x: SIMD[type, 1]) -> SIMD[type, size]: ...\n\n    # Cast the elements of the SIMD to a different elt type.\n    fn cast[target: DType](self) -> SIMD[target, size]: ...\n\n    # Many standard operators are supported.\n    fn __add__(self, rhs: Self) -> Self: ...\n```\n\nSo you can create and use a SIMD vector like this:\n--- cell type: code ---\nvar vector = SIMD[DType.int16, 4](1, 2, 3, 4)\nvector = vector * vector\nfor i in range(4):\n    print_no_newline(vector[i], \" \")\n--- cell type: markdown ---\nAs you can see, a simple arithmetic operator like `*` applied to a pair of \n`SIMD` vector operates on the corresponding elements in each vector.\n\nDefining each SIMD variant with parameters is great for code reuse because the\n`SIMD` type can express all the different vector variants statically, instead of\nrequiring the language to pre-define every variant.\n\nBecause `SIMD` is a parameterized type, the `self` argument in its functions\ncarries those parameters—the full type name is `SIMD[type, size]`. Although\nit's valid to write this out (as shown in the return type of `splat()`), this\ncan be verbose, so we recommend using the `Self` type (from\n[PEP673](https://peps.python.org/pep-0673/)) like the `__add__` example does.\n--- cell type: markdown ---\n## Overloading on parameters\n\nFunctions and methods can be overloaded on their parameter signatures. The\noverload resolution logic filters for candidates according to the following\nrules, in order of precedence:\n\n1) Candidates with the minimal number of implicit conversions (in both arguments\nand parameters).\n2) Candidates without variadic arguments.\n3) Candidates without variadic parameters.\n4) Candidates with the shortest parameter signature.\n5) Non-`@staticmethod` candidates (over `@staticmethod` ones, if available). \n\nIf there is more than one candidate after applying these rules, the overload\nresolution fails. For example:\n--- cell type: code ---\n@register_passable(\"trivial\")\nstruct MyInt:\n    \"\"\"A type that is implicitly convertible to `Int`.\"\"\"\n    var value: Int\n\n    @always_inline(\"nodebug\")\n    fn __init__(_a: Int) -> Self:\n        return Self {value: _a}\n\nfn foo[x: MyInt, a: Int]():\n    print(\"foo[x: MyInt, a: Int]()\")\n\nfn foo[x: MyInt, y: MyInt]():\n    print(\"foo[x: MyInt, y: MyInt]()\")\n\nfn bar[a: Int](b: Int):\n    print(\"bar[a: Int](b: Int)\")\n\nfn bar[a: Int](*b: Int):\n    print(\"bar[a: Int](*b: Int)\")\n\nfn bar[*a: Int](b: Int):\n    print(\"bar[*a: Int](b: Int)\")\n\nfn parameter_overloads[a: Int, b: Int, x: MyInt]():\n    # `foo[x: MyInt, a: Int]()` is called because it requires no implicit\n    # conversions, whereas `foo[x: MyInt, y: MyInt]()` requires one.\n    foo[x, a]()\n\n    # `bar[a: Int](b: Int)` is called because it does not have variadic\n    # arguments or parameters.\n    bar[a](b)\n\n    # `bar[*a: Int](b: Int)` is called because it has variadic parameters.\n    bar[a, a, a](b)\n\nparameter_overloads[1, 2, MyInt(3)]()\n\nstruct MyStruct:\n    fn __init__(inout self):\n        pass\n\n    fn foo(inout self):\n        print(\"calling instance menthod\")\n\n    @staticmethod\n    fn foo():\n        print(\"calling static method\")\n\nfn test_static_overload():\n    var a = MyStruct()\n    # `foo(inout self)` takes precedence over a static method.\n    a.foo()\n--- cell type: markdown ---\n## Using parameterized types and functions\n\nYou can instantiate parametric types and functions by passing values to the\nparameters in square brackets. For example, for the `SIMD` type above, `type`\nspecifies the data type and `size` specifies the length of the SIMD vector (it\nmust be a power of 2):\n--- cell type: code ---\n# Make a vector of 4 floats.\nlet small_vec = SIMD[DType.float32, 4](1.0, 2.0, 3.0, 4.0)\n\n# Make a big vector containing 1.0 in float16 format.\nlet big_vec = SIMD[DType.float16, 32].splat(1.0)\n\n# Do some math and convert the elements to float32.\nlet bigger_vec = (big_vec+big_vec).cast[DType.float32]()\n\n# You can write types out explicitly if you want of course.\nlet bigger_vec2 : SIMD[DType.float32, 32] = bigger_vec\n\nprint('small_vec type:', small_vec.element_type, 'length:', len(small_vec))\nprint('bigger_vec2 type:', bigger_vec2.element_type, 'length:', len(bigger_vec2))\n--- cell type: markdown ---\nNote that the `cast()` method also needs a parameter to specify the type you\nwant from the cast (the method definition above expects a `target` parametric\nvalue). Thus, just as the `SIMD` struct is a generic type definition, the\n`cast()` method is a generic method definition that gets instantiated at\ncompile-time instead of runtime, based on the parameter value.\n\nThe code above shows the use of concrete types (that is, it\ninstantiates `SIMD` using known type values), but the major power of parameters\ncomes from the ability to define parametric algorithms and types (code that\nuses the parameter values). For example, here's how to define a parametric\nalgorithm with `SIMD` that is type- and width-agnostic:\n--- cell type: code ---\nfrom math import sqrt\n\nfn rsqrt[dt: DType, width: Int](x: SIMD[dt, width]) -> SIMD[dt, width]:\n    return 1 / sqrt(x)\n\nprint(rsqrt[DType.float16, 4](42))\n--- cell type: markdown ---\nNotice that the `x` argument is actually a `SIMD` type based on the function\nparameters. The runtime program can use the value of parameters, because the\nparameters are resolved at compile-time before they are needed by the runtime\nprogram (but compile-time parameter expressions cannot use runtime values).\n\nThe Mojo compiler is also smart about type inference with parameters. Note\nthat the above function is able to call the parametric\n[`sqrt[]()`](https://docs.modular.com/mojo/stdlib/math/math.html#sqrt) function\nwithout specifying the parameters—the compiler infers its parameters based on\nthe parametric `x` value passed into it, as if you\nwrote `sqrt[dt, width](x)` explicitly. Also note that `rsqrt()` chose to\nname its second parameter `width` even though the `SIMD` type names it\n`size`, and there is no problem.\n--- cell type: markdown ---\n## Optional parameters and keyword parameters\n\nJust as you can specify [optional arguments](https://docs.modular.com/mojo/manual/basics/#function-arguments-and-returns)\nin function signatures, you can also define an optional _parameter_ by \ngiving it a default value. You can also pass parameters by keyword.\nFor a function or struct with multiple optional parameters, using keywords\nallows you to pass only the parameters you want to specify, regardless of\ntheir position in the function signature. \n\nFor example, here's a function with two parameters, each with a default value:\n--- cell type: code ---\nfn speak[a: Int = 3, msg: StringLiteral = \"woof\"]():\n    print(msg, a)\n\nfn use_defaults() raises:\n    speak()             # prints 'woof 3'\n    speak[5]()          # prints 'woof 5'\n    speak[7, \"meow\"]()  # prints 'meow 7'\n    speak[msg=\"baaa\"]() # prints 'baaa 3'\n--- cell type: markdown ---\nRecall that Mojo can infer parameter values in a parametric function, based on\nthe parametric values attached to an argument value (see the `rsqrt[]()`\nexample above). If the parametric function also has a default value defined,\nthen the inferred parameter type takes precedence.\n\nFor example, in the following code, we update the parametric `speak[]()` function\nto take an argument with a parametric type. Although the function has a default\nparameter value for `a`, Mojo instead uses the inferred `a` parameter value\nfrom the `bar` argument (as written, the default `a` value can never be used,\nbut this is just for demonstration purposes):\n--- cell type: code ---\n@value\nstruct Bar[v: Int]:\n    pass\n\nfn foo[a: Int = 3, msg: StringLiteral = \"woof\"](bar: Bar[a]):\n    print(msg, a)\n\nfn use_inferred():\n    foo(Bar[9]())  # prints 'woof 9'\n--- cell type: markdown ---\nAs mentioned above, you can also use optional parameters and keyword \nparameters in a struct:\n--- cell type: code ---\nstruct KwParamStruct[greeting: String = \"Hello\", name: String = \"🔥mojo🔥\"]:\n    fn __init__(inout self):\n        print(greeting, name)\n\nfn use_kw_params():\n    let a = KwParamStruct[]()                 # prints 'Hello 🔥mojo🔥'\n    let b = KwParamStruct[name=\"World\"]()     # prints 'Hello World'\n    let c = KwParamStruct[greeting=\"Hola\"]()  # prints 'Hola 🔥mojo🔥'\n--- cell type: markdown ---\n<div class=\"alert alert-block alert-info\">\n\n**Note:** Mojo currently includes only partial support for keyword parameters, so\nsome features such as keyword-only parameters and variadic keyword parameters \n(for example, `**kwparams`) are not supported yet.\n\n</div>\n--- cell type: markdown ---\n## Parameter expressions are just Mojo code\n\nA parameter expression is any code expression (such as `a+b`) that occurs where\na parameter is expected. Parameter expressions support operators and function\ncalls, just like runtime code, and all parameter types use the same type\nsystem as the runtime program (such as `Int` and `DType`).\n\nBecause parameter expressions use the same grammar and types as runtime\nMojo code, you can use many \n[\"dependent type\"](https://en.wikipedia.org/wiki/Dependent_type) features. For\nexample, you might want to define a helper function to concatenate two SIMD\nvectors:\n--- cell type: code ---\nfn concat[ty: DType, len1: Int, len2: Int](\n        lhs: SIMD[ty, len1], rhs: SIMD[ty, len2]) -> SIMD[ty, len1+len2]:\n\n    var result = SIMD[ty, len1 + len2]()\n    for i in range(len1):\n        result[i] = SIMD[ty, 1](lhs[i])\n    for j in range(len2):\n        result[len1 + j] = SIMD[ty, 1](rhs[j])\n    return result\n\nlet a = SIMD[DType.float32, 2](1, 2)\nlet x = concat[DType.float32, 2, 2](a, a)\n\nprint('result type:', x.element_type, 'length:', len(x))\n--- cell type: markdown ---\nNote how the resulting length is the sum of the input vector lengths, and you\ncan express that with a simple `+` operation. \n\n### Powerful compile-time programming\n\nWhile simple expressions are useful, sometimes you want to write imperative\ncompile-time logic with control flow. You can even do compile-time recursion.\nFor instance, here is an example \"tree reduction\" algorithm that sums all\nelements of a vector recursively into a scalar:\n--- cell type: code ---\nfn slice[ty: DType, new_size: Int, size: Int](\n        x: SIMD[ty, size], offset: Int) -> SIMD[ty, new_size]:\n    var result = SIMD[ty, new_size]()\n    for i in range(new_size):\n        result[i] = SIMD[ty, 1](x[i + offset])\n    return result\n\nfn reduce_add[ty: DType, size: Int](x: SIMD[ty, size]) -> Int:\n    @parameter\n    if size == 1:\n        return x[0].to_int()\n    elif size == 2:\n        return x[0].to_int() + x[1].to_int()\n\n    # Extract the top/bottom halves, add them, sum the elements.\n    alias half_size = size // 2\n    let lhs = slice[ty, half_size, size](x, 0)\n    let rhs = slice[ty, half_size, size](x, half_size)\n    return reduce_add[ty, half_size](lhs + rhs)\n\nlet x = SIMD[DType.index, 4](1, 2, 3, 4)\nprint(x)\nprint(\"Elements sum:\", reduce_add[DType.index, 4](x))\n--- cell type: markdown ---\nThis makes use of the [`@parameter`](/mojo/manual/decorators/parameter.html) decorator to create a parametric if condition, which is an `if` statement that\nruns at compile-time. It requires that its condition be a valid parameter\nexpression, and ensures that only the live branch of the `if` statement is\ncompiled into the program.\n\n## Mojo types are just parameter expressions\n\nWhile we've shown how you can use parameter expressions within types, type\nannotations can themselves be arbitrary expressions (just like in Python).\nTypes in Mojo have a special metatype type, allowing type-parametric algorithms\nand functions to be defined. \n\nFor example, we can create a simplified `Array` that supports arbitrary types of\nelements (via the `AnyRegType` parameter):\n--- cell type: code ---\nstruct Array[T: AnyRegType]:\n    var data: Pointer[T]\n    var size: Int\n\n    fn __init__(inout self, size: Int, value: T):\n        self.size = size\n        self.data = Pointer[T].alloc(self.size)\n        for i in range(self.size):\n            self.data.store(i, value)\n\n    fn __getitem__(self, i: Int) -> T:\n        return self.data.load(i)\n\n    fn __del__(owned self):\n        self.data.free()\n\nvar v = Array[Float32](4, 3.14)\nprint(v[0], v[1], v[2], v[3])\n--- cell type: markdown ---\nNotice that the `T` parameter is being used as the formal type for the\n`value` arguments and the return type of the `__getitem__()` function. \nParameters allow the `Array` type to provide different APIs based on the\ndifferent use-cases. \n\nThere are many other cases that benefit from more advanced use of parameters.\nFor example, you can execute a closure N times in parallel, feeding in a value\nfrom the context, like this:\n--- cell type: code ---\nfn parallelize[func: fn (Int) -> None](num_work_items: Int):\n    # Not actually parallel: see the 'algorithm' module for real implementation.\n    for i in range(num_work_items):\n        func(i)\n--- cell type: markdown ---\nAnother example where this is important is with variadic generics, where an\nalgorithm or data structure may need to be defined over a list of heterogeneous\ntypes such as for a tuple. Right now, this is not fully supported in Mojo and \nrequires writing some MLIR by hand. In the future, this will be possible in pure\nMojo.\n--- cell type: markdown ---\n## `alias`: named parameter expressions\n\nIt is very common to want to *name* compile-time values. Whereas `var` defines a\nruntime value, and `let` defines a runtime constant, we need a way to define a\ncompile-time temporary value. For this, Mojo uses an `alias` declaration. \n\nFor example, the [`DType`](/mojo/stdlib/builtin/dtype.html#dtype) struct \nimplements a simple enum using aliases for the enumerators like this (the actual\n`DType` implementation details vary a bit):\n\n```mojo\nstruct DType:\n    var value : UI8\n    alias invalid = DType(0)\n    alias bool = DType(1)\n    alias int8 = DType(2)\n    alias uint8 = DType(3)\n    alias int16 = DType(4)\n    alias int16 = DType(5)\n    ...\n    alias float32 = DType(15)\n```\n\nThis allows clients to use `DType.float32` as a parameter expression (which also\nworks as a runtime value) naturally. Note that this is invoking the\nruntime constructor for `DType` at compile-time.\n\nTypes are another common use for alias. Because types are compile-time\nexpressions, it is handy to be able to do things like this:\n--- cell type: code ---\nalias Float16 = SIMD[DType.float16, 1]\nalias UInt8 = SIMD[DType.uint8, 1]\n\nvar x : Float16   # FLoat16 works like a \"typedef\"\n--- cell type: markdown ---\nLike `var` and `let`, aliases obey scope, and you can use local aliases within\nfunctions as you'd expect.\n\nBy the way, the special types `None`, `AnyType`, and `AnyRegType` are defined as\n[type aliases](https://docs.modular.com/mojo/MojoBuiltin/TypeAliases.html).\n--- cell type: markdown ---\n\n## Automatic parameterization of functions\n\nMojo  supports \"automatic\" parameterization of functions. If a function \nargument type is parametric but the function signature *doesn't* specify\nparameters, the \n[unbound parameters](#fully-bound-partially-bound-and-unbound-types) are \nautomatically added as input parameters on the function. This is easier to\nunderstand with an example:\n--- cell type: code ---\nfn print_params(vec: SIMD):\n    print(vec.type)\n    print(vec.size)\n\nfn main():\n    let v = SIMD[DType.float64, 4](1.0, 2.0, 3.0, 4.0)\n    print_params(v)\n--- cell type: markdown ---\nIn the above example, the `print_params` function is automatically \nparameterized. The `vec` argument takes an argument of type `SIMD`. This is an\n[unbound parameterized\ntype](#fully-bound-partially-bound-and-unbound-types)—that is, it doesn't\nspecify any parameter values for the type. Mojo treats the unbound parameters\non `vec` as implicit parameters on the function. This is roughly equivalent to\nthe following code, which includes explicit input parameters:\n--- cell type: code ---\nfn print_params[t: DType, s: Int](vec: SIMD[t, s]):\n    print(vec.type)\n    print(vec.size)\n--- cell type: markdown ---\n\nWhen you call `print_params()` you must pass it a concrete instance of the \n`SIMD`  type—that is, one with all of its parameters specified, like \n`SIMD[DType.float64, 4]`. The Mojo compiler _infers_ the unbound parameter \nvalues from the input argument.\n\nWith a manually parameterized function, you can access the input parameters by\nname (for example, `t` and `s` in the previous example). For an\nautomatically parameterized function, you can access the parameters as\nattributes on the input argument (for example, `vec.type`). \n\nThis ability to access a type's input parameters is not specific to \nautomatically parameterized functions, you can use it anywhere. You can access \nthe input parameters of a parameterized type as attributes on the type itself:\n--- cell type: code ---\nfn on_type():\n    print(SIMD[DType.float32, 2].size) # prints 2\n--- cell type: markdown ---\nOr as attributes on an _instance_ of the type:\n--- cell type: code ---\nfn on_instance():\n    let x = SIMD[DType.int32, 2](4, 8)\n    print(x.type) # prints int32\n--- cell type: markdown ---\nYou can even use this syntax in the function's signature to define a \nfunction's arguments and return type based on an argument's parameters.\nFor example, if you want your function to take two SIMD vectors with the same\ntype and size, you can write code like this:\n--- cell type: code ---\nfn interleave(v1: SIMD, v2: SIMD[v1.type, v1.size]) -> SIMD[v1.type, v1.size*2]:\n    var result = SIMD[v1.type, v1.size*2]()\n    for i in range(v1.size):\n        result[i*2] = SIMD[v1.type, 1](v1[i])\n        result[i*2+1] = SIMD[v1.type, 1](v2[i])\n    return result\n\nlet a = SIMD[DType.int16, 4](1, 2, 3, 4)\nlet b = SIMD[DType.int16, 4](0, 0, 0, 0)\nlet c = interleave(a, b)\nfor i in range(c.size):\n    print_no_newline(c[i], \" \")\n--- cell type: markdown ---\n### Partial automatic parameterization\n\nMojo also supports _partial_ automatic parameterization: you can declare an\nargument that takes a [partially-bound parameterized\ntype](#fully-bound-partially-bound-and-unbound-types) (that is, a type with some\nbut not all of the parameters specified).\n\nFor example, suppose we have a `Fudge` struct with three parameters:\n--- cell type: code ---\n@value\nstruct Fudge[sugar: Int, cream: Int, chocolate: Int = 7](Stringable):\n    fn __str__(self) -> String:\n        let values = StaticIntTuple[3](sugar, cream, chocolate)\n        return str(\"Fudge\") + String(values)\n--- cell type: markdown ---\nWe can write a function that takes a `Fudge` argument with just one bound \nparameter (it's _partially bound_):\n--- cell type: code ---\n\nfn eat(f: Fudge[5]):\n    print(\"Ate \" + str(f))\n--- cell type: markdown ---\nThe `eat()` function takes a `Fudge` struct with the first parameter (`sugar`)\nbound to the value 5. The second parameter, `cream`, is unbound. (The third \nparameter, `chocolate` has a default value, which we'll discuss shortly.)\n\nThe unbound `cream` parameter becomes an implicit input parameter on the `eat`\nfunction. In practice, this is roughly equivalent to writing:\n--- cell type: code ---\nfn eat[c: Int](f: Fudge[5, c]):\n    print(\"Ate \" + str(f))\n--- cell type: markdown ---\nIn both cases, we can call the function by passing in an instance with the\n`cream` parameter bound:\n--- cell type: code ---\neat(Fudge[5, 5]())\neat(Fudge[5, 8]())\n--- cell type: markdown ---\nIf you try to pass in an argument with a `sugar` value other than 5,\ncompilation fails, because it doesn't match the argument type:\n\n[//]: TODO: Fix this example and the following one for Docusaurus\n\n```mojo\neat(Fudge[12, 5]()) \n```\n<div class=\"cell\">\n<div class=\"cell-output cell-output-stdout\" style=\"color: red\">\n<pre><code style=\"color: red; font-weight: bold;\">invalid call to 'eat': argument #0 cannot be converted from 'Fudge[12, 5, 7]' to 'Fudge[5, 5, 7]'</code></pre>\n</div>\n</div>\n\nWe haven't talked about the third parameter, `chocolate`. Currently, a parameter\nwith a default value is considered *bound to the default value* if it's not \nexplicitly bound or unbound. \n\nThis means that the following code won't compile with either of the previous \nversions of the `eat()` function, since it doesn't use the default value for \n`chocolate`:\n\n```mojo\neat(Fudge[5, 5, 9]())\n```\n<div class=\"cell\">\n<div class=\"cell-output cell-output-stdout\" style=\"color: red\">\n<pre><code style=\"color: red; font-weight: bold;\">invalid call to 'eat': argument #0 cannot be converted from 'Fudge[5, 5, 9]' to 'Fudge[5, 5, 7]'</code></pre>\n</div>\n</div>\n\n\n:::{.callout-note}\n\n**TODO:** We believe this handling of default values is incorrect, and it will\nbe changed in a future release.\n\n:::\n\nYou can also **explicitly** identify which parameters are unbound. This lets you\nunbind a parameter that has a default value, and gives you more freedom in \nspecifying unbound parameters.\n\nFor example, you might want to let the user specify values for `sugar` and \n`chocolate`, and leave `cream` constant. To do this, replace each unbound\nparameter value with a single underscore (`_`):\n--- cell type: code ---\nfn devour(f: Fudge[_, 6, _]):\n    print(str(\"Devoured \") + str(f))\n--- cell type: markdown ---\nAgain, the unbound parameters (`sugar` and `chocolate`) are added as implicit\ninput parameters on the function. This version is roughly equivalent to the\nfollowing code, where these two values are explicitly bound to the input \nparameters, `su` and `ch`:\n--- cell type: code ---\nfn devour[su: Int, ch: Int](f: Fudge[su, 6, ch]):\n        print(str(\"Devoured \") + str(f))\n--- cell type: markdown ---\nYou can also specify parameters by keyword, or mix positional and keyword\nparameters, so the following function is roughly equivalent to the previous one:\nthe first parameter, `sugar` is explicitly unbound with the underscore character.\nThe `chocolate` parameter is unbound using the keyword syntax, `chocolate=_`. \nAnd `cream` is explicitly bound to the value 6:\n\n--- cell type: code ---\nfn devour(f: Fudge[_, chocolate=_, cream=6]):\n    print(str(\"Devoured \") + str(f))\n--- cell type: markdown ---\nAll three versions of the `devour()` function work with the following calls:\n--- cell type: code ---\ndevour(Fudge[3, 6, 9]())\ndevour(Fudge[4, 6, 8]())\n--- cell type: markdown ---\n## Autotuning / Adaptive compilation\n\nMojo parameter expressions allow you to write portable parametric algorithms\nlike you can do in other languages, but when writing high-performance code you\nstill have to pick concrete values to use for the parameters. For example, when\nwriting high-performance numeric algorithms, you might want to use memory\ntiling to accelerate the algorithm, but the dimensions to use depend highly on\nthe available hardware features, the sizes of the cache, what gets fused into\nthe kernel, and many other fiddly details.\n\nEven vector length can be difficult to manage, because the vector length of a\ntypical machine depends on the datatype, and some datatypes like `bfloat16`\ndon't have full support on all implementations. Mojo helps by providing an\n[`autotune`](/mojo/stdlib/autotune/autotuning.html#autotune) function in the\nstandard library. For example if you want to write a vector-length-agnostic\nalgorithm to a buffer of data, you might write it like this:\n--- cell type: code ---\nimport benchmark\nfrom autotune import autotune, search\nfrom memory.unsafe import DTypePointer\nfrom algorithm import vectorize\n\nfn buffer_elementwise_add_impl[\n    dt: DType\n](lhs: DTypePointer[dt], rhs: DTypePointer[dt], result: DTypePointer[dt], N: Int):\n    \"\"\"Perform elementwise addition of N elements in RHS and LHS and store\n    the result in RESULT.\n    \"\"\"\n    @parameter\n    fn add_simd[size: Int](idx: Int):\n        let lhs_simd = lhs.simd_load[size](idx)\n        let rhs_simd = rhs.simd_load[size](idx)\n        result.simd_store[size](idx, lhs_simd + rhs_simd)\n\n    # Pick vector length for this dtype and hardware\n    alias vector_len = autotune(1, 4, 8, 16, 32)\n\n    # Use it as the vectorization length\n    vectorize[vector_len, add_simd](N)\n\nfn elementwise_evaluator[dt: DType](\n    fns: Pointer[fn (DTypePointer[dt], DTypePointer[dt], DTypePointer[dt], Int) -> None],\n    num: Int,\n) -> Int:\n    # Benchmark the implementations on N = 64.\n    alias N = 64\n    let lhs = DTypePointer[dt].alloc(N)\n    let rhs = DTypePointer[dt].alloc(N)\n    let result = DTypePointer[dt].alloc(N)\n\n    # Fill with ones.\n    for i in range(N):\n        lhs.store(i, 1)\n        rhs.store(i, 1)\n\n    # Find the fastest implementation.\n    var best_idx: Int = -1\n    var best_time: Int = -1\n    for i in range(num):\n        @parameter\n        fn wrapper():\n            fns.load(i)(lhs, rhs, result, N)\n        let cur_time = benchmark.run[wrapper](1, max_runtime_secs=0.5).mean(\"ns\").to_int()\n        if best_idx < 0 or best_time > cur_time:\n            best_idx = i\n            best_time = cur_time\n        print(\"time[\", i, \"] =\", cur_time)\n    print(\"selected:\", best_idx)\n    return best_idx\n\nfn buffer_elementwise_add[\n    dt: DType\n](lhs: DTypePointer[dt], rhs: DTypePointer[dt], result: DTypePointer[dt], N: Int):\n    # Forward declare the result parameter.\n    alias best_impl: fn(DTypePointer[dt], DTypePointer[dt], DTypePointer[dt], Int) -> None\n\n    # Perform search!\n    search[\n      fn(DTypePointer[dt], DTypePointer[dt], DTypePointer[dt], Int) -> None,\n      buffer_elementwise_add_impl[dt],\n      elementwise_evaluator[dt] -> best_impl\n    ]()\n\n    # Call the select implementation\n    best_impl(lhs, rhs, result, N)\n--- cell type: markdown ---\nWe can now call our function as usual:\n--- cell type: code ---\nlet N = 32\nlet a = DTypePointer[DType.float32].alloc(N)\nlet b = DTypePointer[DType.float32].alloc(N)\nlet res = DTypePointer[DType.float32].alloc(N)\n# Initialize arrays with some values\nfor i in range(N):\n    a.store(i, 2.0)\n    b.store(i, 40.0)\n    res.store(i, -1)\n\nbuffer_elementwise_add[DType.float32](a, b, res, N)\nprint(a.load(10), b.load(10), res.load(10))\n--- cell type: markdown ---\nWhen compiling instantiations of this code, Mojo forks compilation of this\nalgorithm and decides which value to use by measuring what works best in\npractice for the target hardware. It evaluates the different values of the\n`vector_len` expression and picks the fastest one according to a user-defined\nperformance evaluator. Because it measures and evaluates each option\nindividually, it might pick a different vector length for `float32` than for\n`int8`, for example. This simple feature is pretty powerful—going beyond simple\ninteger constants—because functions and types are also parameter expressions.\n\nNotice that the search for the best vector length is performed by the\n[`search()`](https://docs.modular.com/mojo/stdlib/autotune/autotuning.html#search)\nfunction. `search()` takes an evaluator and a forked function and returns the\nfastest implementation selected by the evaluator as a parameter result. For a\ndeeper dive on this topic, check out the notebooks about [Matrix\nMultiplication](https://docs.modular.com/mojo/notebooks/Matmul.html) and [Fast\nMemset in Mojo](https://docs.modular.com/mojo/notebooks/Memset.html).\n\nAutotuning is an inherently exponential technique that benefits from internal\nimplementation details of the Mojo compiler stack (particularly MLIR, integrated\ncaching, and distribution of compilation). This is also a power-user feature and\nneeds continued development and iteration over time."
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/manual/python/index.ipynb",
        "content": "--- cell type: markdown ---\nOur long-term goal is to make Mojo a *superset of Python* (that is, to make Mojo \ncompatible with existing Python programs). Python programmers should be able to\nuse Mojo immediately, and be able to access the huge ecosystem of Python \npackages that are available today. \n\nHowever, Mojo is still in early development and many Python features are not yet\nimplemented. You can't currently write everything in Mojo that you can write in\nPython. And Mojo doesn't have its own ecosystem of packages yet.\n\nTo help bridge this gap, Mojo lets you import Python modules, call Python \nfunctions and interact with Python objects from Mojo code. It runs Python code\nusing a standard Python interpreter (CPython), so your existing Python code\ndoesn't need to change.\n\n## Import a Python module\n\nTo import a Python module in Mojo, just call \n[`Python.import_module()`](/mojo/stdlib/python/python.html#import_module) \nwith the module name:\n--- cell type: code ---\nfrom python import Python\n\nfn use_array() raises:\n    # This is equivalent to Python's `import numpy as np`\n    let np = Python.import_module(\"numpy\")\n\n    # Now use numpy as if writing in Python\n    let array = np.array([1, 2, 3])\n    print(array)\n--- cell type: code ---\nuse_array()\n--- cell type: markdown ---\nYes, this imports Python NumPy, and you can import *any other Python module*\nthat you have installed.\n\nA few things to note:\n\n- Currently, you cannot import individual members (such as a single Python class\n  or function)—you must import the whole Python module and then access members\n  through the module name.\n\n- Mojo doesn't yet support top-level code, so the `import_module()` call must\n  be inside another method. This means you may need to import a module multiple\n  times or pass around a reference to the module. This works the same way as \n  Python: importing the module multiple times won't run the initialization\n  logic more than once, so you don't pay any performance penalty.\n\n- `import_module()` may raise an exception (for example, if the module isn't\n  installed). If you're using it inside an `fn` function, you need to either\n  handle errors (using a `try/except` clause), or add the `raises` keyword to\n  the function signature. You'll also see this when calling Python functions\n  that may raise exceptions. (Raising exceptions is much more common in Python\n  code than in the Mojo standard library, which \n  [limits their use for performance reasons](/mojo/roadmap.html#the-standard-library-has-limited-exceptions-use).)\n\n:::{.callout-note}\n\n**Note:** Mojo loads the Python interpreter and Python modules at runtime, so\nwherever you run a Mojo program, it must be able to access a compatible Python\ninterpreter, and to locate any imported Python modules. For more information,\nsee [Python environment](#python-environment).\n\n:::\n--- cell type: markdown ---\n### Import a local Python module\n\nIf you have some local Python code you want to use in Mojo, just add\nthe directory to the Python path and then import the module.\n\nFor example, suppose you have a Python file named `mypython.py`:\n\n```{.python filename=\"mypython.py\"}\nimport numpy as np\n\ndef gen_random_values(size, base):\n    # generate a size x size array of random numbers between base and base+1\n    random_array = np.random.rand(size, size)\n    return random_array + base\n```\n\nHere's how you can import it and use it in a Mojo file:\n\n```{.mojo filename=\"main.mojo\"}\nfrom python import Python\n\nfn main() raises:\n    Python.add_to_path(\"path/to/module\")\n    let mypython = Python.import_module(\"mypython\")\n\n    let values = mypython.gen_random_values(2, 3)\n    print(c)\n```\n\nBoth absolute and relative paths work with \n[`add_to_path()`](/mojo/stdlib/python/python.html#add_to_path). For example, you\ncan import from the local directory like this:\n\n```mojo\nPython.add_to_path(\".\")\n```\n\n## Call Mojo from Python\n\nAs shown above, you can call out to Python modules from Mojo. However, there's \ncurrently no way to do the reverse—import Mojo modules from Python or call Mojo\nfunctions from Python.\n\nThis may present a challenge for using certain modules. For example, many UI \nframeworks have a main event loop that makes callbacks to user-defined code\nin response to UI events. This is sometimes called an \"inversion of control\" \npattern. Instead of your application code calling *in* to a library, the \nframework code calls *out* to your application code.\n\nThis pattern doesn't work because you can't pass Mojo callbacks to a Python \nmodule.\n\nFor example, consider the popular [Tkinter package](https://docs.python.org/3/library/tkinter.html). \nThe typical usage for Tkinter is something like this:\n\n- You create a main, or \"root\" window for the application.\n- You add one or more UI widgets to the window. The widgets can have associated\n  callback functions (for example, when a button is pushed).\n- You call the root window's `mainloop()` method, which listens for events, \n  updates the UI, and invokes callback functions. The main loop keeps running\n  until the application exits.\n\nSince Python can't call back into Mojo, one alternative is to have the Mojo\napplication drive the event loop and poll for updates. The following example\nuses Tkinter, but the basic approach can be applied to other packages.\n\nFirst we create a Python module that defines a Tkinter interface, with a window\nand single button:\n--- cell type: code ---\n%%python\nimport tkinter as tk\n\nclass App:\n    def __init__(self):\n        self._root = tk.Tk()\n        self.clicked = False\n\n    def click(self):\n        self.clicked = True\n\n    def create_button(self, button_text: str):\n        button = tk.Button(\n            master=self._root,\n            text=button_text,\n            command=self.click\n        )\n        button.place(relx=0.5, rely=0.5, anchor=tk.CENTER)\n\n    def create(self, res: str):\n        self._root.geometry(res)\n        self.create_button(\"Hello Mojo!\")\n\n    def update(self):\n        self._root.update()\n--- cell type: markdown ---\nWe can call this module from Mojo like this:\n--- cell type: code ---\nfrom python import Python\n\nfn button_clicked():\n    print(\"Hi from a Mojo🔥 fn!\")\n\ndef main():\n    Python.add_to_path(\".\")\n    let app = Python.import_module(\"myapp\").App()\n    app.create(\"800x600\")\n\n    while True:\n        app.update()\n        if app.clicked:\n            button_clicked()\n            app.clicked = False\n--- cell type: markdown ---\nInstead of the Python module calling the Tkinter `mainloop()` method, the Mojo \ncode calls the `update()` method in a loop and checks the `clicked` attribute \nafter each update.\n\n## Python environment\n\nThe Mojo SDK depends on an existing installed version of Python that includes\na shared library version of the Python interpreter. When you install the Mojo\nSDK, it tries to locate a compatible version of the Python interpreter and set\nup Python's `sys.path` to load matching modules. In most cases this just works\nand you don't have to do any further configuration of your Python environment. \n\nIf you run into problems after installing Mojo, see the following sections.\n\n### Installation issues\n\nWhen the installer runs, it tries to locate the CPython shared library using the \n[find_libpython](https://pypi.org/project/find-libpython/) module.\n\nThis may fail if one of the following is true:\n\n- There is no version of Python installed, or the installed version isn't\n  supported by the Mojo SDK.\n\n- The installer can't find a shared library version of the CPython interpreter \n  (for example, `.so` or `.dylib` file). Some Python distributions don't include\n  shared libraries, which prevents Mojo from embedding the interpreter.\n\nIf one of these things is the case, you'll need to install a compatible version\nof Python that includes shared libraries. Try following the instructions in \n[Set up a Python environment with Conda](#set-up-a-python-environment-with-conda)\nto install a virtual environment. \n\n### Set up a Python environment with Conda\n\nUsing a Python virtual environment like \n[Conda](https://docs.conda.io/en/latest/) is one way to avoid problems with \nyour Python installation. This provides a consistent Python environment with a\nknown version of Python and all of the Python packages you want to use with\nMojo.\n\nTo set up a virtual environment with Conda:\n\n1. Install Conda by following the \n   [Quick command-line install instructions](https://docs.conda.io/projects/miniconda/en/latest/#quick-command-line-install).\n\n   Make sure to initialize Conda for the shell or shells you use, for example:\n\n   ```bash\n   ~/miniconda3/bin/conda init zsh\n   ```\n\n   Or:\n\n   ```bash\n   ~/miniconda3/bin/conda init --all\n   ```\n\n2. Restart your shell. \n\n3. Run the following command to configure Mojo to use the Python shared library\n   from your Conda environment:\n\n   ```bash\n   export MOJO_PYTHON_LIBRARY=\"$(find $CONDA_PREFIX/lib -iname 'libpython*.[s,d]*' | sort -r | head -n 1)\"\n   echo \"export MOJO_PYTHON_LIBRARY=$MOJO_PYTHON_LIBRARY\" >> ~/.zshrc\n   ```\n\n   **Note:** If you're using a shell other than zsh, you'll need to adjust these\n   commands. For example, if you're using bash, replace `.zshrc` with the\n   shell configuration file you use, such as `.bashrc` or `.bash_profile`.\n\n4. Try running the Mojo REPL:\n\n   ```bash\n   mojo\n   ```\n\nAfter setting up the Conda virtual environment, you can install any Python \npackages you want to use with Mojo using the `conda install` command. For\nexample:\n\n```bash\nconda install numpy\n```\n\nFor more information on using Conda with Mojo, see \n[Using Mojo with Python](https://www.modular.com/blog/using-mojo-with-python) on\nthe Modular Blog."
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/manual/python/types.ipynb",
        "content": "--- cell type: markdown ---\nWhen calling Python methods, Mojo needs to convert back and forth between native\nPython objects and native Mojo objects. Most of these conversions happen\nautomatically, but there are a number of cases that Mojo doesn't handle yet.\nIn these cases you may need to do an explicit conversion, or call an extra\nmethod.\n\n## Mojo types in Python\n\nMojo primitive types implicitly convert into Python objects.\nToday we support lists, tuples, integers, floats, booleans, and strings.\n\nFor example, given this Python function that prints Python types:\n--- cell type: code ---\n%%python\ndef type_printer(value):\n    print(type(value))\n--- cell type: markdown ---\n(You can ignore the `%%python` at the start of the code sample; it's explained\nin the note below.)\n\nYou can pass this Python function Mojo types with no problem:\n--- cell type: code ---\ntype_printer(4)\ntype_printer(3.14)\ntype_printer((\"Mojo\", True))\n--- cell type: markdown ---\n:::{.callout-note}\n\n**Note:** This is a simplified code example written as a set of Jupyter\nnotebook cells. The first cell includes the `%%python` directive so it's\ninterpreted as Python. The second cell includes top-level Mojo code. You'd need\nto adjust this code to run it elsewhere.\n\n:::\n--- cell type: markdown ---\n## Python types in Mojo\n\nYou can also use Python objects from Mojo. For example, Mojo doesn't have a\nstandard dictionary type yet, but you can work with Python dictionaries in Mojo. \nTo create a Python dictionary, use the \n[`dict()`](/mojo/stdlib/python/python.html#dict) method:\n--- cell type: code ---\nfrom python import Python\n\nfn use_dict() raises:\n    let dictionary = Python.dict()\n    dictionary[\"fruit\"] = \"apple\"\n    dictionary[\"starch\"] = \"potato\"\n    print(\"Fruit: \", dictionary[\"fruit\"])\n--- cell type: markdown ---\n### Mojo wrapper objects\n\nWhen you use Python objects in your Mojo code, Mojo adds the \n[`PythonObject`](/mojo/stdlib/python/object.html#pythonobject) wrapper around\nthe Python object. This object exposes a number of common double underscore\nmethods (dunder methods) like `__getitem__()` and `__getattr__()`, passing them\nthrough to the underlying Python object. \n--- cell type: markdown ---\nYou can explicitly create a wrapped Python object by initializing a \n`PythonObject` with a Mojo literal:\n--- cell type: code ---\nfrom python.object import PythonObject\n\nlet pyList: PythonObject = [1, 2, 3, 4]\n--- cell type: markdown ---\nMost of the time, you can treat the wrapped object just like you'd treat it in \nPython. You can use Python's `[]` operators to access an item in a list, and use\ndot-notation to access attributes and call methods. For example:\n--- cell type: code ---\nvar n = pyList[2]\npyList.append(5)\n--- cell type: markdown ---\n\nIf you want to construct a Python type that doesn't have a literal Mojo \nequivalent, you can also use the \n[`Python.evaluate()`](/mojo/stdlib/python/python.html#evaluate) method. For\nexample, to create a Python `set`:\n--- cell type: code ---\nfn use_py_set() raises:\n    let pySet = Python.evaluate('set([2, 3, 5, 7, 11])')\n    let num_items = int(pySet.__len__())\n    print(num_items, \" items in set.\")  # prints \"5 items in set\"\n    print(pySet.__contains__(6))        # prints \"False\"\n--- cell type: markdown ---\nIn the previous exmaple, the `pySet.__len__()` method returns a `PythonObject` \nholding an integer. The `int()` built-in function returns a Mojo integer. In \nPython you'd usually write this as `len(pySet)`. This is a TODO item: the Mojo \ncode requires this temporary workaround because Mojo's `len()` built-in doesn't\nsupport Python objects yet.\n\nLikewise, Mojo doesn't support the `in` operator yet, so you need to use the \n`__contains__()` method instead.\n\nSome Mojo APIs handle `PythonObject` just fine, but sometimes you'll need to \nexplicitly convert a Python value into a native Mojo value. \n\nCurrently `PythonObject` conforms to the \n[`Intable`](/mojo/stdlib/builtin/int.html#intable) and \n[`Stringable`](/mojo/stdlib/builtin/str.html#stringable) traits, which means you\ncan  convert Python values to Mojo `Int` and `String` types using the built-in \n[`int`](/mojo/stdlib/builtin/int.html#int-1) and\n[`str`](/mojo/stdlib/builtin/str.html#str) functions, and print Python values\nusing the built-in [`print()`](/mojo/stdlib/builtin/io.html#print) function.\n  \n`PythonObject` also provides the\n[`__bool__()`](/mojo/stdlib/python/object.html#bool__) and \n[`to_float64()`](/mojo/stdlib/python/object.html#to_float64) methods for \nconverting to boolean and floating point values, respectively.\n\n```mojo\nlet i: Int = int(pyInt)\nlet s: String = str(pyString)\nlet b: Bool = pyBool.__bool__()\nlet f: Float64 = pyFloat.to_float64()\n```\n\n:::{.callout-note}\n\n**Note:** We mentioned that Python types get wrapped in `PythonObject` wrapper. \nThere is currently one exception to this: Python dictionaries have their own\nspecialized Mojo wrapper type, `Dictionary`. Despite the name, it's not a true\ndictionary type, just another kind of wrapper. Most of the time this is\njust an implementation detail, but you may notice that the types are different.\n\n:::\n\n### Comparing Python types in Mojo\n\nIn conditionals, Python objects act like you'd expect them to: Python values \nlike `False` and `None` evaluate as false in Mojo, too.\n\nIf you need to know the type of the underlying Python object, you can use the \n[`Python.type()`](/mojo/stdlib/python/python.html#type) method, which is \nequivalent to the Python `type()` builtin. You can compare the identity of two\nPython objects using the\n[`Python.is_type()`](/mojo/stdlib/python/python.html#is_type) method (which is\nequivalent to the Python `is` operator):\n--- cell type: code ---\nfn python_types() raises:\n    from python import Python\n    from python.object import PythonObject\n\n    let value1: PythonObject = 3.7\n    let value2 = Python.evaluate(\"10/3\")\n    let floatType = Python.evaluate(\"float\")\n\n    print(Python.is_type(Python.type(value1), Python.type(value2))) # True\n    print(Python.is_type(Python.type(value1), floatType))           # True\n    print(Python.is_type(Python.type(value1), Python.none()))       # False\n--- cell type: markdown ---\nA couple of TODO items here: Mojo currently can't print a Python `type` object.\nAnd the `Python.is_type()` method is misleadingly named, since it doesn't\ncompare _types_, but object identity.\n\n## Further reading\n\nFor more information, see \n[Using Mojo with Python](https://www.modular.com/blog/using-mojo-with-python) on \nthe Modular Blog."
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/manual/structs.ipynb",
        "content": "--- cell type: markdown ---\nA Mojo struct is a data structure that allows you to encapsulate fields and\nmethods that operate on an abstraction, such as a data type or an object.\n**Fields** are variables that hold data relevant to the struct, and **methods**\nare functions inside a struct that generally act upon the field data.\n\nFor example, if you're building a graphics program, you can use a struct to\ndefine an `Image` that has fields to store information about each image\n(such as the pixels) and methods that perform actions on it (such as rotate\nit).\n\nFor the most part, Mojo's struct format is designed to provide a static,\nmemory-safe data structure for high-level data types used in programs. For\nexample, all the data types in Mojo's standard library (such as `Int`,\n`Bool`, `String`, and `Tuple`) are defined as structs.\n\nIf you understand how [functions](/mojo/manual/functions.html) and\n[variables](/mojo/manual/variables.html) work in Mojo, you probably\nnoticed that Mojo is designed to provide dynamic programming features in a\n`def` function while enforcing stronger code safety in `fn` functions. When it\ncomes to structs, Mojo leans toward the safe side: You can still choose whether\nto use either `def` or `fn` declarations for methods, but all fields must be\ndeclared with `var` (currently, structs do not support fields declared with\n`let`).\n--- cell type: markdown ---\n## Struct definition\n\nYou can define a simple struct called `MyPair` with two fields like this:\n--- cell type: code ---\nstruct MyPair:\n    var first: Int\n    var second: Int\n--- cell type: markdown ---\nHowever, you can't instantiate this struct because it has no constructor\nmethod. So here it is with a constructor to initialize the two fields:\n--- cell type: code ---\nstruct MyPair:\n    var first: Int\n    var second: Int\n\n    fn __init__(inout self, first: Int, second: Int):\n        self.first = first\n        self.second = second\n--- cell type: markdown ---\n:::{.callout-note}\n\n**Note:** You cannot assign a value to a field outside of a method.\n\n:::\n\nNow we can create an instance of `MyPair` and set the fields:\n--- cell type: code ---\nlet mine = MyPair(2,4)\nprint(mine.first)\n--- cell type: markdown ---\nNotice that the first argument in the `__init__()` method is `inout self`. For\nnow, ignore `inout` (it's an [argument\nconvention](/mojo/manual/values/ownership.html#argument-conventions) that\ndeclares `self` is a mutable reference); all you need to know right now is that\n`self` must be the first argument. It references the current struct instance\n(it allows code in the method to refer to \"itself\"). When you call the\nconstructor, you never pass a value for `self`—Mojo passes it in automatically.\n\nThe `__init__()` method is one of many [special methods](#special-methods)\n(also known as \"dunder methods\" because they have *d*ouble *under*scores) with\npre-determined names.\n\nOf course, you can add any other method you want to your struct (without\nthe double underscores—those are only for special methods defined by Mojo). For\nexample:\n--- cell type: code ---\nstruct MyPair:\n    var first: Int\n    var second: Int\n\n  fn __init__(inout self, first: Int, second: Int):\n      self.first = first\n      self.second = second\n\n  fn get_sum(self) -> Int:\n      return self.first + self.second\n--- cell type: code ---\nlet mine = MyPair(6, 8)\nprint(mine.get_sum())\n--- cell type: markdown ---\nNotice that `get_sum()` also uses the `self` argument, because this is\nthe only way you can access the struct's fields in a method. The name `self` is\njust a convention, and you can use any name you want to refer to the struct\nthat is always passed as the first argument.\n\n:::{.callout-note}\n\n**Note:** The `self` argument in a struct method is the only argument in an\n`fn` function that does not require a type. You can include it if you want, but\nyou can elide it because Mojo already knows its type (`MyPair` in this case).\n\n:::\n--- cell type: markdown ---\n## Structs compared to classes\n\nIf you're familiar with other object-oriented languages, then structs might\nsound a lot like classes, and there are some similarities, but also some\nimportant differences. Eventually, Mojo will also support classes to match the\nbehavior of Python classes.\n\nSo, let's compare Mojo structs to Python classes. They both support methods,\nfields, operator overloading, decorators for metaprogramming, and more, but\ntheir key differences are as follows:\n\n- Python classes are dynamic: they allow for dynamic dispatch, monkey-patching\n(or “swizzling”), and dynamically binding instance fields at runtime.\n\n- Mojo structs are static: they are bound at compile-time (you cannot add\nmethods at runtime). Structs allow you to trade flexibility for performance\nwhile being safe and easy to use.\n\n- Mojo structs do not support inheritance (\"sub-classing\"), but a struct can\n  implement traits (TODO).\n\nSyntactically, the biggest difference compared to a Python class is that all\nfields in a struct must be explicitly declared with `var` (currently, structs\ndo not support fields declared with `let`).\n\nIn Mojo, the structure and contents of a struct are set at compile time and\ncan’t be changed while the program is running. Unlike in Python, where you can\nadd, remove, or change attributes of an object on the fly, Mojo doesn’t allow\nthat for structs.\n\nHowever, the static nature of structs helps Mojo run your code faster. The\nprogram knows exactly where to find the struct’s information and how to use it\nwithout any extra steps or delays at runtime.\n\nMojo’s structs also work really well with features you might already know from\nPython, like operator overloading (which lets you change how math symbols like\n`+` and `-` work with your own data, using [special\nmethods](#special-methods)).\n\nAs mentioned above, all Mojo's standard types\n(`Int`, `String`, etc.) are made using structs, rather than being hardwired\ninto the language itself. This gives you more flexibility and control when\nwriting your code, and it means you can define your own types with all the same\ncapabilities (there's no special treatment for the standard library types).\n--- cell type: markdown ---\n## Special methods\n\nSpecial methods (or \"dunder methods\") such as `__init__()` are pre-determined\nmethod names that you can define in a struct to perform a special task.\n\nAlthough it's possible to call special methods with their method names, the\npoint is that you never should, because Mojo automatically invokes them in\ncircumstances where they're needed (which is why they're also called \"magic\nmethods\"). For example, Mojo calls the `__init__()` method when you instantiate\nan instance of the struct by name; and when Mojo destroys the instance, it\ncalls the `__del__()` method (if it exists).\n\nEven operator behaviors that appear built-in (`+`, `<`, `==`, `|`, and so on)\nare implemented as special methods that Mojo implicitly calls upon to perform\noperations or comparisons on the type that the operator is applied to.\n\nMojo supports a long list of special methods; far too many to discuss here, but\nthey generally match all of [Python's special\nmethods](https://docs.python.org/3/reference/datamodel.html#special-method-names)\nand they usually accomplish one of two types of tasks:\n\n- Operator overloading: A lot of special methods are designed to overload\n  operators such as `<` (less-than), `+` (add), and `|` (or) so they work\n  appropriately with each type. For example, look at the methods listed for Mojo's\n  [`Int` type](/mojo/MojoBuiltin/Int.html). One such method is `__lt__()`, which\n  Mojo calls to perform a less-than comparison between two integers (for example,\n  `num1 < num2`).\n\n- Lifecycle event handling: These special methods deal with the lifecycle and\n  value ownership of an instance. For example, `__init__()` and `__del__()`\n  demarcate the beginning and end of an instance lifetime, and other special\n  methods define the behavior for other lifecycle events such as how to copy or\n  move a value.\n\nYou can learn all about the lifecycle special methods in the section about\n[Value lifecycle](/mojo/manual/lifecycle/). However, most structs are simple\naggregations of other types, so unless your type requires custom behaviors when\nan instance is copied, moved, or destroyed, you synthesize the essential\nlifecycle methods you need (and save yourself some time) by adding the `@value`\ndecorator.\n\n--- cell type: markdown ---\n### `@value` decorator\n\nWhen you add the [`@value` decorator](/mojo/manual/decorators/value.html) to a\nstruct, Mojo will synthesize the essential lifecycle methods so your object\nprovides full value semantics. Specifically, it generates the `__init__()`,\n`__copyinit__()`, and `__moveinit__()` methods, which allow you to construct,\ncopy, and move your struct type in a manner that's value semantic and\ncompatible with Mojo's ownership model.\n\nFor example:\n--- cell type: code ---\n@value\nstruct MyPet:\n    var name: String\n    var age: Int\n--- cell type: markdown ---\nMojo will notice that you don't have a member-wise initializer, a move\nconstructor, or a copy constructor, and it will synthesize these for you as if\nyou had written:\n--- cell type: code ---\nstruct MyPet:\n    var name: String\n    var age: Int\n\n    fn __init__(inout self, owned name: String, age: Int):\n        self.name = name^\n        self.age = age\n\n    fn __copyinit__(inout self, existing: Self):\n        self.name = existing.name\n        self.age = existing.age\n\n    fn __moveinit__(inout self, owned existing: Self):\n        self.name = existing.name^\n        self.age = existing.age\n--- cell type: markdown ---\nWithout the copy and move constructors, the following code would not work\nbecause Mojo would not know how to copy an instance of `MyPet`:\n--- cell type: code ---\nlet dog = MyPet(\"Charlie\", 5)\nlet poodle = dog\nprint(poodle.name)\n--- cell type: markdown ---\nWhen you add the `@value` decorator, Mojo synthesizes each special method above\nonly if it doesn't exist already. That is, you can still implement a custom\nversion of each method methods.\n\nIn addition to the `inout` argument convention you already saw with\n`__init__()`, this code also introduces `owned`, which is another argument\nconvention that ensures the argument has unique ownership of the value.\nFor more detail, see the section about [value\nownership](/mojo/manual/values/ownership.html).\n"
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/manual/traits.ipynb",
        "content": "--- cell type: markdown ---\nA _trait_ is a set of requirements that a type must implement. You can think of\nit as a contract: a type that _conforms_ to a trait guarantees that it \nimplements all of the features of the trait.\n\nTraits are similar to Java _interfaces_, C++ _concepts_, Swift _protocols_, and\nRust _traits_. If you're familiar with any of those features, Mojo traits solve\nthe same basic problem.\n\n## Background\n\nIn dynamically-typed languages like Python, you don't need to explicitly declare\nthat two classes are similar. This is easiest to show by example:\n--- cell type: code ---\n%%python\nclass Duck:\n    def quack(self):\n        print(\"Quack.\")\n\nclass StealthCow:\n    def quack(self):\n        print(\"Moo!\")\n\ndef make_it_quack_python(maybe_a_duck):\n    try:\n        maybe_a_duck.quack()\n    except:\n        print(\"Not a duck.\")\n\nmake_it_quack_python(Duck())\nmake_it_quack_python(StealthCow())\n--- cell type: markdown ---\nThe `Duck` and `StealthCow` classes aren't related in any way, but they both \ndefine a `quack()` method, so they work the same in the `make_it_quack()`\nfunction. This works because Python uses dynamic dispatch—it identifies the\nmethods to call at runtime. So `make_it_quack_python()` doesn't care what types\nyou're passing it, only the fact that they implement the `quack()` method.\n\nIn a statically-typed environment, this approach doesn't work:\n[`fn` functions](/mojo/manual/functions.html#fn-functions) require you to\nspecify the type of each argument. If you wanted to write this example in Mojo \n_without_ traits, you'd need to write a function overload for each input type.\nAll of the examples from here on are in Mojo, so we'll just call the function\n`make_it_quack()` going forward.\n--- cell type: code ---\n@value\nstruct Duck:\n    fn quack(self):\n        print(\"Quack\")\n\n@value\nstruct StealthCow:\n    fn quack(self):\n        print(\"Moo!\")\n\nfn make_it_quack(definitely_a_duck: Duck):\n    definitely_a_duck.quack()\n\nfn make_it_quack(not_a_duck: StealthCow):\n    not_a_duck.quack()\n\nmake_it_quack(Duck())\nmake_it_quack(StealthCow())\n--- cell type: markdown ---\nThis isn't too bad with only two classes. But the more classes you want to\nsupport, the less practical this approach is.\n\nYou might notice that the Mojo versions dosn't include the `try/except` \nstatement. We don't need it because Mojo's static type checking ensures that\nyou can only pass instances of `Duck` or `StealthCow` into the `make_it_quack()`\nfunction.\n\n## Using traits\n\nTraits solve this problem by letting you define a shared set of _behaviors_ that\ntypes can implement. Then you can write a function that depends on the trait,\nrather than individual types. As an example, let's update the `make_it_quack()`\nexample using traits. The first step is defining a trait:\n--- cell type: code ---\ntrait Quackable:\n    fn quack(self):\n        ...\n--- cell type: markdown ---\nA trait looks a lot like a struct, except it's introduced by the `trait` \nkeyword. Right now, a trait can only contain method signatures, and cannot\ninclude method implementations. Each method signature must be followed by\nthree dots (`...`) to indicate that the method is unimplemented.\n\n:::{.callout-note}\n\n**TODO:** In the future, we plan to support defining fields and default method\nimplementations inside a trait. Right now, though, a trait can only declare\nmethod signatures.\n\n:::\n\nNext we create some structs that conform to the `Quackable` trait. To indicate\nthat a struct conforms to a trait, include the trait name in parenthesis after\nthe struct name. You can also include multiple traits, separated by commas. \n(If you're familiar with Python, this looks just like Python's inheritance\nsyntax.)\n--- cell type: code ---\n@value\nstruct Duck(Quackable):\n    fn quack(self):\n        print(\"Quack\")\n\n@value\nstruct StealthCow(Quackable):\n    fn quack(self):\n        print(\"Moo!\")\n--- cell type: markdown ---\nThe struct needs to implement any methods that are declared in the trait. The \ncompiler enforces conformance: if a struct says it conforms to a trait, it must\nimplement everything required by the trait or the code won't compile.\n\nFinally, you can define a function that takes a `Quackable` like this:\n--- cell type: code ---\nfn make_it_quack[T: Quackable](maybe_a_duck: T):\n    maybe_a_duck.quack()\n--- cell type: markdown ---\nThis syntax may look a little unfamiliar if you haven't dealt with Mojo\n[parameters](/mojo/manual/parameters/index.html) before. What this signature\nmeans is that `maybe_a_duck` is an argument of type `T`, where `T` is a type\nthat must conform to the `Quackable` trait. TODO: This syntax is a little \nverbose, and we hope to make it more ergonomic in a future release.\n\nUsing the method is simple enough:\n--- cell type: code ---\nmake_it_quack(Duck())\nmake_it_quack(StealthCow())\n--- cell type: markdown ---\nNote that you don't need the square brackets when you call `make_it_quack()`: \nthe compiler infers the type of the argument, and ensures the type has the\nrequired trait.\n\nOne limitation of traits is that you can't add traits to existing types. For\nexample, if you define a new `Numeric` trait, you can't add it to the standard\nlibrary `Float64` and `Int` types. However, the standard library already\nincludes a few traits, and we'll be adding more over time.\n\n### Traits can require static methods\n\nIn addition to regular instance methods, traits can specify required static \nmethods. \n\n--- cell type: code ---\ntrait HasStaticMethod:\n    @staticmethod\n    fn do_stuff(): ...\n\nfn fun_with_traits[T: HasStaticMethod]():\n    T.do_stuff()\n--- cell type: markdown ---\n\n\n## Trait inheritance\n\nTraits can inherit from other traits. A trait that inherits from another trait\nincludes all of the requirements declared by the parent trait. For example:\n--- cell type: code ---\ntrait Animal:\n    fn make_sound(self):\n        ...\n\n# Bird inherits from Animal\ntrait Bird(Animal):\n    fn fly(self):\n        ...\n--- cell type: markdown ---\nSince `Bird` inherits from `Animal`, a struct that conforms to the `Bird` trait\nneeds to implement **both** `make_sound()` and `fly()`. And since every `Bird`\nconforms to `Animal`, a struct that conforms to `Bird` can be passed to any\nfunction that requires an `Animal`.\n\nTo inherit from multiple traits, add a comma-separated list of traits inside the \nparenthesis. For example, you could define a `Pet` trait that combines the\nrequirements of the `Animal` trait and a new `Named` trait:\n--- cell type: code ---\ntrait Named:\n    fn get_name(self) -> String:\n        ...\n\ntrait Pet(Animal, Named):\n    pass\n--- cell type: markdown ---\n## Traits and lifecycle methods\n\nTraits can specify required \n[lifecycle methods](/mojo/manual/lifecycle/#lifecycles-and-lifetimes), including\nconstructors, copy constructors and move constructors. \n\nFor example, the following code creates a `MassProducible` trait. A \n`MassProducible` type has a default (no-argument) constructor and can be moved.\nThe `factory[]()` function returns a newly-constructed instance of a \n`MassProducible` type.\n--- cell type: code ---\ntrait DefaultConstructible:\n    fn __init__(inout self): ...\n\ntrait Movable:\n    fn __moveinit__(inout self, owned existing: Self): ...\n\ntrait MassProducible(DefaultConstructible, Movable):\n    pass\n\nfn factory[T: MassProducible]() -> T:\n    return T()\n\nstruct Thing(MassProducible):\n    var id: Int\n\n    fn __init__(inout self):\n        self.id = 0\n\n    fn __moveinit__(inout self, owned existing: Self):\n        self.id = existing.id\n\nlet thing = factory[Thing]()\n--- cell type: markdown ---\nNote that [`@register_passable`](/mojo/manual/decorators/register-passable.html) and [`@register_passable(\"trivial\")`](/mojo/manual/decorators/register-passable.html#register_passabletrivial) \ntypes have restrictions on their lifecycle methods: they define their \nconstructors differently, and trivial types can't define copy or move \nconstructors.\n\nThe compiler implements special rules to ensure that these types can conform \nto traits that require certain lifecycle methods. For example, trivial types are\nalways considered copyable, although they cannot include a copy constructor.\nUnlike a standard constructor, a constructor for a register-passable type is \nstatic (doesn't include a `self` argument) and returns a value. The compiler\nignores these differences when comparing a register-passable constructor to the\nrequired constructors declared in a trait. \n\nSo the following constructor signatures are considered equivalent when \ndetermining whether a type conforms to a trait:\n\n```mojo\n# Standard constructor, as declared in a trait\nfn __init__(self, i: Int):\n# Register-passable constructor\nfn __init__(i Int) -> Self:\n```\n--- cell type: markdown ---\nFor example, the following register-passable type conforms to the \n`DefaultConstructible` trait.\n--- cell type: code ---\n@register_passable\nstruct RegisterPassableType(DefaultConstructible):\n    # This is OK: Traits understand different type conventions.\n    fn __init__() -> Self:\n        return Self {}\n--- cell type: markdown ---\n\n\n## Built-in traits\n\n\n--- cell type: markdown ---\nThe Mojo standard library currently includes a few traits. They're implemented\nby a number of standard library types, and you can also implement these on your\nown types:\n\n  - [`CollectionElement`](/mojo/stdlib/utils/vector.html#collectionelement)\n  - [`Copyable`](/mojo/stdlib/builtin/value.html#copyable)\n  - [`Destructable`](/mojo/stdlib/builtin/destructable.html)\n  - [`Intable`](/mojo/stdlib/builtin/int.html#intable)\n  - [`Movable`](/mojo/stdlib/builtin/value.html#movable)\n  - [`Sized`](/mojo/stdlib/builtin/len.html#sized)\n  - [`Stringable`](/mojo/stdlib/builtin/str.html#stringable)\n\nThe API reference docs linked above include usage examples for each trait. The\nfollowing sections discuss a few of these traits.\n\n### The `Sized` trait\n\nThe [`Sized`](/mojo/stdlib/builtin/len.html#sized) trait identifies types that\nhave a measurable length, like strings and arrays. \n\nSpecifically, `Sized` requires a type to implement the `__len__()` method. \nThis trait is used by the built-in [`len()`](/mojo/stdlib/builtin/len.html#len) \nfunction. For example, if you're writing a custom vector type, you could \nimplement this trait so your type works with `len()`:\n--- cell type: code ---\nstruct MyVector(Sized):\n    var size: Int\n    # ...\n\n    fn __init__(inout self):\n        self.size = 0\n\n    fn __len__(self) -> Int:\n        return self.size\n\nprint(len(MyVector()))\n--- cell type: markdown ---\n### The `Intable` and `Stringable` traits\n\nThe [`Intable`](/mojo/stdlib/builtin/int.html#intable) and \n[`Stringable`](/mojo/stdlib/builtin/str.html#stringable) traits identify types\nthat can be implicitly converted to `Int` and `String`, respectively. \n\nAny type that conforms to `Stringable` works with the built-in\n[`print()`](/mojo/stdlib/builtin/io.html#print) and \n[`str()`](/mojo/stdlib/builtin/str.html#str) functions:\n--- cell type: code ---\n@value\nstruct Pet(Stringable):\n    var name: String\n    var type: String\n\n    fn __str__(self) -> String:\n        return \"This is a \" + self.type + \" named \" + self.name\n\nlet spot = Pet(\"Spot\", \"dog\")\nprint(spot)\n--- cell type: markdown ---\nSimilarly, an `Intable` type works with the built-in \n[`int`](/mojo/stdlib/builtin/int.html#int-1) function. You can find an example\nin the [`Intable` API reference](/mojo/stdlib/builtin/int.html#intable).\n--- cell type: markdown ---\n\n\n### The `Destructable` trait\n\nWhen building a generic container type, one challenge is knowing how to dispose\nof the contained items when the container is destroyed. Any type that \ndynamically allocates memory needs to supply a \n[destructor](/mojo/manual/lifecycle/death.html#destructor) (`__del__()` method)\nthat must be called to free the allocated memory. But not all types have a \ndestructor, and your Mojo code has no way to determine which is which.\n\nThe [`Destructable`](/mojo/stdlib/builtin/destructable.html) trait solves this\nissue: every trait implicitly inherits from `Destructable`, which guarantees\nthat the type has a destructor. For types that don't have one, Mojo adds a no-op\ndestructor. This means you can call the destructor on any type that implements\na trait. \n\nThis makes it possible to build generic collections without leaking memory. When\nthe collection's destructor is called, it can safely call the destructors on\nevery item it contains.\n\n:::{.callout-note}\n\n**TODO:** This solution means that you can only use elements in a generic\ncontainer if they implement one or more traits. In the future, we're planning to \nmake the no-op destructor part of the `AnyType` metatype and remove the \n`Destructable` trait.\n\nAlso, this trait should probably have been spelled `Destructible`.\n\n:::\n--- cell type: markdown ---\n## Generic structs with traits\n\nYou can also use traits when defining a generic containers. A generic container\nis a container (for example, an array or hashmap) that can hold different data\ntypes. In a dynamic language like Python it's easy to add  different types of\nitems to a container. But in a statically-typed environment the compiler needs\nto be able to identify the types at compile time. For example, if the container\nneeds to copy a value, the compiler needs to verify that the type can be copied.\n\nThe [`DynamicVector`](/mojo/stdlib/utils/vector.html) type is an example of a\ngeneric container. A single `DynamicVector` can only hold a single type of data.\nFor example, you can create a vector of integer values like this:\n--- cell type: code ---\nfrom utils.vector import DynamicVector\n\nvar vector = DynamicVector[Int]()\nvector.append(3)\nvector.append(6)\nvector.append(9)\nfor i in range(len(vector)):\n    print_no_newline(vector[i], \" \")\n--- cell type: markdown ---\nYou can use traits to define requirements for elements that are stored in a\ncontainer. For example, `DynamicVector` requires elements that can be moved and\ncopied. To store a struct in a `DynamicVector`, the struct needs to conform to\nthe `CollectionElement` trait, which requires a \n[copy constructor](/mojo/manual/lifecycle/life.html#copy-constructor) and a \n[move constructor](/mojo/manual/lifecycle/life.html#move-constructor).\n\nBuilding generic containers is an advanced topic. For an introduction, see the\nsection on \n[parameterized structs](/mojo/manual/parameters/#parameterized-structs)."
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/manual/values/index.ipynb",
        "content": "--- cell type: markdown ---\nA program is nothing without data, and all modern programming languages store\ndata in one of two places: the call stack and the heap (also sometimes in CPU\nregisters, but we won't get into that here). However, each language reads and\nwrites data a bit differently—sometimes very differently. So in the following\nsections, we'll explain how Mojo manages memory in your programs and how this\naffects the way you write Mojo code.\n--- cell type: markdown ---\n## Stack and heap overview\n\nIn general, all programming languages use a call stack the same way: When a\nfunction is called, the compiler allocates a block of memory on the stack that\nis exactly the size required to store the execution logic and _fixed-size_\nlocal values. When another function is called, its data is likewise added to\nthe top of the stack. When a function is done, all its data in the stack is\ndestroyed so that memory becomes available for other code.\n\nNotice that we said only \"_fixed-size_ local values\" are stored in the stack.\nAny dynamically-sized values that can change in size at runtime are instead\nstored in the heap, which is a much larger region of memory that allows for\ndynamic memory access at runtime. Technically, a local variable for such a value\nis still stored in the call stack, but its value is a fixed-size pointer to the\nreal value on the heap.\n\nAdditionally, values that need to outlive the lifetime of a function (such as\nan array that's passed between functions and should not be copied) are stored\nin the heap, because heap memory is accessible from anywhere in the call stack,\neven after the function that created it is removed from the stack. This sort of\nsituation—in which a heap-allocated value is used by multiple functions—is where\nmost memory errors occur, and it's where memory management strategies vary the\nmost between programming languages.\n--- cell type: markdown ---\n## Memory management strategies\n\nBecause memory is limited, it's important that programs remove unused data from\nthe heap (\"free\" the memory) as quickly as possible. Figuring out when to free\nthat memory is pretty complicated.\n\nSome programming languages try to hide the complexities of memory management\nfrom you by utilizing a \"garbage collector\" process that tracks all memory\nusage and deallocates unused heap memory periodically (also known as automatic\nmemory management). A significant benefit of this method is that it relieves\ndevelopers from the burden of manual memory management, generally avoiding more\nerrors and making developers more productive. However, it incurs a performance\ncost because the garbage collector interrupts the program's execution, and it\nmight not reclaim memory very quickly.\n\nOther languages require that you manually free data that's allocated on the\nheap. When done properly, this makes programs execute quickly, because there's\nno processing time consumed by a garbage collector. However, the challenge with\nthis approach is that programmers make mistakes, especially when multiple parts\nof the program need access to the same memory—it becomes difficult to know\nwhich part of the program \"owns\" the data and must deallocate it. Programmers\nmight accidentally deallocate data before the program is done with it (causing\n\"use-after-free\" errors), or they might deallocate it twice (\"double free\"\nerrors), or they might never deallocate it (\"leaked memory\" errors). Mistakes\nlike these and others can have catastrophic results for the program, and these\nbugs are often hard to track down, making it especially important that they\ndon't occur in the first place.\n\nMojo uses a third approach called \"ownership\" that relies on a collection of\nrules that programmers must follow when passing values. The rules ensure there\nis only one \"owner\" for each chunk of memory at a time, and that the memory is\ndeallocated accordingly. In this way, Mojo automatically allocates and\ndeallocates heap memory for you, but it does so in a way that's deterministic\nand safe from errors such as use-after-free, double-free and memory leaks. Plus,\nit does so with a very low performance overhead.\n\nMojo's value ownership model provides an excellent balance of programming\nproductivity and strong memory safety. It only requires that you learn some new\nsyntax and a few rules about how to share access to memory within your program.\n\nBut before we explain the rules and syntax for Mojo's value ownership model,\nyou first need to understand [value\nsemantics](/mojo/manual/values/value-semantics.html)."
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/manual/values/ownership.ipynb",
        "content": "--- cell type: markdown ---\nA challenge you might face when using some programming languages is that you\nmust manually allocate and deallocate memory. When multiple parts of the\nprogram need access to the same memory, it becomes difficult to keep track of\nwho \"owns\" a value and determine when is the right time to deallocate it. If\nyou make a mistake, it can result in a \"use-after-free\" error, a \"double free\"\nerror, or a \"leaked memory\" error, any one of which can be catastrophic.\n\nMojo helps avoid these errors by ensuring there is only one variable that owns\neach value at a time, while still allowing you to share references with other\nfunctions. When the lifetime of the owner ends, Mojo [destroys the\nvalue](/mojo/manual/lifecycle/death.html).\n\nOn this page, we'll explain the rules that govern this ownership model and how\nto specify different argument conventions that define how values are shared into\nfunctions.\n--- cell type: markdown ---\n## Argument conventions\n\nIn all programming languages, code quality and performance is heavily dependent\nupon how functions treat argument values. That is, whether a value received by\na function is a unique value or a reference, and whether it's mutable or\nimmutable, has a series of consequences that define the readability,\nperformance, and safety of the language.\n\nIn Mojo, we want to provide full [value\nsemantics](/mojo/manual/values/value-semantics.html) by default, which provides\nconsistent and predictable behavior. But as a systems programming language, we\nalso need to offer full control over memory optimizations, which generally\nrequires reference semantics. The trick is to introduce reference semantics in\na way that ensures all code is memory safe by tracking the lifetime of every\nvalue and destroying each one at the right time (and only once). All of this is\nmade possible in Mojo through the use of argument conventions that ensure every\nvalue has only one owner at a time.\n\nAn argument convention specifies whether an argument is mutable or immutable,\nand whether the function owns the value. Each convention is defined by a\nkeyword at the beginning of an argument declaration:\n\n- `borrowed`: The function receives an **immutable reference**. This means the\n  function can read the original value (it is *not* a copy), but it cannot\n  mutate (modify) it.\n  \n- `inout`: The function receives a **mutable reference**. This means the\n  function can read and mutate the original value (it is *not* a copy).\n  \n- `owned`: The function takes **ownership**. This means the function has\n  exclusive mutable access to the argument—the function caller does not have\n  access to this value (anymore). Often, this also implies that the caller\n  should transfer ownership to this function, but that's not always what\n  happens and this might instead be a copy (as you'll learn below).\n\nFor example, this function has one argument that's a mutable\nreference and one that's immutable:\n--- cell type: code ---\nfn add(inout x: Int, borrowed y: Int):\n    x += y\n\nfn main():\n    var a = 1\n    let b = 2\n    add(a, b)\n    print(a)  # Prints 3\n--- cell type: markdown ---\nYou've probably already seen some function arguments that don't declare a\nconvention. That's because every argument has a default convention, depending\non whether the function is declared with `fn` or `def`:\n\n- All values passed into a Mojo [`def`\n  function](/mojo/manual/functions.html#def-functions) are `owned`,\n  by default. \n\n- All values passed into a Mojo [`fn`\n  function](/mojo/manual/functions.html#fn-functions) are `borrowed`,\n  by default.\n\nIn the following sections, we'll explain each of these argument conventions in\nmore detail.\n--- cell type: markdown ---\n## Ownership summary\n\nThe fundamental rules that make Mojo's ownership model work are the following:\n\n- Every value has only one owner at a time.\n- When the lifetime of the owner ends, Mojo destroys the value.\n\nThe \"borrow checker\" is a process in the Mojo compiler that ensures there is\nonly one owner for each value at any time. It also enforces some other\nmemory-safety rules:\n\n- You cannot create multiple mutable references (`inout`) for the same value.\n  (Multiple immutable references (`borrowed`) are okay.)\n\n- You cannot create a mutable reference (`inout`) if there exists an\n  immutable reference (`borrowed`) for the same value. (TODO: Not currently\n  implemented.)\n\nBecause Mojo does not allow a mutable reference to overlap with another mutable\nor immutable reference, it provides a predictable programming model about which\nreferences are and aren't valid (an invalid reference is one who's lifetime has\nended, perhaps because the value ownership was transferred). Importantly, this\nlogic allows Mojo to immediately [destroy\nvalues](/mojo/manual/lifecycle/death.html) when their lifetime ends.\n--- cell type: markdown ---\n## Immutable arguments (`borrowed`)\n\nIf you'd like your function to receive an **immutable reference**, add the\n`borrowed` keyword in front of the argument name.\n\nThe `borrowed` convention is the default for all arguments in an `fn` function,\nbut you can still specify it to be explicit. It also works on `def` functions,\nwhich otherwise receive arguments by value, which might not be desirable, such\nas when the type is expensive to copy (or not copyable at all) and you just\nneed to read it. For example:\n--- cell type: code ---\nfrom tensor import Tensor, TensorShape\n\ndef print_shape(borrowed tensor: Tensor[DType.float32]):\n    shape = tensor.shape()\n    print(shape.__str__())\n\nlet tensor = Tensor[DType.float32](256, 256)\nprint_shape(tensor)\n--- cell type: markdown ---\nIn general, passing an immutable reference is much more efficient when handling\nlarge or expensive-to-copy values, because the copy constructor and destructor\nare not invoked for a borrow.\n\n### Compared to C++ and Rust\n\nMojo's borrowed argument convention is similar in some ways to passing an\nargument by `const&` in C++, which also avoids a copy of the value and disables\nmutability in the callee. However, the borrowed convention differs from\n`const&` in C++ in two important ways:\n\n- The Mojo compiler implements a borrow checker (similar to Rust) that prevents\ncode from dynamically forming mutable references to a value when there are\nimmutable references outstanding, and it prevents multiple mutable references\nto the same value.\n\n- Small values like `Int`, `Float`, and `SIMD` are passed directly in machine\nregisters instead of through an extra indirection (this is because they are\ndeclared with the `@register_passable` decorator). This is a [significant\nperformance\nenhancement](https://www.forrestthewoods.com/blog/should-small-rust-structs-be-passed-by-copy-or-by-borrow/)\nwhen compared to languages like C++ and Rust, and moves this optimization from\nevery call site to a declaration on the type definition.\n\nSimilar to Rust, Mojo's borrow checker enforces the exclusivity of invariants.\nThe major difference between Rust and Mojo is that Mojo does not require a\nsigil on the caller side to pass by borrow. Also, Mojo is more efficient when\npassing small values, and Rust defaults to moving values instead of passing\nthem around by borrow. These policy and syntax decisions allow Mojo to provide\nan easier-to-use programming model.\n--- cell type: markdown ---\n## Mutable arguments (`inout`)\n\nIf you'd like your function to receive a **mutable reference**, add the `inout`\nkeyword in front of the argument name. You can think of `inout` like this: it\nmeans any changes to the value *in*side the function are visible *out*side the\nfunction.\n\nFor example, this `mutate()` function updates the original `x` value:\n--- cell type: code ---\ndef mutate(inout y: Int):\n    y += 1\n\nvar x = 1\nmutate(x)\nprint(x)\n--- cell type: markdown ---\nThat behaves like an optimized shorthand for this:\n--- cell type: code ---\ndef mutate_copy(y: Int) -> Int:\n    y += 1\n    return y\n\nvar x = 1\nx = mutate_copy(x)\nprint(x)\n--- cell type: markdown ---\nAlthough the code using `inout` isn't that much shorter, it's more memory\nefficient because it does not make a copy of the value.\n\nHowever, remember that the values passed as `inout` must already be mutable.\nFor example, if you change `var x` to `let x`, you'll get a compiler error\nbecause Mojo can't form a mutable reference to an immutable value (`let` makes\nthe variable immutable).\n\n:::{.callout-note}\n\n**Note:** Notice that we don't call this argument passing \"by reference.\"\nAlthough the `inout` convention is conceptually the same, we don't call it\nby-reference passing because the implementation may actually pass values using\npointers.\n\n:::\n\n:::{.callout-note}\n\n**Note:** You cannot define [default\nvalues](/mojo/manual/functions.html#optional-arguments) for `inout`\narguments.\n\n:::\n--- cell type: markdown ---\n## Transfer arguments (`owned` and `^`)\n\nAnd finally, if you'd like your function to receive value **ownership**, add the\n`owned` keyword in front of the argument name.\n\nThis convention is usually combined with use of the postfixed `^` \"transfer\"\noperator on the variable that is passed into the function, which ends the\nlifetime of that variable.\n\nTechnically, the `owned` keyword does not guarantee that the received value is\na mutable reference to _the original value_—it guarantees only that the function\ngets unique ownership of this particular value (enforcing [value\nsemantics](/mojo/manual/values/value-semantics.html)). This happens in one of\ntwo ways:\n\n- The caller passes the argument with the `^` transfer operator, which ends the\nlifetime of that variable (the variable becomes invalid) and ownership is\ntransferred into the function without making a copy of any heap-allocated data.\n\n- The caller **does not** use the `^` transfer operator, in which case, the\nvalue is copied into the function argument and the original variable remains\nvalid (unless it is not used again, in which case the compiler destroys the\nvariable anyway because its lifetime naturally ends there).\n\nRegardless, when the function declares an argument as `owned`, it can be certain\nthat it has unique mutable access to that value. \n\nFor example, the following code works by making a copy of the string,\nbecause—although `take_text()` uses the `owned` convention—the caller does not\ninclude the transfer operator:\n--- cell type: code ---\nfn take_text(owned text: String):\n    text += \"!\"\n    print(text)\n\nfn my_function():\n    let message = \"Hello\"\n    take_text(message)\n    print(message)\n\nmy_function()\n--- cell type: markdown ---\nHowever, if you add the `^` transfer operator when calling `take_text()`, the\ncompiler complains about `print(message)`, because at that point, the `message`\nvariable is no longer initialized. That is, this version does not compile:\n\n```mojo\nfn my_function():\n    let message = \"Hello\"\n    take_text(message^)  \n    print(message)  # ERROR: The `message` variable is uninitialized\n```\n\nThis is a critical feature of Mojo's borrow checker, because it ensures that no\ntwo variables can have ownership of the same value. To fix the error, you must\nnot use the `message` variable after you end its lifetime with the `^` transfer\noperator. So here is the corrected code:\n--- cell type: code ---\n\nfn my_function():\n    let message = \"Hello\"\n    take_text(message^)\n\nmy_function()\n--- cell type: markdown ---\n:::{.callout-note}\n\n**Note:** Value lifetimes are not fully implemented for top-level code in\nMojo's REPL, so the transfer operator currently works as intended only when\nused inside a function.\n\n:::\n--- cell type: markdown ---\n### Transfer implementation details\n\nIn Mojo, it's important that you not conflate \"ownership transfer\" with a \"move\noperation\"—these are not stricly the same thing. \n\nThere are multiple ways that Mojo can transfer ownership of a value without\nmaking a copy:\n\n- If a type implements the `__moveinit__()` method for\n  [consuming-moves](/mojo/manual/lifecycle/life.html#consuming-move-constructor),\n  Mojo may invoke this method _if_ a value of that type is transferred into a\n  function as an `owned` argument, _and_ the original value's lifetime ends at\n  the same point (with or without use of the `^` transfer operator).\n\n- If a type implements the `__takeinit__()` method for\n  [taking-moves](/mojo/manual/lifecycle/life.html#taking-move-constructor),\n  Mojo may invoke this method _if_ a value of that type is transferred into\n  a function as an `owned` argument, _and_ the original value's lifetime ends at\n  the same point (with or without use of the `^` transfer operator), _and_ the\n  type does not implement `__moveinit__()`.\n\n- If a type has implemented neither `__moveinit__()` nor `__takeinit__()`,\n  Mojo may transfer ownership by simply passing the recipient a reference to\n  the value in the caller's stack.\n\nIn order for the `owned` convention to work _without_ the transfer\noperator, the value type must be copyable (via `__copyinit__()`).\n--- cell type: markdown ---\n## Comparing `def` and `fn` argument conventions\n\nAs mentioned in the section about\n[functions](/mojo/manual/functions.html), the `def` and `fn` functions\nare interchangeable, as far as a caller is concerned, and they can both\naccomplish the same things. It's only the inside that differs, and Mojo's `def`\nfunction is essentially just sugaring for the `fn` function:\n\n- A `def` argument without a type annotation defaults to\n  [`object`](/mojo/MojoStdlib/Object.html#object) type (whereas as `fn`\n  requires all types be explicitly declared).\n\n- A `def` argument without a convention keyword (`borrowed`, `inout`, or\n  `owned`) defaults to `owned` (it receives a copy with a mutable variable).\n\nFor example, these two functions have the exact same behavior:\n--- cell type: code ---\ndef example(borrowed a: Int, inout b: Int, c):\n    pass\n\nfn example(a: Int, inout b: Int, owned c: object):\n    pass\n--- cell type: markdown ---\nOr, instead of specifying `owned` for the `c` argument, you can get the same\neffect by manually making a copy when you need it:\n--- cell type: code ---\nfn example(a: Int, inout b: Int, c_in: object):\n    var c = c_in\n    pass\n--- cell type: markdown ---\nThis shadow copy typically adds no overhead, because references for small types\nlike `object` are cheap to copy. The expensive part is adjusting the reference\ncount, but that's also eliminated by a compiler optimization."
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/manual/values/value-semantics.ipynb",
        "content": "--- cell type: markdown ---\nMojo doesn't enforce value semantics or reference semantics. It supports them\nboth and allows each type to define how it is created, copied, and moved (if at\nall). So, if you're building your own type, you can implement it to support\nvalue semantics, reference semantics, or a bit of both. That said, Mojo is\ndesigned with argument behaviors that default to value semantics, and it\nprovides tight controls for reference semantics that avoid memory errors.\n\nThe controls over reference semantics are provided by the [value ownership\nmodel](/mojo/manual/values/ownership.html), but before we get into the syntax\nand rules for that, it's important that you understand the principles of value\nsemantics. Generally, it means that each variable has unique access to a value,\nand any code outside the scope of that variable cannot modify its value.\n--- cell type: markdown ---\n## Intro to value semantics\n--- cell type: markdown ---\nIn the most basic situation, sharing a value semantic type means that you create\na copy of the value. This is also known as \"pass by value.\" For example,\nconsider this code:\n--- cell type: code ---\nx = 1\ny = x\ny += 1\n\nprint(x)\nprint(y)\n--- cell type: markdown ---\nWe assigned the value of `x` to `y`, which creates the value for `y` by making a\ncopy of `x`. When we increment `y`, the value of `x` doesn't change. Each\nvariable has exclusive ownership of a value.\n\nWhereas, if a type instead uses reference semantics, then `y` would point to\nthe same value as `x`, and incrementing either one would affect the value for\nboth. Neither `x` nor `y` would \"own\" the value, and any variable would be\nallowed to reference it and mutate it.\n\nHere's another example with a function:\n--- cell type: code ---\ndef add_one(y: Int):\n    y += 1\n    print(y)\n\nx = 1\nadd_one(x)\nprint(x)\n--- cell type: markdown ---\nAgain, the `y` value is a copy and the function cannot modify the original `x`\nvalue.\n\nIf you're familiar with Python, this is probably familiar so far, because the\ncode above behaves the same in Python. However, Python is not value semantic.\nIt gets complicated, but let's consider a situation in which you call a Python\nfunction and pass an object with a pointer to a heap-allocated value. Python\nactually gives that function a reference to your object, which allows the\nfunction to mutate the heap-allocated value. This can cause nasty bugs if\nyou're not careful, because the function might incorrectly assume it has unique\nownership of that object.\n\nIn Mojo, the default behavior for all function arguments is to use value\nsemantics. If the function wants to modify the value of an incoming argument,\nthen it must explicitly declare so, which avoids accidental mutations.\n\nFor starters, all Mojo types passed to a `def` function are passed by value,\nwhich maintains the expected mutability behavior from Python. Except—contrary\nto Python—the function has true ownership of the value, usually because it's a\ncopy.\n\nFor example, even though the Mojo [`Tensor`](/mojo/stdlib/tensor/tensor.html)\ntype allocates values on the heap, when you pass an instance to a `def`\nfunction, it creates a unique copy of all values. Thus, if we modify the\nargument in the function, the original value is unchanged:\n--- cell type: code ---\ndef update_tensor(t: Tensor[DType.uint8]):\n    t[1] = 3\n    print(t)\n\nt = Tensor[DType.uint8](2)\nt[0] = 1\nt[1] = 2\nupdate_tensor(t)\nprint(t)\n--- cell type: markdown ---\nIf this were Python code, the function would modify the original object, because\nPython shares a reference to the original object.\n--- cell type: markdown ---\n### Value semantics in `def` vs `fn`\n--- cell type: markdown ---\nThe arguments above are mutable because a [`def`\nfunction](/mojo/manual/functions.html#def-functions) gets ownership for\nits arguments by default (usually as a copy). Whereas, `fn` functions instead\nreceive arguments as immutable references, by default. This is a memory\noptimization to avoid making unnecessary copies.\n\nFor example, let's create another function with the `fn` declaration. In this\ncase, the `y` argument is immutable by default, so if the function wants to\nmodify the value in the local scope, it needs to make a local copy:\n--- cell type: code ---\nfn add_two(y: Int):\n    # y += 2 # This will cause a compiler error because `y` is immutable\n    # We can instead make an explicit copy:\n    var z = y\n    z += 2\n    print(z)\n\nx = 1\nadd_two(x)\nprint(x)\n--- cell type: markdown ---\nThis is all consistent with value semantics because each variable maintains\nunique ownership of its value.\n\nThe way the `fn` function receives the `y` value is a \"look but don't touch\"\napproach to value semantics. This is also a more memory-efficient approach when\ndealing with memory-intensive arguments, because Mojo doesn't make any copies\nunless we explicitly make the copies ourselves.\n\nThus, the default behavior for `def` and `fn` arguments is fully value\nsemantic: arguments are either copies or immutable references, and any living\nvariable from the callee is not affected by the function.\n\nBut we must also allow reference semantics (mutable references) because it's\nhow we build performant and memory-efficient programs (making copies of\neverything gets really expensive). The challenge is to introduce reference\nsemantics in a way that does not disturb the predictability and safety of value\nsemantics.\n\nThe way we do that in Mojo is, instead of enforcing that every variable have\n\"exclusive access\" to a value, we ensure that every value has an \"exclusive\nowner,\" and destroy each values when the lifetime of its owner ends. \n\nOn the next page about [value\nownership]((/mojo/manual/values/value-semantics.html)), you'll learn how modify\nthe default argument conventions, and safely use reference semantics so every\nvalue has only one owner at a time.\n--- cell type: markdown ---\n## Python-style reference semantics\n--- cell type: markdown ---\n:::{.callout-note}\n\n**Note:** If you will always use strict type declarations, you\ncan skip this section because it only applies to Mojo code using `def`\nfunctions without type declarations (or values declared as\n[`object`](/mojo/stdlib/builtin/object.html#object)).\n\n:::\n\nAs we said at the top of this page, Mojo doesn't enforce value semantics or\nreference semantics. It's up to each type author to decide how an instance of\ntheir type should be created, copied, and moved (see [Value\nlifecycle](/mojo/manual/lifecycle/)). Thus, in order to provide compatibility\nwith Python, Mojo's `object` type is designed to support Python's style of\nargument passing for functions, which is different from the other types in\nMojo.\n\nPython's argument-passing convention is called \"pass by object reference.\" This\nmeans when you pass a variable to a Python function, you actually pass a\nreference to the object, as a value (so it's not strictly reference semantics).\n\nPassing the object reference \"as a value\" means that the argument name is just\na container that acts like an alias to the original object. If you reassign the\nargument inside the function, it does not affect the caller's original value.\nHowever, if you modify the object itself (such as call `append()` on a list),\nthe change is visible to the original object outside the function.\n\nFor example, here's a Python function that receives a list and modifies it:\n--- cell type: code ---\n%%python\ndef modify_list(l):\n    l.append(3)\n    print(\"func:\", l)\n\nar = [1, 2]\nmodify_list(ar)\nprint(\"orig:\", ar)\n--- cell type: markdown ---\nIn this example, it looks like the list is \"passed by reference\" because `l`\nmodifies the original value.\n\nHowever, if the Python function instead _assigns_ a value to `l`, it does not\naffect the original value:\n--- cell type: code ---\n%%python\ndef change_list(l):\n    l = [3, 4]\n    print(\"func:\", l)\n\nar = [1, 2]\nchange_list(ar)\nprint(\"orig:\", ar)\n--- cell type: markdown ---\nThis demonstrates how a Python argument holds the object reference _as a\nvalue_: the function can mutate the original value, but it can also assign a\nnew object to the argument name.\n--- cell type: markdown ---\n### Pass by object reference in Mojo\n--- cell type: markdown ---\nAlthough we haven't finished implementing the\n[`object`](/mojo/stdlib/builtin/object.html#object) type to represent any Mojo\ntype, our intention is to do so, and enable \"pass by object reference\" as\ndescribed above for all dynamic types in a `def` function.\n\nThat means you can have dynamic typing and \"pass by object reference\" behavior\nby simply writing your Mojo code like Python:\n\n1. Use `def` function declarations.\n2. Don't declare argument types.\n\n:::{.callout-note}\n\n**TODO:** Mojo is not a complete superset of Python yet, and there is a lot to\ndo in this department before Mojo supports all of Python's types and behaviors.\nAs such, this is a topic that also still needs a lot of documentation.\n\n:::"
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/manual/variables.ipynb",
        "content": "--- cell type: markdown ---\nA variable is a name that holds a value or object, and it can be either\nmutable and immutable—that is, it can either \"mutate\" (change) or it can't.\n--- cell type: markdown ---\n## Undeclared variables\n\nWithin a `def` function or a REPL environment, you can create a variable with\njust a name and a value. For example:\n--- cell type: code ---\nname = \"Sam\"\n--- cell type: markdown ---\nA variable declared without `var` or `let` is mutable (it defaults to `var`).\n\n\n:::{.callout-note}\n\n**Note:** Undeclared variables are not allowed in an `fn` function or as a struct\nfield.\n\n:::\n--- cell type: markdown ---\n## Mutable `var` and immutable `let` variables\n\nYou can declare a variable as mutable with `var` or as immutable\nwith `let`. For example:\n--- cell type: code ---\nvar name = \"Sam\"  # Mutable\nlet user_id = 42  # Immutable\n--- cell type: markdown ---\nThe `name` variable is mutable, so you can change it later, but if you try to\nchange `id` after it's initialized, you'll get a compiler error. (You can\ninitialize the value later if you [specify the type](#type-annotations).)\n\nUsing `var` helps prevent runtime errors caused by typos. For example, if you\nmisspell the name of an [undeclared variable](#undeclared-variables), Mojo\nsimply instantiates a new variable using the misspelled name. But when all\nmutable variables must be first declared with `var` (which is the case inside\nan `fn` function), then misspellings such as the following are caught by the\ncompiler:\n\n```mojo\nvar name = \"Sam\"\n# Somewhere later...\nnane = \"Sammy\"  # This is not allowed in an `fn` function\n```\n\nSo, although using `var` is optional in a `def` function, the benefit is\nrealized only when used inside an `fn` function, where the Mojo compiler will\nflag undeclared variables (such as the above `nane`) as unknown declarations.\n\nWhereas, declaring an immutable `let` variable (also known as a \"constant\") is\nuseful in any situation where you want to avoid bugs that can occur when a\nvalue is supposed to remain the same but is accidentally changed anyway. By\nusing `let`, the compiler catches these mistakes (in `def` and `fn` functions),\nso they don't cause errors at runtime. Also, because the `let` value is\nguaranteed to not change at runtime, the compiler can make some performance\noptimizations.\n\n:::{.callout-note}\n\n**Note:** When using Mojo in a REPL environment, top-level variables (variables\noutside a function or struct) do not require `var` or `let` declarations.\n\n:::\n--- cell type: markdown ---\n## Type annotations\n--- cell type: markdown ---\nAlthough Mojo supports dynamic variable types (it can infer a value type at\nruntime), it also supports static type annotations on variables. This enables\nstrong compile-time type checking for variables, which can make your code more\npredictable, manageable, and secure (especially when combined with type\nchecking in [`fn` functions](/mojo/manual/functions.html#fn-functions)).\n\nTo specify the type for a variable, add a colon followed by the type name:\n--- cell type: code ---\nvar name: String = \"Sam\"\n--- cell type: markdown ---\nThis way, `name` can never be assigned a value that's not a string (or that\ncannot be [implicitly converted](#implicit-type-conversion) to a string).\n\n:::{.callout-note}\n\n**Note:** You must declare `var` or `let` to use type annotations.\n\n:::\n\nIf a type has a constructor with just one argument, you can initialize it in\ntwo ways:\n--- cell type: code ---\nvar name1: String = \"Sam\"\nvar name2 = String(\"Sam\")\n--- cell type: markdown ---\nBoth of these lines invoke the same constructor to create a `String` from a\n`StringLiteral`.\n--- cell type: markdown ---\n### Late initialization\n--- cell type: markdown ---\nUsing type annotations allows for late initialization. For example, notice here\nthat the `z` variable is first declared with just a type, and the value is\nassigned later:\n--- cell type: code ---\nfn my_function(x: Int):\n    let z: Float32\n    if x != 0:\n        z = 1.0\n    else:\n        z = foo()\n    print(z)\n\nfn foo() -> Float32:\n    return 3.14\n--- cell type: markdown ---\n:::{.callout-note}\n\n**Note:** Late initialization works only if the variable is declared with a\ntype.\n\n:::\n--- cell type: markdown ---\n### Implicit type conversion\n--- cell type: markdown ---\nSome types include built-in type conversion (type casting) from one type into\nits own type. For example, if you assign a number to a `String`, it creates the\nstring `\"1\"` instead of a compiler error:\n--- cell type: code ---\nvar number: String = 1\n--- cell type: markdown ---\nAs shown above, value assignment is just sugaring for a constructor call (which\nspecifies the value type). So, this code uses the\n[`String`](/mojo/stdlib/builtin/string.html#string) constructor that takes an\ninteger: `__init__(inout self, num: Int)`.\n\nThis follows the logic of [overloaded\nfunctions](/mojo/manual/functions.html#overloaded-functions), because\nthat's exactly what's happening here; assigning a number to a `String` variable\nis exactly the same as this:\n--- cell type: code ---\nvar number = String(1)\n--- cell type: markdown ---\nThus, if you call a function that requires an argument of a certain type (such\nas `String`), you can pass in any value as long as that value type can\nimplicitly convert to the required type (using one of the type's overloaded\nconstructors).\n\nFor example, you can pass an `Int` to a function that expects a `String`,\nbecause `String` includes a constructor that takes an `Int`:\n--- cell type: code ---\nfn take_string(version: String):\n    print(version)\n\nfn pass_integer():\n    let version: Int = 1\n    take_string(version)\n--- cell type: markdown ---\n## Variable scopes\n\nVariables declared with `var` and `let` are bound by *lexical scoping*. This\nmeans that nested code blocks can read and modify variables defined in an\nouter scope. Conversely, an outer scope cannot read variables defined in an\ninner scope at all.\n\nFor example, the `if` code block shown here creates an inner scope where outer\nvariables are accessible to read/write, but any new variables do not live\nbeyond the scope of the `if` block:\n--- cell type: code ---\ndef lexical_scopes():\n    let num = 10\n    var dig = 1\n    if True:\n        print(\"num:\", num)  # Reads the outer-scope \"num\"\n        let num = 20        # Creates new inner-scope \"num\"\n        print(\"num:\", num)  # Reads the inner-scope \"num\"\n        dig = 2             # Edits the outer-scope \"dig\"\n    print(\"num:\", num)      # Reads the outer-scope \"num\"\n    print(\"dig:\", dig)      # Reads the outer-scope \"dig\"\n\nlexical_scopes()\n--- cell type: markdown ---\nThe lifetime of the inner `num` ends exactly where the `if` code block ends,\nbecause that's the scope in which the variable was defined.\n\nThis is in contrast to undeclared variables (those without the `var` or `let`\nkeyword), which use **function-level scoping** (consistent with Python variable\nbehavior). That means, when you change the value of an undeclared variable\ninside the `if` block, it actually changes the value for the entire function.\n\nFor example, here's the same code but *without* the `let` declarations:\n--- cell type: code ---\ndef function_scopes():\n    num = 1\n    if num == 1:\n        print(num)   # Reads the function-scope \"num\"\n        num = 2      # Updates the function-scope variable\n        print(num)   # Reads the function-scope \"num\"\n    print(num)       # Reads the function-scope \"num\"\n\nfunction_scopes()\n--- cell type: markdown ---\nNow, the last `print()` function sees the updated `num` value from the inner\nscope, because undeclared variables (Python-style variables) use function-level\nscope (instead of lexical scope)."
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/roadmap.md",
        "content": "---\ntitle: Mojo🔥 roadmap & sharp edges\nsidebar_label: Roadmap & sharp edges\ndescription: A summary of our Mojo plans, including upcoming features and things we need to fix.\nwebsite:\n  open-graph:\n    image: /static/images/mojo-social-card.png\n  twitter-card:\n    image: /static/images/mojo-social-card.png\n---\n\nThis document captures the broad plan about how we plan to implement things in\nMojo, and some early thoughts about key design decisions. This is not a full\ndesign spec for any of these features, but it can provide a \"big picture\" view\nof what to expect over time. It is also an acknowledgement of major missing\ncomponents that we plan to add.\n\n## Overall priorities\n\nMojo is still in early development and many language features will arrive in\nthe coming months. We are highly focused on building Mojo the right way (for\nthe long-term), so we want to fully build-out the core Mojo language features\nbefore we work on other dependent features and enhancements.\n\nCurrently, that means we are focused on the core system programming features\nthat are essential to [Mojo's mission](why-mojo.html), and as outlined in the\nfollowing sections of this roadmap.\n\nIn the near-term, we will **not** prioritize \"general goodness\" work such as:\n\n- Adding syntactic sugar and short-hands for Python.\n- Adding features from other languages that are missing from Python (such as\n  public/private declarations).\n- Tackling broad Python ecosystem challenges like packaging.\n\nIf you have encountered any bugs with current Mojo behavior, please\n[submit an issue on GitHub](https://github.com/modularml/mojo/issues).\n\nIf you have ideas about how to improve the core Mojo features, we prefer that\nyou first look for similar topics or start a new conversation about it\nin our [GitHub Discussions](https://github.com/modularml/mojo/discussions).\n\nWe also consider Mojo to be a new member of the Python family, so if you\nhave suggestions to improve the experience with Python, we encourage\nyou to propose these \"general goodness\" enhancements through the formal [PEP\nprocess](https://peps.python.org/pep-0001/).\n\n### Why not add syntactic sugar or other minor new features?\n\nWe are frequently asked whether Mojo will add minor features that people love\nin other languages but that are missing in Python, such as \"implicit\nreturn\" at the end of a function, public/private access control, fixing Python\npackaging, and various syntactic shorthands.  As mentioned above, we are\nintentionally *not* adding these kinds of features to Mojo right now.\nThere are three major reasons for this:\n\n- First, Mojo is still young: we are still \"building a house\" by laying down\nmajor bricks in the type system and adding system programming features that\nPython lacks. We know we need to implement support for many existing Python\nfeatures (compatibility a massive and important goal of Mojo) and this work\nis not done yet. We have limited engineering bandwidth and want focus on\nbuilding essential functionality, and we will not debate whether certain\nsyntactic sugar is important or not.\n\n- Second, syntactic sugar is like mortar in a building—its best use is to hold\nthe building together by filling in usability gaps. Sugar (and mortar) is\nproblematic to add early into a system: you can run into problems with laying\nthe next bricks because the sugar gets in the way. We have experience building\nother languages (such as Swift) that added sugar early, which could have been\nsubsumed by more general features if time and care were given to broader\nevaluation.\n\n- Third, the Python community should tackle some of these ideas first. It is\nimportant to us that Mojo be a good member of the Python family (a \"Python++\"),\nnot just a language with Pythonic syntax. As such, we don't want to needlessly\ndiverge from Python evolution: adding a bunch of features could lead to\nproblems down the road if Python makes incompatible decisions. Such a future\nwould fracture the community which would cause massively more harm than any\nminor language feature could offset.\n\nFor all these reasons, \"nice to have\" syntactic sugar is not a priority, and we\nwill quickly close such proposals to avoid cluttering the issue tracker. If\nyou'd like to propose a \"general goodness\" syntactic feature, please do so with\nthe existing [Python PEP process](https://peps.python.org/pep-0000/). If/when\nPython adopts a feature, Mojo will also add it, because Mojo's goal is to be a\nsuperset. We are happy with this approach because the Python community is\nbetter equipped to evaluate these features, they have mature code bases to\nevaluate them with, and they have processes and infrastructure for making\nstructured language evolution features.\n\n## Mojo SDK known issues\n\nThe [Mojo SDK](/mojo/manual/get-started/) is still in early development\nand currently only available for Ubuntu Linux and macOS (Apple silicon)\nsystems. Here are some of the notable issues that we plan to fix:\n\n- Missing native support for Windows, Intel Macs, and Linux distributions\n  other than Ubuntu. Currently, we support Ubuntu systems with x86-64\n  processors only. Support for more Linux distributions (including Debian\n  and RHEL) and Windows is in progress.\n\n- Python interoperability might fail when running a compiled Mojo program, with\n  the message\n  `Unable to locate a suitable libpython, please set MOJO_PYTHON_LIBRARY`. This\n  is because we currently do not embed the Python version into the Mojo binary.\n  For details and the workaround, see [issue\n  #551](https://github.com/modularml/mojo/issues/551).\n\n- Mojo programs that import NumPy might fail with the following error:\n\n  ```plaintext\n  Importing the numpy C-extensions failed. This error can happen for\n  many reasons, often due to issues with your setup or how NumPy was\n  installed.\n  ```\n\n  This may occur because the version of NumPy doesn't match the Python\n  interpreter Mojo is using. As a workaround, follow the instructions in\n  [issue #1085](https://github.com/modularml/mojo/issues/1085#issuecomment-1771403719)\n  to install a Python virtual environment using Conda. This can solve many\n  issues with Python interoperability.\n\n- Modular CLI install might fail and require `modular clean` before you\n  re-install.\n\n  If it asks you to perform auth, run `modular auth <MODULAR_AUTH>` and use the\n  `MODULAR_AUTH` value shown for the `curl` command on [the download\n  page](https://developer.modular.com/download).\n\n- `modular install mojo` is slow and might appear unresponsive (as the\n  installer is downloading packages in the background). We will add a progress\n  bar in a future release.\n\n- If you attempt to uninstall Mojo with `modular uninstall`, your subsequent\n  attempt to install Mojo might fail with an HTTP 500 error code. If so, run\n  `modular clean` and try again.\n\n- Mojo REPL might hang (become unresponsive for more than 10 seconds) when\n  interpreting an expression if your system has 4 GiB or less RAM. If you\n  encounter this issue, please report it with your system specs.\n\nAdditionally, we're aware of some issues that we might not be able to solve,\nbut we mention them here with some more information:\n\n- When installing Mojo, if you receive the error,\n  `failed to reach URL https://cas.modular.com`, it could be because your\n  network connection is behind a firewall. Try updating your firewall settings\n  to allow access to these end points: `https://packages.modular.com` and\n  `https://cas.modular.com`. Then retry with `modular clean` and\n  `modular install mojo`.\n\n- When installing Mojo, if you receive the error,\n  `gpg: no valid OpenGPG data found`, this is likely because you are located\n  outside our supported geographies. Due to US export control restrictions, we\n  are unable to provide access to Mojo to users situated in specific countries.\n\n- If using Windows Subsystem for Linux (WSL), you might face issues with WSL 1.\n  We recommend you upgrade to WSL 2. To check the version, run `wsl -l -v`. If\n  you're running WSL 1, refer to the\n  [WSL upgrade instructions](https://learn.microsoft.com/en-us/windows/wsl/install#upgrade-version-from-wsl-1-to-wsl-2).\n\n- When installing on macOS (Apple silicon), the Modular CLI install might fail\n  with the message:\n\n  ```plaintext\n  modular: The arm64 architecture is required for this software.\n  ```\n\n  This occurs because Apple's Rosetta x86 emulation is active. Check the\n  following:\n\n  - Right click on the terminal application you use (for example,\n    `Terminal.app`), click **Get Info**, and make sure the **Open in Rosetta**\n    checkbox is not selected.\n\n  - Run the following command:\n\n    ```bash\n    brew config | grep Rosetta\n    ```\n\n    If the output shows `Rosetta 2: True`, the x86 version of Homebrew is\n    installed.\n    [Uninstall and reinstall Homebrew](https://github.com/homebrew/install#uninstall-homebrew)\n    before retrying the Modular installation.\n\n    **Note:** Before uninstalling Homebrew, verify that you don't have other\n    projects specifically depending on the x86 version of Homebrew.\n\nYou can see other [reported issues on\nGitHub](https://github.com/modularml/mojo/issues).\n\n## Small independent features\n\nThere are a number of features that are missing that are important to round out\nthe language fully, but which don't depend strongly on other features.  These\ninclude things like:\n\n- Improved package management support.\n- Many standard library features, including canonical arrays and dictionary\n  types, copy-on-write data structures, etc.\n- Support for \"top level code\" at file scope.\n- Algebraic data types like `enum` in Swift/Rust, and pattern matching.\n- Many standard library types, including `Optional[T]` and `Result[T, Error]`\n  types when we have algebraic datatypes and basic traits.\n- Support for keyword-only arguments and variadic keyword arguments\n  (`**kwargs`).\n- Support for passing keyword arguments when calling Python functions.\n\n## Ownership and Lifetimes\n\nThe ownership system is partially implemented, and is expected to get built out\nin the next couple of months.  The basic support for ownership includes features\nlike:\n\n- Capture declarations in closures.\n- Borrow checker: complain about invalid mutable references.\n\nThe next step in this is to bring proper lifetime support in.  This will add the\nability to return references and store references in structures safely.  In the\nimmediate future, one can use the unsafe `Pointer` struct to do this like in\nC++.\n\n## Traits support\n\nAs of v0.6.0 Mojo has basic support for\n[traits](/mojo/manual/traits.html#built-in-traits). Traits allow you\nto specify a set of requirements for types to implement. Types can implement\nthose requirements to *conform to* the trait. Traits allow you to write\ngeneric functions and generic containers, which can work with any type that\nconforms to a given trait, instead of being hard-coded to work with a specific\ntype.\n\nCurrently, the only kind of requirements supported by traits are required method\nsignatures. The trait can't provide a default implementation for its required\nmethods, so each conforming type must implement all of the required methods.\n\nA number of [built-in traits](/mojo/manual/traits.html#built-in-traits) are\nalready implemented in the standard library.\n\nWe plan to expand traits support in future releases. Planned features include:\n\n- More traits built in to the standard library, and expanded use of traits\n  throughout the standard library.\n\n- Support for default implementations of required methods.\n\n- Support for a feature like Swift's extensions, allowing you to add a trait to\n  a preexisting type.\n\n## Classes\n\nMojo still doesn't support classes, the primary thing Python programmers use\npervasively!  This isn't because we hate dynamism - quite the opposite.  It is\nbecause we need to get the core language semantics nailed down before adding\nthem.  We expect to provide full support for all the dynamic features in Python\nclasses, and want the right framework to hang that off of.\n\nWhen we get here, we will discuss what the right default is: for example, is\nfull Python hash-table dynamism the default? Or do we use a more efficient\nmodel by default (e.g. vtable-based dispatch and explicitly declared stored\nproperties) and allow opt'ing into dynamism with a `@dynamic` decorator on the\nclass. The latter approach worked well for Swift (its [`@objc`\nattribute](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/attributes/#objc)),\nbut we'll have to prototype to better understand the tradeoffs.\n\n## C/C++ Interop\n\nIntegration to transparently import Clang C/C++ modules.  Mojo's type system\nand C++'s are pretty compatible, so we should be able to have something pretty\nnice here. Mojo can leverage Clang to transparently generate a foreign function\ninterface between C/C++ and Mojo, with the ability to directly import functions:\n\n```mojo\nfrom \"math.h\" import cos\n\nprint(cos(0))\n```\n\n## Full MLIR decorator reflection\n\nAll decorators in Mojo have hard-coded behavior in the parser. In time, we will\nmove these decorators to being compile-time metaprograms that use MLIR\nintegration. This may depend on C++ interop for talking to MLIR. This completely\nopens up the compiler to programmers. Static decorators are functions executed\nat compile-time with the capability to inspect and modify the IR of functions\nand types.\n\n```mojo\nfn value(t: TypeSpec):\n    t.__copyinit__ = # synthesize dunder copyinit automatically\n\n@value\nstruct TrivialType: pass\n\nfn full_unroll(loop: mlir.Operation):\n    # unrolling of structured loop\n\nfn main():\n    @full_unroll\n    for i in range(10):\n        print(i)\n```\n\n## Sharp Edges\n\nThe entire Modular kernel library is written in Mojo, and its development has\nbeen prioritized based on the internal needs of those users. Given that Mojo is\nstill a young language, there are a litany of missing small features that many\nPython and systems programmers may expect from their language, as well as\nfeatures that don't quite work the way we want to yet, and in ways that can be\nsurprising or unexpected. This section of the document describes a variety of\n\"sharp edges\" in Mojo, and potentially how to work around them if needed. We\nexpect all of these to be resolved in time, but in the meantime, they are\ndocumented here.\n\n### No list or dict comprehensions\n\nMojo does not yet support Python list or dictionary comprehension expressions,\nlike `[x for x in range(10)]`, because Mojo's standard library has not yet\ngrown a standard list or dictionary type.\n\n### No `lambda` syntax\n\nMojo does not yet support defining anonymous functions with the `lambda`\nkeyword.\n\n### Parametric aliases\n\nMojo aliases can refer to parametric values but cannot themselves have\nparameter lists. As of v0.6.0, you can create a parametric alias by aliasing\nan unbound or partially-bound type. For example, the new `Scalar` type is\ndefined as:\n\n```mojo\nalias Scalar = SIMD[size=1]\n```\n\nThis creates a parametric alias that you can use like this:\n\n```mojo\nvar i = Scalar[DType.int8]\n```\n\nParametric aliases with an explicit parameter list aren't yet supported:\n\n```mojo\nalias mul2[x: Int] = x * 2\n# Error!\n```\n\n### `Exception` is actually called `Error`\n\nIn Python, programmers expect that exceptions all subclass the `Exception`\nbuiltin class. The only available type for Mojo \"exceptions\" is `Error`:\n\n```mojo\nfn raise_an_error() raises:\n    raise Error(\"I'm an error!\")\n```\n\nThe reason we call this type `Error` instead of `Exception` is because it's not\nreally an exception. It's not an exception, because raising an error does not\ncause stack unwinding, but most importantly it does not have a stack trace. And\nwithout polymorphism, the `Error` type is the only kind of error that can be\nraised in Mojo right now.\n\n### No Python-style generator functions\n\nMojo does not yet support Python-style generator functions (`yield` syntax).\nThese are \"synchronous co-routines\" -- functions with multiple suspend points.\n\n### No `async for` or `async with`\n\nAlthough Mojo has support for async functions with `async fn` and `async def`,\nMojo does not yet support the `async for` and `async with` statements.\n\n### The `rebind` builtin\n\nOne of the consequences of Mojo not performing function instantiation in the\nparser like C++ is that Mojo cannot always figure out whether some parametric\ntypes are equal and complain about an invalid conversion. This typically occurs\nin static dispatch patterns, like:\n\n```mojo\nfn take_simd8(x: SIMD[DType.float32, 8]): pass\n\nfn generic_simd[nelts: Int](x: SIMD[DType.float32, nelts]):\n    @parameter\n    if nelts == 8:\n        take_simd8(x)\n```\n\nThe parser will complain,\n\n```log\nerror: invalid call to 'take_simd8': argument #0 cannot be converted from\n'SIMD[f32, nelts]' to 'SIMD[f32, 8]'\n        take_simd8(x)\n        ~~~~~~~~~~^~~\n```\n\nThis is because the parser fully type-checks the function without instantiation,\nand the type of `x` is still `SIMD[f32, nelts]`, and not `SIMD[f32, 8]`, despite\nthe static conditional. The remedy is to manually \"rebind\" the type of `x`,\nusing the `rebind` builtin, which inserts a compile-time assert that the input\nand result types resolve to the same type after function instantiation.\n\n```mojo\nfn generic_simd[nelts: Int](x: SIMD[DType.float32, nelts]):\n    @parameter\n    if nelts == 8:\n        take_simd8(rebind[SIMD[DType.float32, 8]](x))\n```\n\n### Scoping and mutability of statement variables\n\nPython programmers understand that local variables are implicitly declared and\nscoped at the function level. As the programming manual explains, this feature\nis supported in Mojo only inside `def` functions. However, there are some\nnuances to Python's implicit declaration rules that Mojo does not match 1-to-1.\n\nFor example, the scope of `for` loop iteration variables and caught exceptions\nin `except` statements is limited to the next indentation block, for both `def`\nand `fn` functions. Python programmers will expect the following program to\nprint \"2\":\n\n```python\nfor i in range(3): pass\nprint(i)\n```\n\nHowever, Mojo will complain that `print(i)` is a use of an unknown declaration.\nThis is because whether `i` is defined at this line is dynamic in Python. For\ninstance the following Python program will fail:\n\n```python\nfor i range(0): pass\nprint(i)\n```\n\nWith `NameError: name 'i' is not defined`, because the definition of `i` is a\ndynamic characteristic of the function. Mojo's lifetime tracker is intentionally\nsimple (so lifetimes are easy to use!), and cannot reason that `i` would be\ndefined even when the loop bounds are constant.\n\nAlso stated in the programming manual: in `def` functions, the function\narguments are mutable and re-assignable, whereas in `fn`, function arguments are\nrvalues and cannot be re-assigned. The same logic extends to statement\nvariables, like `for` loop iteration variables or caught exceptions:\n\n```mojo\ndef foo():\n    try:\n        bad_function():\n    except e:\n        e = Error() # ok: we can overwrite 'e'\n\nfn bar():\n    try:\n        bad_function():\n    except e:\n        e = Error() # error: 'e' is not mutable\n```\n\n### Name scoping of nested function declarations\n\nIn Python, nested function declarations produce dynamic values. They are\nessentially syntax sugar for `bar = lambda ...`.\n\n```python\ndef foo():\n    def bar(): # creates a function bound to the dynamic value 'bar'\n        pass\n    bar() # indirect call\n```\n\nIn Mojo, nested function declarations are static, so calls to them are direct\nunless made otherwise.\n\n```mojo\nfn foo():\n    fn bar(): # static function definition bound to 'bar'\n        pass\n    bar() # direct call\n    let f = bar # materialize 'bar' as a dynamic value\n    f() # indirect call\n```\n\nCurrently, this means you cannot declare two nested functions with the same\nname. For instance, the following example does not work in Mojo:\n\n```mojo\ndef pick_func(cond):\n    if cond:\n        def bar(): return 42\n    else:\n        def bar(): return 3 # error: redeclaration of 'bar'\n    return bar\n```\n\nThe functions in each conditional must be explicitly materialized as dynamic\nvalues.\n\n```mojo\ndef pick_func(cond):\n    let result: def() capturing # Mojo function type\n    if cond:\n        def bar0(): return 42\n        result = bar0\n    else:\n        def bar1(): return 3 # error: redeclaration of 'bar'\n        result = bar1\n    return result\n```\n\nWe hope to sort out these oddities with nested function naming as our model\nof closures in Mojo develops further.\n\n### Limited polymorphism\n\nMojo has implemented static polymorphism through traits, as noted above. We\nplan to implement dynamic polymorphism through classes and MLIR reflection in\nthe future.\n\nPython programmers are used to implementing special dunder methods on their\nclasses to interface with generic methods like `print()` and `len()`. For\ninstance, one expects that implementing `__repr__()` or `__str__()` on a class\nwill enable that class to be printed using `print()`.\n\n```python\nclass One:\n    def __init__(self): pass\n    def __repr__(self): return '1'\n\nprint(One()) # prints '1'\n```\n\nMojo currently supports this feature through the\n[`Stringable`](/mojo/stdlib/builtin/str.html#stringable) trait, so that\n`print()` works on all `Stringable` types. Similar support exists for the\n[`int()`](/mojo/stdlib/builtin/int.html#int-1) and\n[`len()`](/mojo/stdlib/builtin/len.html#len) functions. We'll continue to\nadd traits support to the standard library to enable common use cases like this.\n\n### Lifetime tracking inside collections\n\nWith traits, it is now possible to build collection types like lists, maps, and\nsets that invoke element destructors. However, most standard library collection\ntypes haven't yet been extended to use traits.\n\nFor collections of trivial types, like `Int`, this is no problem, but for\ncollections of types with lifetimes, like `String`, the elements have to be\nmanually destructed. Doing so requires quite an ugly pattern, shown in the next\nsection.\n\nThe `DynamicVector` type has been updated to use traits, and invokes destructors\nproperly.\n\n### No safe value references\n\nMojo does not have proper lifetime marker support yet, and that means it cannot\nreason about returned references, so Mojo doesn't support them. You can return\nor keep unsafe references by passing explicit pointers around.\n\n```mojo\nstruct StringRef:\n    var ref: Pointer[SI8]\n    var size: Int\n    # ...\n\nfn bar(x: StringRef): pass\n\nfn foo():\n    let s: String = \"1234\"\n    let ref: StringRef = s # unsafe reference\n    bar(ref)\n    _ = s # keep the backing memory alive!\n```\n\nMojo will destruct objects as soon as it thinks it can. That means the lifetime\nof objects to which there are unsafe references must be manually extended. See\nthe [Death of a value](/mojo/manual/lifecycle/death.html)\nfor more details. This disables the RAII pattern in Mojo.  Context managers and\n`with` statements are your friends in Mojo.\n\nNo lvalue returns also mean that implementing certain patterns require magic\nkeywords until proper lifetime support is built. One such pattern is retrieving\nan unsafe reference from an object.\n\n```mojo\nstruct UnsafeIntRef:\n    var ptr: Pointer[Int]\n\nfn printIntRef(x: UnsafeIntRef):\n    # \"deference\" operator\n    print(__get_address_as_lvalue(x.ptr)) # Pointer[Int] -> &Int\n\nvar c: Int = 10\n# \"reference\" operator\nlet ref = UnsafeIntRef(__get_lvalue_as_address(c)) # &Int -> Pointer[Int]\n```\n\n### Parameter closure captures are unsafe references\n\nYou may have seen nested functions, or \"closures\", annotated with the\n`@parameter` decorator. This creates a \"parameter closure\", which behaves\ndifferently than a normal \"stateful\" closure. A parameter closure declares a\ncompile-time value, similar to an `alias` declaration. That means parameter\nclosures can be passed as parameters:\n\n```mojo\nfn take_func[f: fn() capturing -> Int]():\n    pass\n\nfn call_it(a: Int):\n    @parameter\n    fn inner() -> Int:\n        return a # capture 'a'\n\n    take_func[inner]() # pass 'inner' as a parameter\n```\n\nParameter closures can even be parametric and capturing:\n\n```mojo\nfn take_func[f: fn[a: Int]() capturing -> Int]():\n    pass\n\nfn call_it(a: Int):\n    @parameter\n    fn inner[b: Int]() -> Int:\n        return a + b # capture 'a'\n\n    take_func[inner]() # pass 'inner' as a parameter\n```\n\nHowever, note that parameter closures are always capture by *unsafe* reference.\nMojo's lifetime tracking is not yet sophisticated enough to form safe references\nto objects (see above section). This means that variable lifetimes need to be\nmanually extended according to the lifetime of the parametric closure:\n\n```mojo\nfn print_it[f: fn() capturing -> String]():\n    print(f())\n\nfn call_it():\n    let s: String = \"hello world\"\n    @parameter\n    fn inner() -> String:\n        return s # 's' captured by reference, so a copy is made here\n    # lifetime tracker destroys 's' here\n\n    print_it[inner]() # crash! 's' has been destroyed\n```\n\nThe lifetime of the variable can be manually extended by discarding it\nexplicitly.\n\n```mojo\nfn call_it():\n    let s: String = \"hello world\"\n    @parameter\n    fn inner() -> String:\n        return s\n\n    print_it[inner]()\n    _ = s^ # discard 's' explicitly\n```\n\nA quick note on the behaviour of \"stateful\" closures. One sharp edge here is\nthat stateful closures are *always* capture-by-copy; Mojo lacks syntax for\nmove-captures and the lifetime tracking necessary for capture-by-reference.\nStateful closures are runtime values -- they cannot be passed as parameters,\nand they cannot be parametric. However, a nested function is promoted to a\nparametric closure if it does not capture anything. That is:\n\n```mojo\nfn foo0[f: fn() capturing -> String](): pass\nfn foo1[f: fn[a: Int]() capturing -> None](): pass\n\nfn main():\n    let s: String = \"hello world\"\n    fn stateful_captures() -> String:\n        return s # 's' is captured by copy\n\n    foo0[stateful_captures]() # not ok: 'stateful_captures' is not a parameter\n\n    fn stateful_nocapture[a: Int](): # ok: can be parametric, since no captures\n        print(a)\n\n    foo1[stateful_nocapture]() # ok: 'stateful_nocapture' is a parameter\n```\n\n### The standard library has limited exceptions use\n\nFor historic and performance reasons, core standard library types typically do\nnot use exceptions. For instance, `DynamicVector` will not raise an\nout-of-bounds access (it will crash), and `Int` does not throw on divide by\nzero. In other words, most standard library types are considered \"unsafe\".\n\n```mojo\nlet v = DynamicVector[Int](0)\nprint(v[1]) # could crash or print garbage values (undefined behaviour)\n\nprint(1//0) # does not raise and could print anything (undefined behaviour)\n```\n\nThis is clearly unacceptable given the strong memory safety goals of Mojo. We\nwill circle back to this when more language features and language-level\noptimizations are avaiable.\n\n### Nested functions cannot be recursive\n\nNested functions (any function that is not a top-level function) cannot be\nrecursive in any way. Nested functions are considered \"parameters\", and although\nparameter values do not have to obey lexical order, their uses and definitions\ncannot form a cycle. Current limitations in Mojo mean that nested functions,\nwhich are considered parameter values, cannot be cyclic.\n\n```mojo\nfn try_recursion():\n    fn bar(x: Int): # error: circular reference :<\n        if x < 10:\n            bar(x + 1)\n```\n\n### Only certain loaded MLIR dialects can be accessed\n\nAlthough Mojo provides features to access the full power of MLIR, in reality\nonly a certain number of loaded MLIR dialects can be accessed in the Playground\nat the moment.\n\nThe upstream dialects available in the Playground are the\n[`index`](https://mlir.llvm.org/docs/Dialects/IndexOps/) dialect and the\n[`LLVM`](https://mlir.llvm.org/docs/Dialects/LLVM/) dialect.\n"
    },
    {
        "url": "https://github.com/modularml/mojo/blob/main/docs/why-mojo.md",
        "content": "---\ntitle: Why Mojo🔥\nsidebar_label: Why Mojo\ndescription: A backstory and rationale for why we created the Mojo language.\nwebsite:\n  open-graph:\n    image: /static/images/mojo-social-card.png\n  twitter-card:\n    image: /static/images/mojo-social-card.png\n---\n\nWhen we started Modular, we had no intention of building a new programming\nlanguage. But as we were building our [platform to unify the world's ML/AI\ninfrastructure](https://www.modular.com/blog/the-case-for-a-next-generation-ai-developer-platform),\nwe realized that programming across the entire stack was too complicated. Plus,\nwe were writing a lot of MLIR by hand and not having a good time.\n\nWhat we wanted was an innovative and scalable programming model that could\ntarget accelerators and other heterogeneous systems that are pervasive in\nthe AI field. This meant a programming language with powerful compile-time\nmetaprogramming, integration of adaptive compilation techniques, caching\nthroughout the compilation flow, and other features that are not supported by\nexisting languages.\n\nAnd although accelerators are important, one of the most prevalent and\nsometimes overlooked \"accelerators\" is the host CPU. Nowadays, CPUs have lots of\ntensor-core-like accelerator blocks and other AI acceleration units, but they\nalso serve as the \"fallback\" for operations that specialized accelerators\ndon't handle, such as data loading, pre- and post-processing, and integrations\nwith foreign systems. So it was clear that we couldn't lift AI with just an\n\"accelerator language\" that worked with only specific processors.\n\nApplied AI systems need to address all these issues, and we decided there was\nno reason it couldn't be done with just one language. Thus, Mojo was born.\n\n## A language for next-generation compiler technology {#mlir}\n\nWhen we realized that no existing language could solve the challenges in\nAI compute, we embarked on a first-principles rethinking of how a programming\nlanguage should be designed and implemented to solve our problems. Because we\nrequire high-performance support for a wide variety of accelerators,\ntraditional compiler technologies like LLVM and GCC were not suitable (and any\nlanguages and tools based on them would not suffice). Although they support a\nwide range of CPUs and some commonly used GPUs, these compiler technologies\nwere designed decades ago and are unable to fully support modern chip\narchitectures. Nowadays, the standard technology for specialized machine\nlearning accelerators is MLIR.\n\n[MLIR](https://mlir.llvm.org/) is a relatively new open-source compiler\ninfrastructure started at Google (whose leads moved to Modular) that has been\nwidely adopted across the machine learning accelerator community. MLIR’s\nstrength is its ability to build _domain specific_ compilers, particularly for\nweird domains that aren’t traditional CPUs and GPUs, such as AI ASICS, [quantum\ncomputing systems](https://github.com/PennyLaneAI/catalyst), FPGAs, and [custom\nsilicon](https://circt.llvm.org/).\n\nGiven our goals at Modular to build a next-generation AI platform, we were\nalready using MLIR for some of our infrastructure, but we didn't have a\nprogramming language that could unlock MLIR's full potential across our stack.\nWhile many other projects now use MLIR, Mojo is the first major language\ndesigned expressly _for MLIR_, which makes Mojo uniquely powerful when writing\nsystems-level code for AI workloads.\n\n## A member of the Python family\n\nOur core mission for Mojo includes innovations in compiler internals and\nsupport for current and emerging accelerators, but don't see any need to\ninnovate in language _syntax_ or _community_. So we chose to embrace the Python\necosystem because it is so widely used, it is loved by the AI ecosystem, and\nbecause we believe it is a really nice language.\n\nThe Mojo language has lofty goals: we want full compatibility with the Python\necosystem, we want predictable low-level performance and low-level control, and\nwe need the ability to deploy subsets of code to accelerators. Additionally, we\ndon't want to create a fragmented software ecosystem—we don't want Python\nusers who adopt Mojo to draw comparisons to the painful migration from Python 2\nto 3. These are no small goals!\n\nFortunately, while Mojo is a brand-new code base, we aren't really starting\nfrom scratch conceptually. Embracing Python massively simplifies our design\nefforts, because most of the syntax is already specified. We can instead focus\nour efforts on building Mojo's compilation model and systems programming\nfeatures. We also benefit from tremendous lessons learned from other languages\n(such as Rust, Swift, Julia, Zig, Nim, etc.), from our prior experience\nmigrating developers to new compilers and languages, and we leverage the\nexisting MLIR compiler ecosystem.\n\nFurther, we decided that the right _long-term goal_ for Mojo is to provide a\n**superset of Python** (that is, to make Mojo compatible with existing Python\nprograms) and to embrace the CPython implementation for long-tail ecosystem\nsupport. If you're a Python programmer, we hope that Mojo is immediately\nfamiliar, while also providing new tools to develop safe and performant\nsystems-level code that would otherwise require C and C++ below Python.\n\nWe aren't trying to convince the world that \"static is best\" or \"dynamic is\nbest.\" Rather, we believe that both are good when used for the right\napplications, so we designed Mojo to allow you, the programmer, to decide when\nto use static or dynamic.\n\n### Why we chose Python\n\nPython is the dominant force in ML and countless other fields. It's easy to\nlearn, known by important cohorts of programmers, has an amazing community, has\ntons of valuable packages, and has a wide variety of good tooling. Python\nsupports the development of beautiful and expressive APIs through its dynamic\nprogramming features, which led machine learning frameworks like TensorFlow and\nPyTorch to embrace Python as a frontend to their high-performance runtimes\nimplemented in C++.\n\nFor Modular today, Python is a non-negotiable part of our API surface\nstack—this is dictated by our customers. Given that everything else in our\nstack is negotiable, it stands to reason that we should start from a\n\"Python-first\" approach.\n\nMore subjectively, we believe that Python is a beautiful language. It's\ndesigned with simple and composable abstractions, it eschews needless\npunctuation that is redundant-in-practice with indentation, and it's built with\npowerful (dynamic) metaprogramming features. All of which provide a runway for\nus to extend the language to what we need at Modular. We hope that people in\nthe Python ecosystem see our direction for Mojo as taking Python ahead to the\nnext level—completing it—instead of competing with it.\n\n## Compatibility with Python\n\nWe plan for full compatibility with the Python ecosystem, but there are actually\ntwo types of compatibility, so here's where we currently stand on them both:\n\n- In terms of your ability to import existing Python modules and use them in a\nMojo program, Mojo is 100% compatible because we use CPython for\ninteroperability.\n\n- In terms of your ability to migrate any Python code to Mojo, it's not fully\ncompatible yet. Mojo already supports many core features from Python, including\nasync/await, error handling, variadics, and so on. However, Mojo is still young\nand missing many other features from Python. Mojo doesn't even support classes\nyet!\n\nThere is a lot of work to be done, but we're confident we'll get there, and\nwe're guided by our team's experience building other major technologies with\ntheir own compatibility journeys:\n\n- The journey to the [Clang compiler](https://clang.llvm.org/) (a\ncompiler for C, C++, Objective-C, CUDA, OpenCL, and others), which is a\n\"compatible replacement\" for GCC, MSVC and other existing compilers. It is hard\nto make a direct comparison, but the complexity of the Clang problem appears to\nbe an order of magnitude bigger than implementing a compatible replacement for\nPython.\n\n- The journey to the [Swift programming language](https://www.swift.org/),\nwhich embraced the Objective-C runtime and language ecosystem, and progressively\nmigrated millions of programmers (and huge amounts of code). With Swift, we\nlearned lessons about how to be \"run-time compatible\" and cooperate with a\nlegacy runtime.\n\nIn situations where you want to mix Python and Mojo code, we expect Mojo to\ncooperate directly with the CPython runtime and have similar support for\nintegrating with CPython classes and objects without having to compile the code\nitself. This provides plug-in compatibility with a massive ecosystem of\nexisting code, and it enables a progressive migration approach in which\nincremental migration to Mojo yields incremental benefits.\n\nOverall, we believe that by focusing on language design and incremental\nprogress towards full compatibility with Python, we will get where we\nneed to be in time.\n\nHowever, it's important to understand that when you write pure Mojo code, there\nis nothing in the implementation, compilation, or runtime that uses any\nexisting Python technologies. On its own, it is an entirely new language with\nan entirely new compilation and runtime system.\n\n### Intentional differences from Python\n\nWhile Python compatibility and migratability are key to Mojo's success, we also\nwant Mojo to be a first-class language (meaning that it's a standalone language\nrather than dependent upon another language). It should not be limited in its\nability to introduce new keywords or grammar productions merely to maintain\ncompatibility. As such, our approach to compatibility is two-fold:\n\n1. We utilize CPython to run all existing Python 3 code\nwithout modification and use its runtime, unmodified, for full compatibility\nwith the entire ecosystem. Running code this way provides no benefit from Mojo,\nbut the sheer existence and availability of this ecosystem will rapidly\naccelerate the bring-up of Mojo, and leverage the fact that Python is really\ngreat for high-level programming already.\n\n2. We will provide a mechanical migration tool that provides very good\ncompatibility for people who want to migrate code from Python to Mojo. For\nexample, to avoid migration errors with Python code that uses identifier names\nthat match Mojo keywords, Mojo provides a backtick feature that allows any\nkeyword to behave as an identifier.\n\nTogether, this allows Mojo to integrate well in a mostly-CPython world, but\nallows Mojo programmers to progressively move code (a module or file\nat a time) to Mojo. This is a proven approach from the Objective-C to\nSwift migration that Apple performed.\n\nIt will take some time to build the rest of Mojo and the migration support, but\nwe are confident that this strategy allows us to focus our energies and avoid\ndistractions. We also think the relationship with CPython can build in both\ndirections—wouldn't it be cool if the CPython team eventually reimplemented the\ninterpreter in Mojo instead of C? 🔥\n\n## Python's problems\n\nBy aiming to make Mojo a superset of Python, we believe we can solve many of\nPython's existing problems.\n\nPython has some well-known problems—most obviously, poor low-level performance\nand CPython implementation details like the global interpreter lock (GIL),\nwhich makes Python single-threaded. While there are many active projects\nunderway to improve these challenges, the issues brought by Python go deeper\nand are particularly impactful in the AI field. Instead of talking about those\ntechnical limitations in detail, we'll talk about their implications here in\n2023.\n\nNote that everywhere we refer to Python in this section is referring to the\nCPython implementation. We'll talk about other implementations later.\n\n### The two-world problem\n\nFor a variety of reasons, Python isn't suitable for systems programming.\nFortunately, Python has amazing strengths as a glue layer, and low-level\nbindings to C and C++ allow building libraries in C, C++ and many other\nlanguages with better performance characteristics. This is what has enabled\nthings like NumPy, TensorFlow, PyTorch, and a vast number of other libraries\nin the ecosystem.\n\nUnfortunately, while this approach is an effective way to build\nhigh-performance Python libraries, it comes with a cost: building\nthese hybrid libraries is very complicated. It requires low-level understanding\nof the internals of CPython, requires knowledge of C/C++ (or other) programming\n(undermining one of the original goals of using Python in the first place),\nmakes it difficult to evolve large frameworks, and (in the case of ML) pushes\nthe world towards \"graph based\" programming models, which have worse fundamental\nusability than \"eager mode\" systems. Both TensorFlow and PyTorch have faced\nsignificant challenges in this regard.\n\nBeyond the fundamental nature of how the two-world problem creates system\ncomplexity, it makes everything else in the ecosystem more complicated.\nDebuggers generally can't step across Python and C code, and those that can\naren't widely accepted. It's painful that the Python package ecosystems has to\ndeal with C/C++ code in addition to Python. Projects like PyTorch, with\nsignificant C++ investments, are intentionally trying to move more of their\ncodebase to Python because they know it gains usability.\n\n### The three-world and N-world problem\n\nThe two-world problem is commonly felt across the Python ecosystem, but things\nare even worse for developers of machine learning frameworks. AI is pervasively\naccelerated, and those accelerators use bespoke programming languages like\nCUDA. While CUDA is a relative of C++, it has its own special problems and\nlimitations, and it does not have consistent tools like debuggers or profilers.\nIt is also effectively locked into a single hardware maker.\n\nThe AI world has an incredible amount of innovation on the hardware front, and\nas a consequence, complexity is spiraling out of control. There are now several\nattempts to build limited programming systems for accelerators (OpenCL, Sycl,\nOneAPI, and others). This complexity explosion is continuing to increase and\nnone of these systems solve the fundamental fragmentation in the tools and\necosystem that is hurting the industry so badly—they're _adding to the\nfragmentation_.\n\n### Mobile and server deployment\n\nAnother challenge for the Python ecosystem is deployment. There are many facets\nto this, including how to control dependencies, how to deploy hermetically\ncompiled \"a.out\" files, and how to improve multi-threading and performance.\nThese are areas where we would like to see the Python ecosystem take\nsignificant steps forward.\n\n## Related work\n\nWe are aware of many other efforts to improve Python, but they do not solve the\n[fundamental problem](#mlir) we aim to solve with Mojo.\n\nSome ongoing efforts to improve Python include work to speed up Python and\nreplace the GIL, to build languages that look like Python but are subsets of\nit, and to build embedded domain-specific languages (DSLs) that integrate with\nPython but which are not first-class languages. While we cannot provide an\nexhaustive list of all the efforts, we can talk about some challenges faced in\nthese projects, and why they don't solve the problems that Mojo does.\n\n### Improving CPython and JIT compiling Python\n\nRecently, the community has spent significant energy on improving CPython\nperformance and other implementation issues, and this is showing huge results.\nThis work is fantastic because it incrementally improves the current CPython\nimplementation. For example, Python 3.11 has increased performance 10-60% over\nPython 3.10 through internal improvements, and [Python\n3.12](https://github.com/faster-cpython/ideas/wiki/Python-3.12-Goals) aims to\ngo further with a trace optimizer. Many other projects are attempting to tame\nthe GIL, and projects like PyPy (among many others) have used JIT compilation\nand tracing approaches to speed up Python.\n\nWhile we are fans of these great efforts, and feel they are valuable and\nexciting to the community, they unfortunately do not satisfy our needs at\nModular, because they do not help provide a unified language onto an\naccelerator. Many accelerators these days support very limited dynamic\nfeatures, or do so with terrible performance. Furthermore, systems programmers\ndon't seek only \"performance,\" but they also typically want a lot of\n**predictability and control** over how a computation happens.\n\nWe are looking to eliminate the need to use C or C++ within Python libraries,\nwe seek the highest performance possible, and we cannot accept dynamic features\nat all in some cases. Therefore, these approaches don't help.\n\n### Python subsets and other Python-like languages\n\nThere are many attempts to build a \"deployable\" Python, such as TorchScript\nfrom the PyTorch project. These are useful because they often provide\nlow-dependency deployment solutions and sometimes have high performance.\nBecause they use Python-like syntax, they can be easier to learn than a novel\nlanguage.\n\nOn the other hand, these languages have not seen wide adoption—because they are\na subset of Python, they generally don't interoperate with the Python\necosystem, don't have fantastic tooling (such as debuggers), and often\nchange-out inconvenient behavior in Python unilaterally, which breaks\ncompatibility and fragments the ecosystem further. For example, many of these\nchange the behavior of simple integers to wrap instead of producing\nPython-compatible math.\n\nThe challenge with these approaches is that they attempt to solve a weak point\nof Python, but they aren't as good at Python's strong points. At best, these\ncan provide a new alternative to C and C++, but without solving the dynamic\nuse-cases of Python, they cannot solve the \"two world problem.\" This approach\ndrives fragmentation, and incompatibility makes _migration_ difficult to\nimpossible—recall how challenging it was to migrate from Python 2 to Python 3.\n\n### Python supersets with C compatibility\n\nBecause Mojo is designed to be a superset of Python with improved systems\nprogramming capabilities, it shares some high-level ideas with other Python\nsupersets like [Pyrex](https://wiki.python.org/moin/Pyrex) and\n[Cython](https://cython.org/). Like Mojo, these projects define their own\nlanguage that also support the Python language. They allow you to write more\nperformant extensions for Python that interoperate with both Python and C\nlibraries.\n\nThese Python supersets are great for some kinds of applications, and they've\nbeen applied to great effect by some popular Python libraries. However, they\ndon't solve [Python's two-world problem](#the-two-world-problem) and because\nthey rely on CPython for their core semantics, they can't work without it,\nwhereas Mojo uses CPython only when necessary to provide [compatibility with\nexisting Python code](#compatibility-with-python). Pure Mojo code does not use\nany pre-existing runtime or compiler technologies, it instead uses an\n[MLIR-based infrastructure](#mlir) to enable high-performance execution on a\nwide range of hardware.\n\n### Embedded DSLs in Python\n\nAnother common approach is to build an embedded domain-specific languages\n(DSLs) in Python, typically installed with a Python decorator. There are many\nexamples of this (the `@tf.function` decorator in TensorFlow, the\n`@triton.jit` in OpenAI's Triton programming model, etc.). A major benefit of\nthese systems is that they maintain compatibility with the Python\necosystem of tools, and integrate natively into Python logic, allowing an\nembedded mini language to co-exist with the strengths of Python for dynamic use\ncases.\n\nUnfortunately, the embedded mini-languages provided by these systems often have\nsurprising limitations, don't integrate well with debuggers and other workflow\ntooling, and do not support the level of native language integration that we\nseek for a language that unifies heterogeneous compute and is the primary way\nto write large-scale kernels and systems.\n\nWith Mojo, we hope to move the usability of the overall system forward by\nsimplifying things and making it more consistent. Embedded DSLs are an\nexpedient way to get demos up and running, but we are willing to put in the\nadditional effort and work to provide better usability and predictability for\nour use-case.\n\nTo learn about what we've built with Mojo so far, see the [Mojo\nManual](/mojo/manual/).\n"
    }
]